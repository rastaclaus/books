Мега учебник Flask
==================

Глава 1. Привет, Мир!
---------------------

::: {#post-content-body .post__text .post__text-html io-article-url="https://habr.com/ru/post/346306/"}
### Установка Python

Если на вашем компьютере не установлен **Python** , установите его. Если ваша операционная система не имеет предустановленный пакет Python, вы можете скачать программу установки с [официального сайта Python](http://python.org/download/) . Если вы используете Microsoft Windows вместе с WSL или Cygwin, обратите внимание, что вы не будете использовать родную версию Python для Windows, а версию, совместимую с Unix, которую вам нужно получить от Ubuntu (если вы используете WSL) или от Cygwin.

Чтобы убедиться, что ваша установка Python является функциональной, вы можете открыть окно терминала и ввести python3, или если это не работает, просто python. Вот что вам следует ожидать:

    $ python3
    Python 3.5.2 (default, Nov 17 2016, 17:05:23)
    [GCC 5.4.0 20160609] on linux
    Type "help", "copyright", "credits" or "license" for more information.
    >>> _

или так в cmd (окно командной строки Microsoft Windows) :

    c:\cp>c:\python33\python
    Python 3.3.5 (v3.3.5:62cf4e77f785, Mar  9 2014, 10:37:12) [MSC v.1600 32 bit (In
    tel)] on win32
    Type "help", "copyright", "credits" or "license" for more information.
    >>>

Интерпретатор Python теперь находится в ожидании пользовательского ввода. В будущих главах вы узнаете, для чего это интерактивное приглашение полезно. Но пока Вы подтвердили, что Python установлен в вашей системе. Чтобы выйти из интерактивного приглашения, вы можете ввести `exit()` и нажать Enter.

В версиях Python для Linux и Mac OS X вы также можете выйти из интерпретатора, нажав `Ctrl-D` .

В Windows, комбинация клавиш для выхода --- `Ctrl-Z` , затем Enter.

### Установка Flask

Следующий шаг --- установить Flask, но прежде чем я расскажу об этом, я хочу рассказать вам о лучших методах, связанных с установкой пакетов Python.

В Python пакеты, такие как Flask, доступны в общем репозитории, откуда их можно загрузить и установить. Официальный репозиторий пакетов Python называется [PyPI](https://pypi.python.org/pypi) , что означает Python Package Index (также известный, как «cheese shop»). Установка пакета из PyPI очень проста, потому что у Python есть инструмент под названием pip, который выполняет эту работу (в Python 2.7 `pip` не входит в комплект с Python и его нужно устанавливать отдельно).

Чтобы установить пакет на свой компьютер, вы используете pip следующим образом:

    $ pip install <package-name>

Интересно, что этот метод установки пакетов не будет работать в большинстве случаев. Если ваш интерпретатор Python был установлен глобально для всех пользователей вашего компьютера, велика вероятность того, что ваша обычная учетная запись пользователя не получит разрешения на внесение в нее изменений, поэтому единственный способ выполнить вышеприведенную команду --- запустить ее от имени администратора. Но даже без этого осложнения поймите, что происходит, когда вы устанавливаете пакет, как указанным выше способом. Инструмент `pip` загрузит пакет из PyPI, а затем добавит его в вашу папку Python. С этого момента каждый скрипт Python, который у вас есть в вашей системе, будет иметь доступ к этому пакету. Представьте ситуацию, когда вы закончили веб-приложение с использованием версии 0.11 Flask, которая была самой последней версией Flask при запуске, но теперь она была заменена версией 0.12. Теперь вы хотите запустить второе приложение, для которого вы хотели бы использовать версию 0.12, но если вы замените установленную версию 0.11, вы рискуете сломать свое старое приложение. Вы видите проблему? Было бы идеально, если бы можно было установить Flask 0.11, который будет использоваться вашим старым приложением, а также установить Flask 0.12 для Вашего нового.

Чтобы решить проблему поддержки различных версий пакетов для разных приложений, Python использует концепцию виртуальных сред. Виртуальная среда --- это полная копия интерпретатора Python. Когда вы устанавливаете пакеты в виртуальной среде, общесистемный интерпретатор Python не затрагивается, только копия. Таким образом, решение иметь полную свободу для установки любых версий ваших пакетов для каждого приложения --- использовать другую виртуальную среду для каждого приложения. Виртуальные среды имеют дополнительное преимущество, они принадлежат пользователю, который их создает, поэтому им не требуется учетная запись администратора.

Начнем с создания каталога, в котором будет жить проект. Я собираюсь назвать этот каталог **microblog** , так как это имя приложения:

    $ mkdir microblog
    $ cd microblog

Если вы используете версию Python 3, в нее включена поддержка виртуальной среды, поэтому все, что вам нужно сделать для ее создания, это:

    $ python3 -m venv venv

С помощью этой команды Python запустит пакет `venv` , который создает виртуальную среду с именем `venv` . Первым `venv` в команде является имя пакета виртуальной среды Python, а второе --- имя виртуальной среды, которое я буду использовать для этой конкретной среды. Если вы считаете, что это сбивает с толку, вы можете заменить второй `venv` другим именем, которое вы хотите назначить своей виртуальной среде. В общем, я создаю свои виртуальные среды с именем `venv` в каталоге проекта, поэтому всякий раз, когда я подключаюсь к проекту, я нахожу его соответствующую виртуальную среду.

Обратите внимание, что в некоторых операционных системах вам может понадобиться использовать `python` вместо `python3` в приведенной выше команде. Некоторые установки используют `python` для релизов Python 2.x и python3 для релизов 3.x, в то время как другие отображают `python` в выпусках 3.x.

По завершении команды вы будете иметь каталог с именем `venv` , где хранятся файлы виртуальной среды.

Если вы используете любую версию Python старше 3.4 (включая выпуск 2.7), виртуальные среды не поддерживаются изначально. Для этих версий Python вам необходимо загрузить и установить сторонний инструмент [virtualenv](https://virtualenv.pypa.io/) , прежде чем создавать виртуальные среды. После того, как `virtualenv` установлен, вы можете создать виртуальную среду со следующей командой:

    $ virtualenv venv

или так

    $ python virtualenv.py venv

***Прим.переводчика:** У меня установлено несколько версий Python. Я использую Python3.3. В моем случае пришлось вводить строку так:*

    C:\microblog>c:\Python33\python.exe c:\Python33\Lib\site-packages\virtualenv.py venv

*В полученном сообщении видно, что установлен `pip` и ряд пакетов:*

    Using base prefix 'c:\\Python33'
    New python executable in C:\microblog\venv\Scripts\python.exe
    Installing setuptools, pip, wheel...done.

Независимо от метода, который вы использовали для его создания, вы создали свою виртуальную среду. Теперь вам нужно сообщить системе, что вы хотите ее использовать, активируя ее. Чтобы активировать новую виртуальную среду, используете следующую команду:

    $ source venv/bin/activate
    (venv) $ _

Если вы используете cmd (окно командной строки Microsoft Windows), команда активации немного отличается:

    $ venv\Scripts\activate
    (venv) $ _

Когда вы активируете виртуальную среду, конфигурация сеанса терминала изменяется так, что интерпретатор Python, хранящийся внутри нее, станет тем, который вызывается при вводе `python` . Кроме того, в запросе терминала включено имя активированной виртуальной среды. Изменения, внесенные в сеанс терминала, являются временными и частными для этого сеанса, поэтому они не будут сохраняться при закрытии окна терминала. Если вы одновременно работаете с несколькими терминальными окнами, отлично видно, чтобы на каждом из них были задействованы разные виртуальные среды.

Теперь, когда вы создали и активировали виртуальную среду, вы можете, наконец, установить в нее Flask:

    (venv) C:\microblog>pip install flask
    Collecting flask
      Using cached Flask-0.12.2-py2.py3-none-any.whl
    Requirement already satisfied: click>=2.0 in c:\python33\lib\site-packages (from flask)
    Requirement already satisfied: Werkzeug>=0.7 in c:\python33\lib\site-packages (from flask)
    Requirement already satisfied: Jinja2>=2.4 in c:\python33\lib\site-packages (from flask)
    Requirement already satisfied: itsdangerous>=0.21 in c:\python33\lib\site-packages (from flask)
    Requirement already satisfied: markupsafe in c:\python33\lib\site-packages (from Jinja2>=2.4->flask)
    Installing collected packages: flask
    Successfully installed flask-0.12.2

    (venv) C:\microblog>

Если вы хотите проверить, что в вашей виртуальной среде установлен Flask, вы можете запустить интерпретатор Python и импортировать Flask в него:

    (venv) C:\microblog>python
    Python 3.3.5 (v3.3.5:62cf4e77f785, Mar  9 2014, 10:37:12) [MSC v.1600 32 bit (Intel)] on win32
    Type "help", "copyright", "credits" or "license" for more information.
    >>> import flask
    >>>

Если этот импорт не дает вам никаких ошибок, вы можете поздравить себя, так как `Flask` установлен и готов к использованию.

### Flask приложение «Привет, мир»

Если вы зайдете на [сайт Flask](http://flask.pocoo.org/) , вас приветствует очень простое примерное приложение с пятью строками кода. Вместо того, чтобы повторять этот тривиальный пример, я покажу вам немного более сложный, который даст вам хорошую базовую структуру для написания больших приложений.

Приложение будет существовать в виде пакета.

***Прим.переводчика:** Пакет --- это коллекция модулей.*

В Python подкаталог, содержащий файл `__init__.py` , считается пакетом и может быть импортирован. Когда вы импортируете пакет, `__init__.py` выполняет и определяет, какие символы предоставляют пакет для внешнего мира.

Давайте создадим пакет под названием `app` , в котором будет размещено приложение. Убедитесь, что вы находитесь в каталоге `microblog` , а затем выполните следующую команду:

    (venv) $ mkdir app

`__init__.py` для пакета приложения будет содержать следующий код:

    from flask import Flask

    app = Flask(__name__)

    from app import routes

Сценарий выше просто создает объект приложения как экземпляр класса Flask, импортированного из пакета flask. Переменная `__name__` , переданная в класс Flask, является предопределенной переменной Python, которая задается именем модуля, в котором она используется. Flask использует расположение модуля, переданного здесь как отправную точку, когда ему необходимо загрузить связанные ресурсы, такие как файлы шаблонов, которые я расскажу в **главе 2** . Для всех практических целей передача `__name__` почти всегда будет настраивать flask в правильном направлении. Затем приложение импортирует модуль `routes` , который еще не существует.

Один из аспектов, который может показаться запутанным вначале, состоит в том, что существуют два объекта с именем *app* . Пакет приложения определяется каталогом приложения и сценарием `__init__.py` и указан в инструкции `routes` импорта приложения. Переменная *app* определяется как экземпляр класса Flask в сценарии `__init__.py` , что делает его частью пакета приложения.

Другая особенность заключается в том, что модуль `routes` импортируется внизу, а не наверху скрипта, как это всегда делается. Нижний импорт является обходным путем для циклического импорта, что является общей проблемой при использовании приложений Flask. Вы увидите, что модуль `routes` должен импортировать переменную приложения, определенную в этом скрипте, поэтому, поместив один из взаимных импортов внизу, вы избежите ошибки, которая возникает из взаимных ссылок между этими двумя файлами.

Так что же входит в модуль `routes` ? `routes` --- это разные URL-адреса, которые приложение реализует. В Flask обработчики маршрутов приложений записываются как функции Python, называемые функциями просмотра. Функции просмотра сопоставляются с одним или несколькими URL-адресами маршрутов, поэтому Flask знает, какую логику следует выполнять, когда клиент запрашивает данный URL-адрес.

Вот ваша первая функция просмотра, которую вам нужно написать в новом модуле с именем `app/routes.py` :

    from app import app

    @app.route('/')
    @app.route('/index')
    def index():
        return "Hello, World!"

Эта функция просмотра на самом деле довольно проста, она просто возвращает приветствие в виде строки. Две странные строки `@app.route` над функцией --- декораторы, уникальная особенность языка Python. Декоратор изменяет функцию, которая следует за ней. Общий шаблон с декораторами --- использовать их для регистрации функций как обратных вызовов для определенных событий. В этом случае декоратор `@app.route` создает связь между URL-адресом, заданным как аргумент, и функцией. В этом примере есть два декоратора, которые связывают URL-адреса `/` и `/index` с этой функцией. Это означает, что когда веб-браузер запрашивает один из этих двух URL-адресов, Flask будет вызывать эту функцию и передавать возвращаемое значение обратно в браузер в качестве ответа. Если вам кажется, что это еще не имеет смысла, это будет недолго, пока вы запустите это приложение.

Чтобы завершить приложение, вам нужно создать сценарий Python на верхнем уровне, определяющий экземпляр приложения Flask. Давайте назовем этот скрипт *microblog.py* и определим его как одну строку, которая импортирует экземпляр приложения:

    from app import app

Помните два объекта `app` ? Здесь вы можете видеть оба вместе в одном предложении. Экземпляр приложения Flask называется `app` и входит в пакет *app* . from app import app импортирует переменную `app` , входящую в пакет *app* . Если вы считаете это запутанным, вы можете переименовать либо пакет, либо переменную во что то другое.

Чтобы убедиться, что вы все делаете правильно, ниже приведена диаграмма структуры проекта:

    microblog/
      venv/
      app/
        __init__.py
        routes.py
      microblog.py

Верьте или нет, но первая версия приложения завершена! Прежде чем запускать его, Flask нужно сообщить, как его импортировать, установив переменную среды `FLASK_APP` :

    (venv) $ export FLASK_APP=microblog.py

Если вы используете Microsoft Windows, используйте команду \'set\' вместо \'export\' в команде выше.

Готовы ли вы быть потрясены? Вы можете запустить свое первое веб-приложение со следующей командой:

    (venv) $ flask run
     * Serving Flask app "microblog"
     * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)

***Прим.переводчика:** Я был потрясен поскольку получил ошибку кодировки. Если у вас версия Python старше 3.6 вас скорее всего ждет сюрприз. Типа:*

    Syntax Error: (unicode error) 'utf-8' codec can't decode byte 0xcf in position 0: invalid continuation byte:

*В моем случае виноваты кириллические символы ПК в имени компьютера. Заменил на PK и все заработало. Виноват модуль socket*

    (venv) C:\microblog>python
    Python 3.3.5 (v3.3.5:62cf4e77f785, Mar  9 2014, 10:37:12) [MSC v.1600 32 bit (Intel)] on win32
    Type "help", "copyright", "credits" or "license" for more information.
    >>> from socket import gethostbyaddr
    >>> gethostbyaddr('127.0.0.1')
    ('Acer-PK', [], ['127.0.0.1'])
    >>>

*Действительно все заработало:*

    (venv) C:\microblog>set FLASK_APP=microblog.py

    (venv) C:\microblog>flask run
     * Serving Flask app "microblog"
     * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)

![](https://habrastorage.org/getpro/habr/post_images/ca3/239/dde/ca3239dde36652d873aee1315472a64a.png)

Что бы написать по русски \"Привет, Мир!\" потребуется скорректировать модуль *routes.py*

Добавить строку `# -*- coding: utf-8 -*-`

    # -*- coding: utf-8 -*-
    from app import app

    @app.route('/')
    @app.route('/index')
    def index():
        return "Привет, Мир!"

![](https://habrastorage.org/getpro/habr/post_images/ecf/279/f37/ecf279f3796c921f601d668f92a9aaf1.png)

Когда вы закончите играть с сервером, вы можете просто нажать Ctrl-C, чтобы остановить его.

Поздравляем, вы совершили первый большой шаг, чтобы стать веб-разработчиком!
:::

Глава 2: Шаблоны
----------------

::: {#post-content-body .post__text .post__text-html io-article-url="https://habr.com/ru/post/346340/"}
### Краткое повторение

После завершения **главы 1** вы должны иметь полностью работающее, но простое веб-приложение, имеющее следующую структуру файлов:

    microblog\
      venv\
      app\
        __init__.py
        routes.py
      microblog.py

Для запуска приложения вы установили `FLASK_APP=microblog.py` в сеансе терминала, а затем выполняете запуск flask. Он запустит веб-сервер с приложением, которое вы можете открыть, введя `http://localhost:5000` / URL в адресной строке вашего веб-браузера.

В этой главе вы продолжите работу над тем же приложением, и, в частности, вы узнаете, как создавать более сложные веб-страницы, которые имеют более навороченную структуру и множество динамических компонентов. Если что-либо о приложении или технологическом процессе разработки пока неясно, перед продолжением просмотрите **главу 1** .

*Ссылки GitHub для этой главы:* [Browse](https://github.com/miguelgrinberg/microblog/tree/v0.2) , [Zip](https://github.com/miguelgrinberg/microblog/archive/v0.2.zip) , [Diff](https://github.com/miguelgrinberg/microblog/compare/v0.1...v0.2) .

### Что такое шаблоны?

Я хочу, чтобы на домашней странице моего приложения для микроблогов был заголовок, приветствующий пользователя. На данный момент я проигнорирую тот факт, что приложение еще не имеет концепции пользователей, поскольку это произойдет позже. Вместо этого я собираюсь использовать вымышленного (mock) пользователя, которого я собираюсь реализовать как словарь Python, следующим образом:

    user = {'username': 'Miguel'}

Создание mock-объектов --- полезный метод, который позволяет вам сосредоточиться на одной части приложения, не беспокоясь о других частях системы, которые еще не существуют. Я хочу создать домашнюю страницу своего приложения, и я не хочу, чтобы отсутствие системы пользователя отвлекало меня. Поэтому я просто создаю объект пользователя.

Функция просмотра в приложении возвращает простую строку. Теперь я хочу расширить эту возвращаемую строку в полную HTML-страницу, возможно, что-то вроде этого:

    from app import app

    @app.route('/')
    @app.route('/index')
    def index():
        user = {'username': 'miguel'}
        return '''
    <html>
        <head>
            <title>Home Page - Microblog</title>
        </head>
        <body>
            <h1>Hello, ''' + user['username'] + '''!</h1>
        </body>
    </html>'''

Если Вы не знакомы с HTML, я рекомендую, чтобы Вы прочитали [Markup HTML](https://en.wikipedia.org/wiki/HTML#Markup) в Википедии для краткого введения.

Обновите функцию представления как показано выше и смотрите в Вашем браузере.

![](https://habrastorage.org/getpro/habr/post_images/a6c/ca5/d78/a6cca5d7872928142742befaf988ccb8.png)

Я надеюсь, Вы согласитесь со мной, что решение, используемое выше, не достаточно хорошо. Подумайте, насколько сложным будет код в этом представлении, когда у меня появятся сообщения в блоге от пользователей, которые будут постоянно меняться. Приложение также будет иметь больше функций просмотра, которые будут связаны с другими URL-адресами, поэтому представьте, если в один прекрасный день я решу изменить макет этого приложения и придется обновлять HTML в каждом представлении. Это явно не вариант, который будет масштабироваться по мере роста приложения.

Если бы вы могли сохранить логику своего приложения отдельно от макета или презентации ваших веб-страниц, тогда все было бы намного лучше организовано, не так ли? Вы даже можете нанять веб-дизайнера для создания убойного сайта, когда вы закодируете логику приложения в Python.

Шаблоны помогают достичь этого разделения между презентацией и бизнес-логикой. В Flask шаблоны записываются как отдельные файлы, хранящиеся в папке `templates` , которая находится внутри пакета приложения. Поэтому, убедившись, что вы находитесь в каталоге `microblog` , создайте каталог, в котором будут храниться шаблоны:

    (venv) $ mkdir app/templates

или так:

    (venv) C:\microblog>mkdir app\templates

Ниже вы можете увидеть свой первый шаблон, который похож по функциональности на страницу HTML, возвращаемую функцией просмотра `index()` выше. Запишите этот файл в `app/templates/index.html` :

    <html>
        <head>
            <title>{{ title }} - Microblog</title>
        </head>
        <body>
            <h1>Hello, {{ user.username }}!</h1>
        </body>
    </html>

Это стандартная, очень простая HTML-страница. Единственная интересная вещь на этой странице состоит в том, что для динамического контента есть несколько заполнителей, заключенных в `{{...}}` разделы. Эти заполнители представляют части страницы, которые являются переменными и будут определены только во время выполнения.

Теперь, когда презентация страницы была выгружена в шаблон HTML, функция просмотра может быть упрощена (файл *\\app\\routes.py* ):

    # -*- coding: utf-8 -*- 
    from flask import render_template
    from app import app

    @app.route('/')
    @app.route('/index')
    def index():
        user = {'username': 'Miguel'}
        return render_template('index.html', title='Home', user=user)

Это выглядит намного лучше, не так ли? Попробуйте эту новую версию приложения, чтобы посмотреть, как работает шаблон. Как только вы загрузите страницу в свой браузер, вы можете просмотреть исходный HTML-код и сравнить его с исходным шаблоном.

Операция, которая преобразует шаблон в полную HTML-страницу, называется рендерингом. Чтобы отобразить шаблон, мне пришлось импортировать функцию, которая поставляется с флаговой инфраструктурой под названием `render_template()` . Эта функция принимает имя файла шаблона и переменную список аргументов шаблона и возвращает один и тот же шаблон, но при этом все заполнители в нем заменяются фактическими значениями.

Функция `render_template()` вызывает механизм шаблонов `Jinja2` , который поставляется в комплекте с Flask. `Jinja2` заменяет блоки `{{...}}` соответствующими значениями, заданными аргументами, указанными в вызове `render_template()` .

### Условные операторы

Вы видели, как `Jinja2` заменяет заполнители фактическими значениями во время рендеринга, но это всего лишь одна из многих мощных операций, поддерживаемых `Jinja2` в файлах шаблонов. Например, шаблоны также поддерживают управляющие операторы, заданные внутри блоков `{% ...%}` . Следующая версия шаблона `index.html` добавляет условное выражение:

    <html>
        <head>
            {% if title %}
            <title>{{ title }} - Microblog</title>
            {% else %}
            <title>Welcome to Microblog!</title>
            {% endif %}
        </head>
        <body>
            <h1>Hello, {{ user.username }}!</h1>
        </body>
    </html>

Теперь шаблон немного умнее. Если функция просмотра забывает передать значение переменной заполнитель заголовка, вместо того, чтобы показывать пустой заголовок, шаблон предоставит значение по умолчанию. Вы можете попробовать, как это условие работает, удалив аргумент *title* в вызове `render_template()` функции view (файл *\\app\\routes.py* ).

### Циклы

Пользователь, вошедший в систему, вероятно, захочет увидеть последние сообщения от подключенных пользователей на домашней странице, поэтому теперь я собираюсь расширить приложение, для поддержки этого.

Еще раз, использую трюк с поддельным объектом, чтобы создать некоторых пользователей и некоторые сообщения, для демонстрации:

    # -*- coding: utf-8 -*-
    from flask import render_template
    from app import app

    @app.route('/')
    @app.route('/index')
    def index():
        user = {'username': 'Эльдар Рязанов'}
        posts = [
            {
                'author': {'username': 'John'},
                'body': 'Beautiful day in Portland!'
            },
            {
                'author': {'username': 'Susan'},
                'body': 'The Avengers movie was so cool!'
            }, 
            {
                'author': {'username': 'Ипполит'},
                'body': 'Какая гадость эта ваша заливная рыба!!'
            }
        ]
        return render_template('index.html', title='Home', user=user, posts=posts)

Для представления пользовательских сообщений я использую список, где каждый элемент является словарем, имеющим поля `Author` и `Body` . Когда я доберусь до реализации пользователей и сообщений в блоге по-настоящему, я постараюсь сохранить эти имена полей, чтобы вся работа, которую сделал для проектирования и тестирования шаблона домашней страницы, используя эти временные объекты, продолжала действовать и на момент когда я представляю реальных пользователей и сообщения из базы данных.

На стороне шаблона я должен решить новую проблему. Список сообщений может иметь любое количество элементов. Сколько сообщений будут представлены на странице? Шаблон не может делать какие-либо предположения о том, сколько записей существует, поэтому он должен быть готов к отображению стольких сообщений, сколько отправляет представление общим способом.

Для этого типа проблемы, Jinja2 предлагает `for` структуры управления (файл app/templates/index.html):

    <html>
        <head>
            {% if title %}
            <title>{{ title }} - Microblog</title>
            {% else %}
            <title>Welcome to Microblog</title>
            {% endif %}
        </head>
        <body>
            <h1>Hi, {{ user.username }}!</h1>
            {% for post in posts %}
            <div><p>{{ post.author.username }} says: <b>{{ post.body }}</b></p></div>
            {% endfor %}
        </body>
    </html>

Просто, не так ли? Попробуйте эту новую версию приложения и не забудьте поиграть с добавлением большего количества контента в список сообщений, чтобы увидеть, как шаблон адаптируется и всегда отображает все сообщения, отправляемые функцией представления.

![](https://habrastorage.org/getpro/habr/post_images/c94/3d2/521/c943d252179e2597cac7488b11a456e6.png)

***Прим.переводчика:** Все не так просто с кодировками. Я попробовал заменить приветствие на `Превед` и получил ошибку. Следите за кодировкой файла index.html. Он должен быть сохранен в utf-8.*

![](https://habrastorage.org/getpro/habr/post_images/8c2/76a/10a/8c276a10aa7e496c520baf391ddb4464.png)

### Наследование шаблонов

В большинстве веб-приложений вверху страницы имеется панель навигации с несколькими часто используемыми ссылками, такими как ссылка для редактирования вашего профиля, логина, выхода из системы и т.д. Я могу легко добавить панель навигации в `index.html` шаблон с некоторым количеством HTML, но по мере того, как приложение будет расти, мне понадобится эта же панель навигации на других страницах. Не хотелось бы поддерживать несколько копий навигационной панели во многих HTML-шаблонах, это хорошая практика, обходиться без дублирования кода, если это возможно.

*Jinja2* имеет функцию наследования шаблона, которая специально решает эту проблему. По существу, вы можете перемещать части макета страницы, которые являются общими для всех шаблонов, к базовому шаблону, из которого выводятся все остальные шаблоны.

Итак, теперь я определяю базовый шаблон `base.html` , который включает в себя простую навигационную панель, а также логику заголовка, которую я реализовал ранее. Вам необходимо написать следующий шаблон в файле `app/templates/base.html` :

    <html>
        <head>
          {% if title %}
          <title>{{ title }} - Microblog</title>
          {% else %}
          <title>Welcome to Microblog</title>
          {% endif %}
        </head>
        <body>
            <div>Microblog: <a href="/index">Home</a></div>
            <hr>
            {% block content %}{% endblock %}
        </body>
    </html>

В этом шаблоне я использовал оператор управления блоком, чтобы определить место, где производные шаблоны могут вставляться. Блокам присваивается уникальное имя, которое производные шаблоны могут ссылаться, когда они предоставляют свой контент.

С базовым шаблоном я теперь могу упростить `index.html` , *наследуя* его от `base.html` :

    {% extends "base.html" %}

    {% block content %}
        <h1>Hi, {{ user.username }}!</h1>
        {% for post in posts %}
        <div><p>{{ post.author.username }} says: <b>{{ post.body }}</b></p></div>
        {% endfor %}
    {% endblock %}

Поскольку шаблон *base.html* теперь будет заботиться об общей структуре страницы, я удалил все эти элементы из *index.html* и оставил только часть содержимого. Оператор `extends` устанавливает ссылку наследования между двумя шаблонами, так что Jinja2 знает, что когда ему предлагается визуализировать `index.html` , он должен встроить его в `base.html` . Два шаблона имеют согласованные операторы `block` с именами `content` , и именно так Jinja2 знает, как объединить два шаблона в один. Теперь, если мне нужно создать дополнительные страницы для приложения, я могу создать их как производные шаблоны из одного и того же шаблона `base.html` , и именно так я могу иметь все страницы приложения, которые будут одинаково выглядеть и выглядеть без дублирования.

![](https://habrastorage.org/getpro/habr/post_images/72e/eb0/28e/72eeb028e1177e620fdf40219ad2af66.png)
:::

Глава 3: Веб-формы
------------------

::: {#post-content-body .post__text .post__text-html io-article-url="https://habr.com/ru/post/346342/"}
### Краткое повторение

В **главе 2** я создал простой шаблон для домашней страницы приложения и использовал ложные сущности в качестве заполнителей для объектов, которых у меня еще нет, таких как пользователи или сообщения в блогах. В этой главе я расскажу об одном из многих явлений, которые у меня есть в этом приложении, в частности, как принимать входные данные от пользователей через веб-формы.

Веб-формы являются одним из самых основных строительных блоков в любом веб-приложении. Я буду использовать формы, чтобы пользователи могли отправлять сообщения в блоге, а также для входа в приложение.

Прежде чем продолжить читать эту главу, убедитесь, что у вас есть приложение `microblog` . Работа проделанная в предыдущей главе должна позволить запустить его без каких-либо ошибок.

*Ссылки GitHub для этой главы:* [Browse](https://github.com/miguelgrinberg/microblog/tree/v0.3) , [Zip](https://github.com/miguelgrinberg/microblog/archive/v0.3.zip) , [Diff](https://github.com/miguelgrinberg/microblog/compare/v0.2...v0.3) .

### Введение в Flask-WTF

Чтобы обрабатывать веб-формы в этом приложении, я собираюсь использовать расширение [Flask-WTF](http://packages.python.org/Flask-WTF) , которое представляет собой обертку пакета [WTForms](https://wtforms.readthedocs.io/) и прекрасно интегрирует его с Flask. Это первое расширение Flask, которое я вам представляю, но не последнее. Расширения являются очень важной частью экосистемы Flask, поскольку они обеспечивают решения проблем.

Расширения Flask --- это обычные пакеты Python, которые устанавливаются вместе с `pip` . Надо установить Flask-WTF в свою виртуальную среду:

    (venv) $ pip install flask-wtf

### Конфигурация

Пока что приложение очень простое, и по этой причине мне не нужно было беспокоиться о его конфигурации. Но для любых приложений, кроме простейших, вы обнаружите, что Flask (и, возможно, также используемые расширения Flask) предлагают некоторую свободу в том, как делать что-то, и вам нужно принять некоторые решения, которые вы передаете в качестве списка переменных конфигурации.

Для указания параметров конфигурации существует несколько форматов. Самое основное решение --- определить ваши переменные как ключи в app.config, который использует стиль словаря для работы с переменными. Например, вы можете сделать что-то вроде этого:

    app = Flask(__name__)
    app.config['SECRET_KEY'] = 'you-will-never-guess'
    # ... add more variables here as needed

Хотя вышеприведенного синтаксиса достаточно для создания параметров конфигурации для Flask, мне нравится применять принцип разделения проблем, поэтому вместо того, чтобы ставить мою конфигурацию в том же месте, где я создаю свое приложение, я буду использовать несколько более сложную структуру, которая позволяет мне сохранить мою конфигурацию в отдельном файле.

Формат, который мне очень нравится, поскольку он расширяемый, заключается в использовании класса для хранения переменных конфигурации. Чтобы все было хорошо организовано, я собираюсь создать класс конфигурации в отдельном модуле Python. Ниже вы можете увидеть новый класс конфигурации для этого приложения, хранящийся в модуле **config.py** в каталоге [верхнего(!!!) уровня.]{.underline}

![](https://habrastorage.org/webt/ft/-e/gk/ft-egkbseevmalbrgqlucegufmu.png)

    import os

    class Config(object):
        SECRET_KEY = os.environ.get('SECRET_KEY') or 'you-will-never-guess'

Довольно просто, не так ли? Параметры конфигурации определяются как переменные класса внутри класса `Config` . Поскольку для приложения требуется больше элементов конфигурации, они могут быть добавлены в этот класс, а позже, если я обнаружу, что мне нужно иметь более одного набора конфигурации, я могу создать его подклассы. Но пока об этом не беспокойтесь.

Переменная конфигурации `SECRET_KEY` , которую я добавил как единственный элемент конфигурации, является важной частью большинства приложений Flask. Flask и некоторые его расширения используют значение секретного ключа в качестве криптографического ключа, полезного для генерации подписей или токенов. Расширение Flask-WTF использует его для защиты веб-форм от противной атаки под названием [Cross-Site Request Forgery](http://en.wikipedia.org/wiki/Cross-site_request_forgery) или CSRF (произносится как «seasurf»). Как следует из его названия, секретный ключ должен быть секретным, поскольку сила токенов и подписей, генерируемых им, зависит от того, что никто за пределами круга доверенных лиц сопровождающих приложения не знает об этом.

Значение секретного ключа задается как выражение с двумя терминами, к которым присоединяется оператор `OR` . Первый термин ищет значение переменной среды, также называемой SECRET\_KEY. Второй термин, это просто жестко закодированная строка. Это шаблон, который вы увидите, что я часто повторяю для конфигурационных переменных. Идея в том, что значение, появляющееся из переменной среды, предпочтительнее, но если среда не определяет переменную, то вместо нее используется жестко закодированная строка. При разработке этого приложения требования к безопасности невелики, поэтому можно просто игнорировать этот параметр и позволить использовать жестко закодированную строку. Но когда это приложение развертывается на рабочем сервере, я буду устанавливать уникальное и трудно угадываемое значение, так что сервер будет иметь безопасный ключ, который никто не знает.

Теперь, когда у меня есть файл конфигурации, мне нужно, чтобы Flask прочитал его и применил. Это можно сделать сразу после создания экземпляра приложения Flask с использованием метода `app.config.from_object()` ( `app\__init__.py` ):

    from flask import Flask
    from config import Config

    app = Flask(__name__)
    app.config.from_object(Config)

    from app import routes

То, как я импортирую класс Config, может показаться запутанным сначала, но если вы посмотрите, как класс Flask (в верхнем регистре «F») импортируется из flask пакета (нижний регистр «f»), вы заметите, что я делаю то же самое с конфигурацией. Строковый «config» --- это имя модуля python config.py, и, очевидно, тот, который имеет верхний регистр «C», является фактическим классом.

Как я упоминал выше, элементы конфигурации могут быть доступны со словарным синтаксисом из app.config. Здесь вы можете увидеть быстрый сеанс с интерпретатором Python, где я проверяю, каково значение секретного ключа:

    >>> from microblog import app
    >>> app.config['SECRET_KEY']
    'you-will-never-guess'

### Форма входа пользователя

Расширение Flask-WTF использует классы Python для представления веб-форм. Класс формы просто определяет поля формы как переменные класса.

Еще раз имея в виду разделение проблем, я собираюсь использовать новый *app/forms.py* модуль для хранения классов веб-форм. Для начала определим форму входа пользователя, в которой пользователю будет предложено ввести имя пользователя и пароль. Форма также будет включать флажок \"Запомнить меня\" и кнопку Отправить:

    from flask_wtf import FlaskForm
    from wtforms import StringField, PasswordField, BooleanField, SubmitField
    from wtforms.validators import DataRequired

    class LoginForm(FlaskForm):
        username = StringField('Username', validators=[DataRequired()])
        password = PasswordField('Password', validators=[DataRequired()])
        remember_me = BooleanField('Remember Me')
        submit = SubmitField('Sign In')

Большинство расширений Flask используют соглашение об именах flask\_ для импорта верхнего уровня. В этом случае Flask-WTF меняет все свои символы под flask\_wtf. Здесь базовый класс FlaskForm импортируется из верхней части `app/forms.py` .

Четыре класса, которые представляют типы полей, которые я использую для этой формы, импортируются непосредственно из пакета WTForms, поскольку расширение Flask-WTF не предоставляет настраиваемые версии. Для каждого поля объект создается как переменная класса в классе `LoginForm` . Каждому полю присваивается описание или метка в качестве первого аргумента.

Дополнительный аргумент `validators` , который вы видите в некоторых полях, используется для привязки поведения проверки к полям. Валидатор DataRequired просто проверяет, что поле не отправлено пустым. Существует еще много доступных валидаторов, некоторые из которых будут использоваться в других формах.

### Шаблоны форм

Следующим шагом является добавление формы в шаблон HTML, чтобы ее можно было визуализировать на веб-странице. Поля, определенные в классе `LoginForm` , знают, как визуализировать себя как HTML, поэтому эта задача довольно проста. Ниже вы можете увидеть шаблон входа в систему, который я собираюсь хранить в файле `app/templates/login.html` :

> `app/templates/login.html` : Шаблон формы входа в систему ( Код исправлен в связи с изменениями в оригинале статьи 2018-06-09. Спасибо [magax](https://habr.com/users/magax/) ! )

    {% extends "base.html" %}

    {% block content %}
        <h1>Sign In</h1>
        <form action="" method="post" novalidate>
            {{ form.hidden_tag() }}
            <p>
                {{ form.username.label }}<br>
                {{ form.username(size=32) }}
            </p>
            <p>
                {{ form.password.label }}<br>
                {{ form.password(size=32) }}
            </p>
            <p>{{ form.remember_me() }} {{ form.remember_me.label }}</p>
            <p>{{ form.submit() }}</p>
        </form>
    {% endblock %}

Для этого шаблона я повторно использую еще один раз `base.html` , как показано в [главе 2](https://habrahabr.ru/post/346340/) , через инструкцию расширенного наследования шаблона. На самом деле я сделаю это со всеми шаблонами, чтобы обеспечить единообразную компоновку, которая включает верхнюю панель навигации по всем страницам приложения.

В этом шаблоне предполагается, что объект формы, созданный из класса `LoginForm` , будет предоставлен в качестве аргумента, который можно увидеть как ссылку `form` . Этот аргумент будет отправлен функцией просмотра входа, которую я до сих пор не написал.

Элемент `HTML` `<form>` используется в качестве контейнера для веб-формы. Атрибут `action` формы используется для того, чтобы сообщить веб-браузеру URL-адрес, который должен использоваться при отправке информации, введенной пользователем в форму. Если для действия задана пустая строка, форма передается URL-адресу, находящемуся в данный момент в адресной строке, то есть URL-адресу, который визуализирует форму на странице. Атрибут `method` указывает метод HTTP-запроса, который должен использоваться при отправке формы на сервер. По умолчанию он отправляется с запросом `GET` , но почти во всех случаях использование `POST` запрос, улучшающий взаимодействие с пользователем, поскольку запросы этого типа могут отправлять данные формы в тело запроса, в то время как запросы `GET` добавляют поля формы к URL-адресу, загромождая адресную строку обозревателя.

> *Добавлено 2018-06-09* Спасибо за замечания [magax](https://habr.com/users/magax/) ! Атрибут `novalidate` используется для указания веб-браузеру не применять проверку к полям в этой форме, что фактически оставляет эту задачу приложению Flask, запущенному на сервере. Использование `novalidate` является полностью необязательным, но **для этой первой формы важно** , чтобы вы установили его, потому что это позволит вам протестировать проверку на стороне сервера позже в этой главе

Аргумент шаблона `form.hidden_tag()` создает скрытое поле, содержащее токен, используемый для защиты формы от атак CSRF. Все, что вам нужно сделать, чтобы форма была защищена, --- это включить это скрытое поле и определить переменную `SECRET_KEY` в конфигурации Flask. Если вы позаботитесь об этих двух вещах, Flask-WTF сделает все остальное за вас.

Если вы уже писали HTML Web Forms в прошлом, возможно, вы сочли странным, что в этом шаблоне нет HTML-полей. Это происходит потому, что поля из объекта Form знают, как визуализировать себя как HTML. Все, что мне нужно было сделать, это включить `{{ form.<field_name>.label }}` в месте где нужна метка поля и `{{ form.<field_name>() }}` где нужно само поле. Для полей, которым требуются дополнительные атрибуты HTML, они могут быть переданы в качестве аргументов. Поля username и Password в этом шаблоне принимают `size` размер в качестве аргумента, который будет добавлен в HTML-элемент `<input>` в качестве атрибута. Таким образом можно также присоединять классы CSS или идентификаторы к полям формы.

### Представление формы

Заключительный шаг перед тем, как вы увидите эту форму в браузере, --- это код новой функции просмотра в приложении, которая отображает шаблон из предыдущего раздела.

Итак, давайте напишем новую функцию представления, сопоставленную с URL-адресом `/login` , которая создаст форму, и передаст её в шаблон для рендеринга. Эта функция просмотра может находиться в модуле `app/routes.py` дополняя содержимое:

    from flask import render_template
    from app import app
    from app.forms import LoginForm

    # ...

    @app.route('/login')
    def login():
        form = LoginForm()
        return render_template('login.html', title='Sign In', form=form)

Здесь я импортировал класс `LoginForm` из *forms.py* , создал экземпляр объекта из него и отправлял его в шаблон. Синтаксис `form = form` может выглядеть странно, но просто передает объект формы, созданный в строке выше (и показан справа), в шаблон с формой имени (показан слева). Это все, что требуется для отображения полей формы.

Чтобы упростить доступ к форме входа, базовый шаблон должен включать в себя ссылку на панель навигации:

    <div>
        Microblog:
        <a href="/index">Home</a>
        <a href="/login">Login</a>
    </div>

На этом этапе можно запустить приложение и посмотреть веб-браузере что получилось. При запуске приложения введите `http://localhost:5000/` в адресной строке браузера, а затем нажмите ссылку «Войти» (Sign In) в верхней панели навигации, чтобы увидеть новую форму входа. Довольно круто, не так ли?

![](https://habrastorage.org/getpro/habr/post_images/5bf/956/150/5bf956150c3131a77332da51c1496a57.png)

### Получение данных формы

Если вы попытаетесь нажать кнопку отправки (Sign In), браузер отобразит ошибку \"Method Not Allowed\" (Метод не разрешен). Это связано с тем, что функция входа в систему из предыдущего раздела выполняет половину задания. Может отображать форму на веб-странице, но у нее нет никакой логики для обработки данных, представленных пользователем. Это еще одна область, где Flask-WTF облегчает работу. Ниже приведена обновленная версия функции просмотра, которая принимает и проверяет данные, представленные пользователем:

    from flask import render_template, flash, redirect

    @app.route('/login', methods=['GET', 'POST'])
    def login():
        form = LoginForm()
        if form.validate_on_submit():
            flash('Login requested for user {}, remember_me={}'.format(
                form.username.data, form.remember_me.data))
            return redirect('/index')
        return render_template('login.html', title='Sign In', form=form)

Первой новинкой в этой версии является аргумент `methods` в дизайнере маршрутов. Это сообщения для Flask, что эта функция просмотра принимает запросы `GET` и `POST` , переопределяя значение по умолчанию, которое должно принимать только запросы `GET` . Протокол HTTP указывает, что `GET` -запросы --- это те, которые возвращают информацию клиенту (в этом случае веб-браузер). Все запросы в приложении до сих пор относятся к этому типу. Запросы `POST` обычно используются, когда браузер передает данные формы на сервер (на самом деле запросы `GET` также могут использоваться для этой цели, но это не рекомендуется). Ошибка «Method Not Allowed», которую браузер показал вам раньше, появляется, потому что браузер попытался отправить запрос `POST` , и приложение не настроено на его принятие. Предоставляя аргумент `methods` , вы сообщаете Flask о необходимости принимать методы запроса.

Метод `form.validate_on_submit()` выполняет всю обработку формы. Когда браузер отправляет запрос `GET` для получения веб-страницы с формой, этот метод возвращает `False` , поэтому в этом случае функция пропускает оператор if и переходит к отображению шаблона в последней строке функции.

Когда браузер отправляет запрос `POST` в результате нажатия пользователем кнопки submit, `form.validate_on_submit()` собирает все данные, запускает все валидаторы, прикрепленные к полям, и если все в порядке, вернет `True` , сообща что данные действительны и могут быть обработаны приложением. Но если хотя бы одно поле не подтвердит проверку, функция вернет `False` , и это приведет к тому, что форма будет возвращена пользователю, например, в случае запроса `GET` . Позже я собираюсь добавить сообщение об ошибке, когда проверка не удалась.

Когда `form.validate_on_submit()` возвращает значение `True` , функция входа в систему вызывает две новые функции, импортированные из Flask. Функция `flash()` --- полезный способ показать сообщение пользователю. Многие приложения используют эту технику, чтобы сообщить пользователю, было ли какое-либо действие успешным или нет. В этом случае я буду использовать этот механизм как временное решение, потому что у меня нет всей инфраструктуры, необходимой для регистрации пользователей в реальности. Лучшее, что я могу сделать сейчас, это показать сообщение, подтверждающее, что приложение получило учетные данные.

Вторая новая функция, используемая в функции входа в систему, --- `redirect()` . Эта функция указывает веб-браузеру клиента автоматически перейти на другую страницу, указанную в качестве аргумента. Эта функция просмотра использует ее для перенаправления пользователя на `/index` страницу приложения.

Когда вы вызываете функцию `flash()` , Flask сохраняет сообщение, но на веб-страницах не будут появляться магические сообщения. Шаблоны приложения должны отображать эти свернутые сообщения таким образом, который работает для макета сайта. Я собираюсь добавить эти сообщения в базовый шаблон, чтобы все шаблоны наследовали эту функциональность. Это обновленный базовый шаблон:

    <html>
        <head>
            {% if title %}
            <title>{{ title }} - microblog</title>
            {% else %}
            <title>microblog</title>
            {% endif %}
        </head>
        <body>
            <div>
                Microblog:
                <a href="/index">Home</a>
                <a href="/login">Login</a>
            </div>
            <hr>
            {% with messages = get_flashed_messages() %}
            {% if messages %}
            <ul>
                {% for message in messages %}
                <li>{{ message }}</li>
                {% endfor %}
            </ul>
            {% endif %}
            {% endwith %}
            {% block content %}{% endblock %}
        </body>
    </html>

Здесь я использую конструкцию `with` , чтобы назначить результат вызова `get_flashed_messages()` переменной `messages` , все в контексте шаблона. Функция `get_flashed_messages()` поступает из Flask и возвращает список всех сообщений, которые были зарегистрированы в `flash()` ранее. Условие, которое следует, проверяет, имеет ли сообщение некоторый контент, и в этом случае элемент `<ul>` отображается с каждым сообщением в виде элемента списка `<li>` . Этот стиль рендеринга выглядит не очень хорошо, но тема стилизации веб-приложения появится позже.

Интересным свойством этих flash-сообщений является то, что после их запроса один раз через функцию `get_flashed_messages` они удаляются из списка сообщений, поэтому они появляются только один раз после вызова функции `flash()` .

Время, чтобы попробовать приложение еще раз и проверить, как работает форма. Убедитесь, что вы пытаетесь отправить форму с полями имени пользователя или пароля пустым, чтобы увидеть, как валидатор `DataRequired` останавливает процесс отправки.

### Повышение эффективности проверки полей

Валидаторы, прикрепленные к полям формы, предотвращают передачу недопустимых данных в приложение. Способ, которым приложение отвечает на недопустимый ввод в поля формы, заключается в повторном отображении формы, чтобы позволить пользователю внести необходимые исправления.

Если вы пытались ввести недопустимые данные, я уверен, что вы заметили, что, хотя механизмы проверки работают хорошо, нет сообщений пользователю, что что-то не так с формой, пользователь просто получает форму обратно. Следующая задача состоит в том, чтобы улучшить взаимодействие с пользователем, добавив значимое сообщение об ошибке рядом с каждым полем, которое не удалось проверить.

Фактически, валидаторы форм уже создают эти описательные сообщения об ошибках, поэтому все, что отсутствует, --- это некоторая дополнительная логика в шаблоне для их отображения.

Вот шаблон входа с добавленными сообщениями (Это поле обязательно.) проверки имени пользователя и пароля:

    {% extends "base.html" %}

    {% block content %}
        <h1>Sign In</h1>
        <form action="" method="post">
            {{ form.hidden_tag() }}
            <p>
                {{ form.username.label }}<br>
                {{ form.username(size=32) }}<br>
                {% for error in form.username.errors %}
                <span style="color: red;">[{{ error }}]</span>
                {% endfor %}
            </p>
            <p>
                {{ form.password.label }}<br>
                {{ form.password(size=32) }}<br>
                {% for error in form.password.errors %}
                <span style="color: red;">[{{ error }}]</span>
                {% endfor %}
            </p>
            <p>{{ form.remember_me() }} {{ form.remember_me.label }}</p>
            <p>{{ form.submit() }}</p>
        </form>
    {% endblock %}

Единственное изменение, которое я сделал, это добавил циклы сразу после поля `username` и `password` , которые отображают сообщения об ошибках, добавленные валидаторами в красном цвете. Как правило, все поля, имеющие прикрепленные проверяющие элементы, будут иметь сообщения об ошибках, добавляемые в `form.<field_name>.errors` . Это будет список, потому что поля могут иметь несколько прилагающихся валидаторов и предоставлений сообщений об ошибках может быть более одного для отображения пользователю.

Если вы попытаетесь отправить форму с пустым именем пользователя или паролем, вы получите красное сообщение об ошибке.

![](https://habrastorage.org/getpro/habr/post_images/ae3/e52/24d/ae3e5224d8735f43f653f456b1dfa3a0.png)

### Создание связей

Форма входа в систему теперь почти закончена, но перед закрытием этой главы я хотел бы обсудить правильный способ включения связей в шаблоны и перенаправления. До сих пор вы видели несколько примеров, в которых были определены связи. Например, это текущая панель навигации в базовом шаблоне:

    <div>
        Microblog:
        <a href="/index">Home</a>
        <a href="/login">Login</a>
    </div>

Функция просмотра `login` также определяет ссылку, которая передается функции `redirect()` :

    @app.route('/login', methods=['GET', 'POST'])
    def login():
    form = LoginForm()
    if form.validate_on_submit():
        # ...
        return redirect('/index')
        # ...

Одна из проблем с написанием ссылок непосредственно в шаблонах и исходных файлах заключается в том, что если в один прекрасный день вы решите реорганизовать свои ссылки, вам придется искать и заменять эти ссылки во всем своем приложении.

Чтобы лучше контролировать эти ссылки, Flask предоставляет функцию `url_for()` , которая генерирует URL-адреса, используя внутреннее отображение URL-адресов для просмотра функций. Например, `url_for('login')` возвращает `/login` , а `url_for('index')` возвращает `'/index` . Аргументом для `url_for()` является имя *конечной точки* , которое является именем функции view.

Вы можете спросить, почему лучше использовать имена функций вместо URL-адресов. Дело в том, что URL-адреса гораздо чаще меняются, чем имена функций, которые являются внутренними. Вторая причина заключается в том, что, как вы узнаете позже, некоторые URL-адреса имеют динамические компоненты, поэтому для генерации этих URL вручную потребуется объединение нескольких элементов, что является утомительным и подверженным ошибкам. `url_for()` также может генерировать эти сложные URL-адреса.

Поэтому с этого момента я буду использовать `url_for()` каждый раз, когда мне нужно создать URL приложения. В итоге панель навигации в базовом шаблоне становится такой:

    <div>
        Microblog:
        <a href="{{ url_for('index') }}">Home</a>
        <a href="{{ url_for('login') }}">Login</a>
    </div>

И вот обновленная функция `login()` :

    from flask import render_template, flash, redirect, url_for

    # ...

    @app.route('/login', methods=['GET', 'POST'])
    def login():
        form = LoginForm()
        if form.validate_on_submit():
            # ...
            return redirect(url_for('index'))
    # ...
:::

Глава 4: База данных
--------------------

::: {#post-content-body .post__text .post__text-html io-article-url="https://habr.com/ru/post/346344/"}
### Базы данных в Flask

Поскольку я уверен, что вы уже слышали, Flask не поддерживает базы данных изначально. Это одна из многих областей, в которых Flask намеренно не самодостаточен, и это здорово, потому что у вас есть свобода выбора базы данных, которая наилучшим образом подходит для вашего приложения, вместо того, чтобы быть вынужденным адаптироваться к одному.

В Python есть большой выбор для баз данных, многие из которых интегрируются с Flask приложением. Базы данных можно разделить на две большие группы: те, которые соответствуют реляционной модели, и те, которые этого не делают. Последняя группа часто называется NoSQL, что указывает на то, что они не реализуют популярный язык реляционных запросов [SQL](https://en.wikipedia.org/wiki/SQL) . Хотя в обеих группах есть отличные продукты для баз данных, я считаю, что реляционные базы данных лучше подходят для приложений, которые имеют структурированные данные, такие как списки пользователей, сообщения в блогах и т.д., В то время как базы данных NoSQL имеют тенденцию быть лучше для данных, которые имеют менее определенную структуру. Это приложение, как и большинство других, может быть реализовано с использованием любого типа базы данных, но по указанным выше причинам я собираюсь работать с реляционной базой данных.

В **главе 3** я показал вам первое расширение Flask. В этой главе я собираюсь использовать еще два. Первым является [Flask-SQLAlchemy](http://packages.python.org/Flask-SQLAlchemy) , расширение, которое обеспечивает Flask-дружественную оболочку к популярному пакету [SQLAlchemy](http://www.sqlalchemy.org/) , который является [Object Relational Mapper](http://en.wikipedia.org/wiki/Object-relational_mapping) или ORM. ORM позволяют приложениям управлять базой данных с использованием объектов высокого уровня, таких как классы, объекты и методы, а не таблицы и SQL. Задача ORM --- перевести операции высокого уровня в команды базы данных.

Самое приятное в SQLAlchemy заключается в том, что это ORM не для одного, а для многих реляционных баз данных. SQLAlchemy поддерживает длинный список движков баз данных, включая популярные [MySQL](https://www.mysql.com/) , [PostgreSQL](https://www.postgresql.org/) и [SQLite](https://www.sqlite.org/) . Это очень сильно, потому что вы можете сделать свою разработку с помощью простой базы данных SQLite, которая не требует сервера, а затем, когда придет время развертывать приложение на производственном сервере, вы можете выбрать более надежный сервер MySQL или PostgreSQL, не измененяя вашего приложения.

Чтобы установить Flask-SQLAlchemy в виртуальную среду, убедитесь, что вы активировали ее сначала, а затем запустите:

    (venv) $ pip install flask-sqlalchemy

### Миграция баз данных

Большинство учебных пособий по базе данных, которые я видел, охватывают создание и использование базы данных, но не позволяют адекватно решить проблему создания обновлений существующей базы данных по мере того, как приложение нуждается в изменении или увеличении. Это сложно, потому что реляционные базы данных сосредоточены вокруг структурированных данных, поэтому при изменении структуры данные, которые уже находятся в базе данных, необходимо перенести в модифицированную структуру.

Второе расширение, которое я собираюсь представить в этой главе, [Flask-Migrate](https://github.com/miguelgrinberg/flask-migrate) , который фактически созданный вашим покорным слугой. Это расширение является Flask-оберткой для [Alembic](https://bitbucket.org/zzzeek/alembic) , основой для миграции базы данных SQLAlchemy. Работа с миграциями баз данных добавляет немного работы вначале, но это небольшая цена, чтобы заплатить за надежный способ внесения изменений в вашу базу данных в будущем.

Процесс установки для Flask-Migrate аналогичен другим расширениям, которые вы видели:

    (venv) $ pip install flask-migrate

### Конфигурация Flask-SQLAlchemy

Во время разработки я собираюсь использовать базу данных SQLite. Базы данных SQLite являются наиболее удобным выбором для разработки небольших приложений, иногда даже не очень маленьких, так как каждая база данных хранится в одном файле на диске и нет необходимости запускать сервер баз данных, как MySQL и PostgreSQL.

У нас есть два новых элемента конфигурации для добавления в файл конфигурации:

> config.py

    import os
    basedir = os.path.abspath(os.path.dirname(__file__))

    class Config(object):
        # ...
        SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL') or \
            'sqlite:///' + os.path.join(basedir, 'app.db')
        SQLALCHEMY_TRACK_MODIFICATIONS = False

Расширение Flask-SQLAlchemy принимает местоположение базы данных приложения из переменной конфигурации `SQLALCHEMY_DATABASE_URI` . Как вы помните из **главы 3** , в целом рекомендуется установить конфигурацию из переменных среды и предоставить резервное значение, когда среда не определяет переменную. В этом случае я беру URL-адрес базы данных из переменной среды `DATABASE_URL` , и если это не определено, я настраиваю базу данных с именем *app.db* , расположенную в основном каталоге приложения, которая хранится в переменной `basedir` .

Параметр конфигурации `SQLALCHEMY_TRACK_MODIFICATIONS` установлен в значение False, чтобы отключить функцию Flask-SQLAlchemy, которая мне не нужна, которая должна сигнализировать приложению каждый раз, когда в базе данных должно быть внесено изменение.

База данных будет представлена ​​в приложении, как *database instance* . Механизм миграции базы данных также будет иметь экземпляр. Это объекты, которые необходимо создать после приложения, в файле `app/__ init__.py` :

    from flask import Flask
    from config import Config
    from flask_sqlalchemy import SQLAlchemy
    from flask_migrate import Migrate

    app = Flask(__name__)
    app.config.from_object(Config)
    db = SQLAlchemy(app)
    migrate = Migrate(app, db)

    from app import routes, models

Я внес три изменения в скрипт init. Во-первых, я добавил объект `db` , который представляет базу данных. Затем я добавил еще один объект, который представляет механизм миграции. Надеюсь, вы увидите образец работы с расширениями Flask. Большинство расширений инициализируются как эти два. Наконец, я импортирую новый модуль под названием `models` внизу. Этот модуль определит структуру базы данных.

### Модели баз данных

Данные, которые будут храниться в базе данных, будут представлены набором классов, обычно называемых моделями баз данных. Уровень ORM в SQLAlchemy будет выполнять переводы, необходимые для сопоставления объектов, созданных из этих классов, в строки в соответствующих таблицах базы данных.

Начнем с создания модели, представляющей пользователей. Используя инструмент [WWW SQL Designer](http://ondras.zarovi.cz/sql/demo) , я сделал следующую диаграмму для представления данных, которые мы хотим использовать в таблице users:

[![](https://habrastorage.org/getpro/habr/post_images/735/51e/366/73551e366bcbb81e973580ae02dfd83d.png)](http://ondras.zarovi.cz/sql/demo)

Поле `id` обычно используется во всех моделях и используется как первичный ключ. Каждому пользователю в базе данных будет присвоено уникальное значение идентификатора, сохраненное в этом поле. Первичные ключи в большинстве случаев автоматически назначаются базой данных, поэтому мне просто нужно указать поле `id` , помеченное как первичный ключ.

Поля `username` , `email` и `password_hash` определяются как строки (или `VARCHAR` на жаргоне базы данных), а их максимальная длина указывается так, чтобы база данных могла оптимизировать использование пространства. Хотя поля `username` и `email` не требуют пояснений, поля `password_hash` заслуживают внимания. Я хочу убедиться, что приложение, которое я создаю, использует лучшие рекомендации по безопасности, и по этой причине я не буду хранить пароли пользователей в базе данных. Проблема с хранением паролей заключается в том, что если база данных когда-либо становится скомпрометированной, злоумышленники будут иметь доступ к паролям, и это может быть разрушительным для пользователей. Вместо того, чтобы писать пароли напрямую, я собираюсь написать *хэши паролей* (password hashes), которые значительно улучшают безопасность. Это будет тема другой главы, так что не беспокойтесь об этом сейчас.

Итак, теперь, когда я знаю, что мне нужно для таблицы моих пользователей, я могу перевести это в код в новом модуле *app/models.py* :

    from app import db

    class User(db.Model):
        id = db.Column(db.Integer, primary_key=True)
        username = db.Column(db.String(64), index=True, unique=True)
        email = db.Column(db.String(120), index=True, unique=True)
        password_hash = db.Column(db.String(128))

        def __repr__(self):
            return '<User {}>'.format(self.username) 

Созданный выше класс `User` наследует от `db.Model` , базового класса для всех моделей из Flask-SQLAlchemy. Этот класс определяет несколько полей как переменные класса. Поля создаются как экземпляры класса `db.Column` , который принимает тип поля в качестве аргумента, плюс другие необязательные аргументы, которые, например, позволяют мне указать, какие поля уникальны и индексированы, что важно для эффективного поиска базы данных ,

Метод `__repr__` сообщает Python, как печатать объекты этого класса, что будет полезно для отладки. Вы можете увидеть метод `__repr __()` в действии в сеансе интерпретатора Python ниже:

    >>> from app.models import User
    >>> u = User(username='susan', email='susan@example.com')
    >>> u
    <User susan>

### Создание миграции репозитория

Класс модели, созданный в предыдущем разделе, определяет исходную структуру (или *схему* ) базы данных для этого приложения. Но по мере того, как приложение продолжает расти, потребуется изменить структуру, которая, скорее всего, добавит новые сущности, но иногда также может изменять или удалять элементы. Alembic (инфраструктура миграции, используемая Flask-Migrate) сделает эти изменения схемы таким образом, чтобы не требовалось воссоздавать базу данных с нуля.

Чтобы выполнить эту, казалось бы, сложную задачу, Alembic поддерживает репозиторий *миграции* , который является каталогом, в котором хранится его сценарии миграции. Каждый раз, когда в схему базы данных вносится изменение, в репозиторий добавляется сценарий миграции с подробными сведениями об изменении. Чтобы применить миграции к базе данных, эти сценарии миграции выполняются в той последовательности, в которой они были созданы.

Flask-Migrate выдает свои команды через `flask` команду. Вы уже видели `flask run` , который является подчиненной командой, которая является родной для Flask. Подкоманда `flask db` добавляется Flask-Migrate для управления всем, что связано с миграцией базы данных. Итак, давайте создадим репозиторий миграции для microblog, запустив `flask db init` :

    (venv) $ flask db init
      Creating directory /home/miguel/microblog/migrations ... done
      Creating directory /home/miguel/microblog/migrations/versions ... done
      Generating /home/miguel/microblog/migrations/alembic.ini ... done
      Generating /home/miguel/microblog/migrations/env.py ... done
      Generating /home/miguel/microblog/migrations/README ... done
      Generating /home/miguel/microblog/migrations/script.py.mako ... done
      Please edit configuration/connection/logging settings in
      '/home/miguel/microblog/migrations/alembic.ini' before proceeding.

Помните, что `flask` команда полагается на переменную среды `FLASK_APP` , чтобы знать, где расположено приложение Flask. Для этого приложения вы хотите установить `FLASK_APP=microblog.py` , как описано в **главе 1** .

После запуска этой команды вы найдете новый каталог *migrations* , в котором есть несколько файлов и подкаталог *версий* . Все эти файлы теперь должны рассматриваться как часть вашего проекта и, их необходимо добавить в систему управления версиями.

### Первая миграция базы данных

При наличии репозитория миграции настало время создать первую миграцию базы данных, которая будет включать таблицу `Users` , сопоставляемую с моделью пользовательской базы данных. Существует два способа создания миграции базы данных: вручную или автоматически. Для автоматического создания миграции Alembic сравнивает схему базы данных, определенную моделями баз данных, с фактической схемой базы данных, используемой в настоящее время в базе данных. Затем он заполняет сценарий переноса изменениями, необходимыми для того, чтобы схема базы данных соответствовала моделям приложений. В этом случае, поскольку нет предыдущей базы данных, автоматический перенос добавит всю `User` модель в сценарий переноса. `flask db migrate` Подкоманда переноса DB генерирует эти автоматические миграции:

    (venv) $ flask db migrate -m "users table"
    INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
    INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
    INFO  [alembic.autogenerate.compare] Detected added table 'user'
    INFO  [alembic.autogenerate.compare] Detected added index 'ix_user_email' on '['email']'
    INFO  [alembic.autogenerate.compare] Detected added index 'ix_user_username' on '['username']'
    Generating /home/miguel/microblog/migrations/versions/e517276bb1c2_users_table.py ... done

Вывод команды дает вам представление о том, что Alembic включен в миграцию. Первые две строки являются информационными и их обычно можно игнорировать. Затем он говорит, что нашел таблицу `'user'` и два индекса `'['email']'` и \'\[\'username\'\]\'. Затем он сообщает вам, где он написал сценарий миграции. Код e517276bb1c2 --- это автоматически созданный уникальный код для миграции (он будет другим для вас). Комментарий, заданный с параметром `-m` , является необязательным, он добавляет короткий описательный текст в перенос.

Сгенерированный сценарий миграции теперь является частью вашего проекта и должен быть включен в систему управления версиями. Вы можете просмотреть сценарий, если вам интересно посмотреть, как он выглядит. Вы обнаружите, что у него есть две функции: `upgrade()` и `downgrade()` . Функция `upgrade()` применяет миграцию, а функция `downgrade()` удаляет ее. Это позволяет Alembic переносить базу данных в любую точку истории, даже в более старые версии, используя путь понижения.

Команда `flask db migrate` не вносит никаких изменений в базу данных, она просто создает сценарий миграции. Чтобы применить изменения в базе данных, необходимо использовать команду `flask db upgrade` .

    (venv) $ flask db upgrade
    INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
    INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
    INFO  [alembic.runtime.migration] Running upgrade  -> e517276bb1c2, users table

Поскольку это приложение использует SQLite, команда Upgrade обнаружит, что база данных не существует и создаст ее (вы заметите, что файл с именем `app.db` будет добавлен после завершения этой команды, то есть базы данных SQLite). При работе с серверами баз данных, такими как MySQL и PostgreSQL, перед запуском обновления необходимо создать базу данных на сервере базы данных.

### Процесс обновления базы данных и откатка изменений Upgrade и Downgrade

На данный момент приложение находится в зачаточном состоянии, но это не помешает обсудить, что будет в стратегии миграции базы данных в будущем. Представьте, что у вас есть приложение на вашей машине разработки, а также есть копия, развернутая на производственный сервер, который находится в сети и используется.

Предположим, что для следующей версии вашего приложения вам нужно внести изменения в свои модели, например, нужно добавить новую таблицу. Без миграции вам нужно будет выяснить, как изменить схему вашей базы данных, как на локальном хосте, так и на вашем сервере, и это может быть большой проблемой.

Но с поддержкой миграции базы данных, после изменения моделей в приложении вы создаете новый сценарий миграции ( flask db migrate ), вы, вероятно, просмотрите его, чтобы убедиться, что автоматическое создание сделало правильные вещи, а затем примените изменения в базе данных разработки ( flask db upgrade ). Вы добавите сценарий миграции в систему управления версиями и зафиксируете его.

Когда вы будете готовы выпустить новую версию приложения на свой *production* сервер, все, что вам нужно сделать, это захватить обновленную версию приложения, которая будет включать в себя новый сценарий миграции и запустить `flask db upgrade` . *Alembic* обнаружит, что база данных не обновлена до последней редакции, и выполнит все новые сценарии миграции, созданные после предыдущего выпуска.

Как я упоминал ранее, у вас также есть команда `downgrade flask db` , которая отменяет последнюю миграции. Хотя вам вряд ли понадобится этот вариант в момент рабочей эксплуатации, Вы можете найти его очень полезным во время разработки. Возможно, вы сгенерировали сценарий миграции и применили его, только чтобы обнаружить, что внесенные изменения не совсем то, что вам нужно. В этом случае можно понизить рейтинг базы данных, удалить сценарий миграции, а затем создать новый, чтобы заменить его.

### Связи базы данных

Реляционные базы данных хороши в хранении связей между элементами данных. Рассмотрим случай, когда пользователь пишет сообщение в блоге. Пользователь будет иметь запись в таблице пользователей, и сообщение будет иметь запись в таблице сообщений. Самый эффективный способ записать кто написал данное сообщение, --- связать две записи.

После того, как установлена связь между пользователем и постом, есть два типа запросов, которые нам могут понадобиться. Самый тривиальный, когда у вас есть пост и нужно знать кто из пользователей его написал. Чуть более сложный вопрос является обратным этому. Если у вас есть пользователь, то вам может понадобиться получить все написанные им записи. Flask-SQLAlchemy поможет нам с обоими типами запросов.

Расширим нашу базу для хранения постов, чтобы мы могли увидеть связи в действии. Для этого мы вернемся к нашему инструменту дизайна БД и создадим таблицу записей:

![](https://habrastorage.org/getpro/habr/post_images/a40/e5e/a48/a40e5ea48c8c6544d3e82f0d7c6e16d4.png)

Таблица Сообщений будет иметь необходимый идентификатор, текст сообщения и метку времени. Но в дополнение к этим ожидаемым полям я добавляю поле `user_id` , которое связывает сообщение с его автором. Вы видели, что у всех пользователей есть первичный ключ `id` , который уникален. Способ связать запись блога с пользователем, который ее создал, --- добавить ссылку на идентификатор пользователя, и это именно то, что является полем `user_id` . Это поле `user_id` называется внешним ключом (англ. foreign key). На приведенной выше схеме базы данных внешние ключи отображаются как связь между полем и полем `id` таблицы, на которую он ссылается. Такого рода отношения называется один ко многим, потому что \"один\" пользователь пишет \"много\" Сообщений.

Измененный *app/models.py* показан ниже:

    from datetime import datetime
    from app import db

    class User(db.Model):
        id = db.Column(db.Integer, primary_key=True)
        username = db.Column(db.String(64), index=True, unique=True)
        email = db.Column(db.String(120), index=True, unique=True)
        password_hash = db.Column(db.String(128))
        posts = db.relationship('Post', backref='author', lazy='dynamic')

        def __repr__(self):
            return '<User {}>'.format(self.username)

    class Post(db.Model):
        id = db.Column(db.Integer, primary_key=True)
        body = db.Column(db.String(140))
        timestamp = db.Column(db.DateTime, index=True, default=datetime.utcnow)
        user_id = db.Column(db.Integer, db.ForeignKey('user.id'))

        def __repr__(self):
            return '<Post {}>'.format(self.body)

Новый класс `Post` будет представлять записи в блогах, написанные пользователями. Поле `timestamp` будет проиндексировано, что полезно, если вы хотите получить сообщения в хронологическом порядке. Я также добавил аргумент по умолчанию и передал функцию `datetime.utcnow` . Когда вы передаете функцию по умолчанию, SQLAlchemy установит для поля значение вызова этой функции (обратите внимание, что я не включил `()` после `utcnow` , поэтому я передаю эту функцию сам, а не результат ее вызова ). В общем, это позволит работать с датами и временем UTC в серверном приложении. Это гарантирует, что вы используете единые временные метки независимо от того, где находятся пользователи. Эти временные метки будут преобразованы в локальное время пользователя, когда они будут отображаться.

Поле `user_id` было инициализировано как внешний ключ для `user.id` , что означает, что оно ссылается на значение `id` из таблицы `users` . В этой ссылке user --- это имя таблицы базы данных, которую Flask-SQLAlchemy автоматически устанавливает как имя класса модели, преобразованного в нижний регистр. Класс User имеет новое поле сообщений, которое инициализируется `db.relationship` . Это не фактическое поле базы данных, а высокоуровневое представление о взаимоотношениях между users и posts, и по этой причине оно не находится в диаграмме базы данных. Для отношения «один ко многим» поле db.relationship обычно определяется на стороне «один» и используется как удобный способ получить доступ к «многим». Так, например, если у меня есть пользователь, хранящийся в `u` , выражение `u.posts` будет запускать запрос базы данных, который возвращает все записи, написанные этим пользователем. Первый аргумент `db.relationship` указывает класс, который представляет сторону отношения «много». Аргумент `backref` определяет имя поля, которое будет добавлено к объектам класса «много», который указывает на объект «один». Это добавит выражение `post.author` , которое вернет автора сообщения. Аргумент lazy определяет, как будет выполняться запрос базы данных для связи, о чем я расскажу позже. Не беспокойтесь, если эти детали не имеют для вас смысла, я покажу примеры в конце этой статьи.

Поскольку у меня есть обновления для моделей приложений, необходимо создать новую миграцию базы данных:

    (venv) $ flask db migrate -m "posts table"
    INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
    INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
    INFO  [alembic.autogenerate.compare] Detected added table 'post'
    INFO  [alembic.autogenerate.compare] Detected added index 'ix_post_timestamp' on '['timestamp']'
      Generating /home/miguel/microblog/migrations/versions/780739b227a7_posts_table.py ... done

И миграция должна быть применена к базе данных:

    (venv) $ flask db upgrade
    INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
    INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
    INFO  [alembic.runtime.migration] Running upgrade e517276bb1c2 -> 780739b227a7, posts table

Если проект хранится в системе управления версиями, не забудьте добавить в него новый сценарий миграции.

### Время запуска

Я заставил вас пройти через долгий процесс создания базы данных, но я еще не показал вам, как все работает. Поскольку приложение еще не имеет логики базы данных, давайте поиграемся с базой данных в интерпретаторе Python, чтобы ознакомиться с ним. Итак, продолжайте и запустите Python. Перед запуском интерпретатора убедитесь, что ваша виртуальная среда активирована.

В командной строке Python давайте импортируем экземпляр базы данных и модели:

    >>> from app import db
    >>> from app.models import User, Post

Начните с создания нового пользователя:

    >>> u = User(username='john', email='john@example.com')
    >>> db.session.add(u)
    >>> db.session.commit()

Изменения в базе данных выполняются в контексте сеанса, к которому можно получить доступ как `db.session` . Множество изменений можно накапливать в сеансе, и как только все изменения были зарегистрированы, вы можете выпустить один файл `db.session.commit()` , который записывает все изменения атомарно. Если в любое время во время работы над сеансом произошла ошибка, вызов `db.session.rollback()` отменяет сеанс и удаляет любые изменения, сохраненные в нем. Важно помнить, что изменения записываются только в базу данных при вызове `db.session.commit()` . Сеансы гарантируют, что база данных никогда не останется в несогласованном состоянии.

Давайте добавим другого пользователя:

    >>> u = User(username='susan', email='susan@example.com')
    >>> db.session.add(u)
    >>> db.session.commit()

База данных может ответить на запрос, возвращающий всех пользователей:

    >>> users = User.query.all()
    >>> users
    [<User john>, <User susan>]
    >>> for u in users:
    ...     print(u.id, u.username)
    ...
    1 john
    2 susan

Все модели имеют атрибут запроса, который является точкой входа для запуска запросов к базе данных. Самый основной запрос --- тот, который возвращает все элементы этого класса, который называется `all()` . Обратите внимание, что при добавлении этих пользователей поля `id` автоматически устанавливались в 1 и 2.

Вот еще один способ. Если вы знаете идентификатор пользователя, вы можете получить результат следующим образом:

    >>> u = User.query.get(1)
    >>> u
    <User john>

Теперь добавим сообщение в блоге:

    >>> u = User.query.get(1)
    >>> p = Post(body='my first post!', author=u)
    >>> db.session.add(p)
    >>> db.session.commit()

Мне не нужно было устанавливать значение для поля `timestamp` , потому что это поле имеет значение по умолчанию, которое вы можете увидеть в определении модели. А как насчет поля user\_id? Напомню, что отношение `db.relationship` , которое я создал в классе `User` , добавляет атрибут `posts` для пользователей, а также атрибут автора для сообщений. Я назначаю автора сообщению, используя виртуальное поле автора, вместо того, чтобы иметь дело с идентификаторами пользователей. SQLAlchemy отлично подходит в этом отношении, поскольку обеспечивает абстракцию высокого уровня над отношениями и внешними ключами.

В завершении, давайте рассмотрим еще несколько запросов к базе данных:

    >>> # get all posts written by a user
    >>> u = User.query.get(1)
    >>> u
    <User john>
    >>> posts = u.posts.all()
    >>> posts
    [<Post my first post!>]

    >>> # same, but with a user that has no posts
    >>> u = User.query.get(2)
    >>> u
    <User susan>
    >>> u.posts.all()
    []

    >>> # print post author and body for all posts 
    >>> posts = Post.query.all()
    >>> for p in posts:
    ...     print(p.id, p.author.username, p.body)
    ...
    1 john my first post!

    # get all users in reverse alphabetical order
    >>> User.query.order_by(User.username.desc()).all()
    [<User susan>, <User john>]

Документация по Flask-SQLAlchemy-это лучшее место, чтобы узнать о многих вариантах, доступных для запроса к базе данных.

Для завершения этого раздела, давайте сотрем тест пользователей и сообщений, созданных выше, так что бы база данных стала чистой и готовой к следующей главе:

    >>> users = User.query.all()
    >>> for u in users:
    ...     db.session.delete(u)
    ...
    >>> posts = Post.query.all()
    >>> for p in posts:
    ...     db.session.delete(p)
    ...
    >>> db.session.commit()

### shell context или лекарство от геморроя

Помните, что вы делали в начале предыдущего раздела, сразу после запуска интерпретатора Python? Первое, что вы сделали, это запустили некоторые операции импорта:

    >>> from app import db
    >>> from app.models import User, Post

В то время как вы работаете над своим приложением, вам нужно будет очень часто тестировать функционал в оболочке Python, поэтому повторять вышеуказанный импорт каждый раз будет утомительно. Команда `flask shell` --- еще один очень полезный инструмент в командной оболочке команд. `shell` --- это второе \"ядро\", реализующее `flask` , после запуска. Цель этой команды-запустить интерпретатор Python в контексте приложения. Что это значит? Рассмотрим следующий пример:

    (venv) $ python
    >>> app
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    NameError: name 'app' is not defined
    >>>

    (venv) $ flask shell
    >>> app
    <Flask 'app'>

При регулярном сеансе интерпретатора имя `app` неизвестно, если явно не импортировано, но при использовании `flask shell` команда предварительно импортирует экземпляр приложения. Прикол `flask shell` заключается не в том, что предварительно импортирует приложение, а в том, что вы можете настроить «shell context», который представляет собой список других имен для предварительного импорта.

Следующая функция в *microblog.py* создает контекст оболочки, который добавляет экземпляр и модели базы данных в сеанс оболочки:

    from app import app, db
    from app.models import User, Post

    @app.shell_context_processor
    def make_shell_context():
        return {'db': db, 'User': User, 'Post': Post}

Декоратор `app.shell_context_processor` регистрирует функцию как функцию контекста оболочки. Когда запускается команда `flask shell` , она будет вызывать эту функцию и регистрировать элементы, возвращаемые ею в сеансе оболочки. Причина, по которой функция возвращает словарь, а не список, заключается в том, что для каждого элемента вы также должны указывать имя, под которым оно будет ссылаться в оболочке, которое задается индексами словаря.

После того, как вы добавите функцию обработчика `flask shell` , вы можете работать с объектами базы данных, не импортируя их:

    (venv) $ flask shell
    >>> db
    <SQLAlchemy engine=sqlite:////Users/migu7781/Documents/dev/flask/microblog2/app.db>
    >>> User
    <class 'app.models.User'>
    >>> Post
    <class 'app.models.Post'>
:::

Глава 5: Пользовательские логины
--------------------------------

::: {#post-content-body .post__text .post__text-html io-article-url="https://habr.com/ru/post/346346/"}
### Хеширование паролей

В **главе 4** пользовательской модели было присвоено поле `password_hash` , которое пока не используется. Цель этого поля --- сохранить хэш пароля пользователя, который будет использоваться для проверки пароля, введенного пользователем во время процесса регистрации. Хеширование паролей ( *Password hashing* ) --- это сложная тема, которую следует оставить экспертам по безопасности, но есть несколько простых в использовании библиотек, которые реализуют всю эту логику таким образом, чтобы ее можно было вызвать из приложения.

Одним из пакетов, реализующих хеширование паролей, является [Werkzeug](http://werkzeug.pocoo.org/) , который вы, возможно, видели в выводе pip при установке Flask. Раз уж это зависимость, Werkzeug уже установлен в вашей виртуальной среде. Следующий сеанс оболочки Python демонстрирует, как хешировать пароль:

    >>> from werkzeug.security import generate_password_hash
    >>> hash = generate_password_hash('foobar')
    >>> hash
    'pbkdf2:sha256:50000$vT9fkZM8$04dfa35c6476acf7e788a1b5b3c35e217c78dc04539d295f011f01f18cd2175f'

В этом примере пароль foobar преобразуется в длинную кодированную строку посредством серии криптографических операций, которые не имеют никакой обратной операции, что означает, что человек, получающий хешированный пароль, не сможет использовать его для получения исходного пароля. В качестве дополнительной меры, если вы будете иметь один и тот же пароль несколько раз, вы получите разные результаты, поэтому это не позволяет определить, имеют ли два пользователя одинаковый пароль, просматривая их хэши.

Процесс проверки выполняется со второй функцией от Werkzeug следующим образом:

        >>> from werkzeug.security import check_password_hash
        >>> check_password_hash(hash, 'foobar')
        True
        >>> check_password_hash(hash, 'barfoo')
        False

Функция проверки принимает хэш-код пароля, который был ранее сгенерирован, и пароль, введенный пользователем во время входа в систему. Функция возвращает значение `True` , если пароль, предоставленный пользователем, совпадает с хешем, иначе `False` .

Вся логика хэширования пароля может быть реализована как два новых метода в пользовательской модели:

> `app/models.py` : Хеширование и проверка пароля

    from werkzeug.security import generate_password_hash, check_password_hash

    # ...

    class User(db.Model):
        # ...

        def set_password(self, password):
            self.password_hash = generate_password_hash(password)

        def check_password(self, password):
            return check_password_hash(self.password_hash, password)

Используя эти два метода, пользовательский объект теперь может выполнять безопасную проверку пароля без необходимости хранить оригинальные пароли. Вот пример использования этих новых методов:

    >>> u = User(username='susan', email='susan@example.com')
    >>> u.set_password('mypassword')
    >>> u.check_password('anotherpassword')
    False
    >>> u.check_password('mypassword')
    True

### Введение в Flask-Login

В этой главе я познакомлю вас с очень популярным расширением Flask под названием Flask-Login. Это расширение управляет состоянием входа пользователя в систему, так что, например, пользователи могут войти в приложение, а затем перейти на разные страницы, пока приложение «помнит», что пользователь вошел в систему. Оно также предоставляет функциональность «запомнить меня», которая позволяет пользователям оставаться в системе даже после закрытия окна браузера. Чтобы быть готовым к этой главе, вы можете начать с установки Flask-Login в вашей виртуальной среде:

    (venv) $ pip install flask-login

Как и с другими расширениями, Flask-Login должен быть создан и инициализирован сразу после экземпляра приложения в `app/__init__.py` . Так инициализируется это расширение:

> `app/__init__.py` : Flask-Login initialization

    # ...
    from flask_login import LoginManager

    app = Flask(__name__)
    # ...
    login = LoginManager(app)

    # ...

### Подготовка User Model для Flask-Login

Расширение Flask-Login работает с пользовательской моделью приложения и ожидает, что в нем будут реализованы определенные свойства и методы. Такой подход хорош тем, что до тех пор, пока эти необходимые элементы добавляются в модель, Flask-Login не имеет никаких других требований, поэтому, например, он может работать с пользовательскими моделями, основанными на любой системе баз данных.

Ниже перечислены четыре обязательных элемента:

-   `is_authenticated` : свойство, которое имеет значение `True` , если пользователь имеет действительные учетные данные или `False` в противном случае.
-   `is_active` : свойство, которое вернет `True` , если учетная запись Пользователя активна или `False` в противном случае.
-   `is_anonymous` : свойство, которое вернет `False` для обычных пользователей, и `True` , если пользователь анонимный.
-   `get_id()` : метод, который возвращает уникальный идентификатор пользователя в виде строки (unicode, если используется Python 2).

Я могу легко реализовать все четыре, но поскольку реализации довольно общие, Flask-Login предоставляет *mixin* класс `UserMixin` , который включает в себя общие реализации, которые подходят для большинства классов пользовательских моделей. Вот как класс *mixin* добавляется в модель:

> `app/models.py` : Flask-Login user mixin class

    # ...
    from flask_login import UserMixin

    class User(UserMixin, db.Model):
        # ...

### Пользовательский загрузчик

Flask-Login отслеживает зарегистрированного пользователя, сохраняя его уникальный идентификатор в *пользовательском сеансе* Flask, назначенный каждому пользователю, который подключается к приложению. Каждый раз, когда вошедший в систему пользователь переходит на новую страницу, Flask-Login извлекает идентификатор пользователя из сеанса и затем загружает этого пользователя в память.

Поскольку Flask-Login ничего не знает о базах данных, ему нужна помощь приложения при загрузке пользователя. По этой причине расширение ожидает, что приложение настроит функцию загрузчика пользователя, которую можно вызвать для загрузки пользователя с идентификатором. Эта функция может быть добавлена ​​в модуле *app/models.py* :

> `app/models.py` : Flask-Login user loader function

    from app import login
    # ...

    @login.user_loader
    def load_user(id):
        return User.query.get(int(id))

Пользовательский загрузчик зарегистрирован в Flask-Login с помощью декоратора `@login.user_loader` . Идентификатор, который Flask-Login переходит к функции в качестве аргумента, будет строкой, поэтому для баз данных, использующих числовые идентификаторы, необходимо преобразовать строку в целое число, как вы видите выше `int(id)` .

### Вход пользователей в систему

Давайте перейдем к функции входа в систему, которая, как вы помните, реализовала поддельный логин, который только выдавал сообщение `flash()` . Теперь, когда приложение имеет доступ к пользовательской базе данных и знает, как создавать и проверять хэши паролей, эта функция просмотра может быть завершена ( `\microblog\app\routes.py` ).

> `app/routes.py` : Login view function logic

    # ...
    from flask_login import current_user, login_user
    from app.models import User

    # ...

    @app.route('/login', methods=['GET', 'POST'])
    def login():
        if current_user.is_authenticated:
            return redirect(url_for('index'))
        form = LoginForm()
        if form.validate_on_submit():
            user = User.query.filter_by(username=form.username.data).first()
            if user is None or not user.check_password(form.password.data):
                flash('Invalid username or password')
                return redirect(url_for('login'))
            login_user(user, remember=form.remember_me.data)
            return redirect(url_for('index'))
        return render_template('login.html', title='Sign In', form=form)

Две верхние строчки в функции `login()` приводят к странной ситуации. Представьте, что у вас есть пользователь, который вошел в систему и желая перейти к URL-адресу `/login` вашего приложения заново попадает на страницу авторизации. Ясно, что это ошибка, поэтому я не хочу этого допускать. Переменная `current_user` поступает из Flask-Login и может использоваться в любое время для получения объекта пользователя. Значение этой переменной может быть пользовательским объектом из базы данных (который Flask-Login читает через обратный вызов загрузчика пользователя, представленный выше), или специальный анонимный пользовательский объект, если пользователь еще не входил в систему. Помните те свойства, которые требуются Flask в пользовательском объекте? Один из них был `is_authenticated` , что очень полезно, чтобы проверить, зарегистрирован ли пользователь или нет. Когда пользователь уже вошел в систему, я просто перенаправляю его на страницу *index* .

Вместо вызова flash(), который я использовал ранее, теперь я могу войти в систему пользователя по-настоящему. Первым шагом является загрузка пользователя из базы данных. Имя пользователя пришло с формой отправки, так что я могу запросить базу данных, чтобы найти пользователя.

Для этого я использую метод `filter_by()` объекта запроса SQLAlchemy. Результат `filter_by()` --- это запрос, который включает только объекты, у которых есть совпадающее имя пользователя. Поскольку я знаю, что будет только один или нулевой результат, я завершу запрос, вызвав `first()` , который вернет объект пользователя, если он существует, или `None` , если это не так. В **главе 4** вы видели, что когда вы вызываете метод `all()` в запросе, запрос выполняется, и вы получаете список всех результатов, соответствующих этому запросу. Метод `first()` является другим используемым способом выполнения запроса, когда вам нужен только один результат.

Если я получил соответствие для имени пользователя, которое было предоставлено, я могу проверить, действительно ли пароль, который также пришел с формой, действителен. Это делается путем вызова метода `check_password()` , определенного выше. Это приведет к хеш-паролю, хранящемуся у пользователя, и определит, соответствует ли введенный в форму пароль хешу или нет. Итак, теперь у меня есть два возможных условия ошибки: имя пользователя может быть недопустимым, или пароль может быть неправильным для пользователя. В любом из этих случаев я прокручиваю сообщение и перенаправляю обратно в приглашение для входа, чтобы пользователь мог попробовать еще раз.

Если имя пользователя и пароль верны, я вызываю функцию `login_user()` , которая поступает из Flask-Login. Эта функция будет регистрировать пользователя во время входа в систему, поэтому это означает, что на любых будущих страницах, к которым пользователь переходит, будет установлена ​​переменная `current_user` для этого пользователя.

Чтобы завершить процесс входа в систему, я просто перенаправляю вновь зарегистрированного пользователя на страницу *index* .

### Выход из системы

Очевидно, что нужно будет предложить пользователям возможность выхода из приложения. Это можно сделать с помощью функции `logout_user()` Flask-Login. Вот как выглядит функция выхода:

> `app/routes.py` : Logout view function

    # ...
    from flask_login import logout_user

    # ...

    @app.route('/logout')
    def logout():
        logout_user()
        return redirect(url_for('index'))

Я могу заставить ссылку « `login` » на панели навигации автоматически переключиться на ссылку « `logout` » после входа пользователя в систему. Это можно сделать с помощью условного выражения в шаблоне *base.html* :

> `app/templates/base.html` : Conditional login and logout links

    <div>
        Microblog:
        <a href="{{ url_for('index') }}">Home</a>
        {% if current_user.is_anonymous %}
        <a href="{{ url_for('login') }}">Login</a>
        {% else %}
        <a href="{{ url_for('logout') }}">Logout</a>
        {% endif %}
    </div>

Свойство `is_anonymous` является одним из атрибутов, которые Flask-Login добавляет к объектам пользователя через класс UserMixin. Выражение `current_user.is_anonymous` вернет `True` , только если пользователь не войдет в систему.

### Требование к пользовательскому входу

Flask-Login предоставляет очень полезную функцию, которая заставляет пользователей регистрироваться, прежде чем они смогут просматривать определенные страницы приложения. Если пользователь, который не выполнил вход в систему, пытается просмотреть защищенную страницу, Flask-Login автоматически перенаправляет пользователя в форму для входа и только после завершения процесса входа в систем перенаправляет на страницу, которую пользователь хотел просмотреть.

Чтобы эта функция была реализована, Flask-Login должен знать, что такое функция просмотра, которая обрабатывает логины. Это можно добавить в *app/ **init** .py:*

    # ...
    login = LoginManager(app)
    login.login_view = 'login'

Значение «login» выше является именем функции (или конечной точки) для входа в систему. Другими словами, имя, которое вы будете использовать в вызове `url_for()` , чтобы получить URL.

Способ Flask-Login защищает функцию просмотра от анонимных пользователей с помощью декоратора, называемого `@login_required` . Когда вы добавляете этот декоратор к функции вида под декораторами `@app.route` из Flask, функция становится защищенной и не разрешает доступ к пользователям, которые не аутентифицированы. Вот как декоратор может быть применен к функции просмотра индексов приложения:

> `app/routes.py` : \@login\_required decorator

    from flask_login import login_required

    @app.route('/')
    @app.route('/index')
    @login_required
    def index():
        # ...

Остается реализовать перенаправление с успешного входа на страницу, к которой пользователь хотел получить доступ. Когда пользователь, не входящий в систему, обращается к функции просмотра, защищенной декодером `@login_required` , декоратор собирается перенаправить на страницу входа в систему, но в это перенаправление будет включена дополнительная информация, чтобы приложение затем могло вернуться к первой странице. Если пользователь переходит, например на */index* , обработчик `@login_required` перехватит запрос и ответит перенаправлением на `/login` , но он добавит аргумент строки запроса к этому URL-адресу, сделав полный URL */login?Next = /index* . `next` аргумент строки запроса установлен на исходный URL-адрес, поэтому приложение может использовать это для перенаправления после входа в систему.

Вот фрагмент кода, который показывает, как читать и обрабатывать `next` -аргумент строки запроса:

> `app/routes.py` : Перенаправление на \"next\" (следующую) страницу

    from flask import request
    from werkzeug.urls import url_parse

    @app.route('/login', methods=['GET', 'POST'])
    def login():
        # ...
        if form.validate_on_submit():
            user = User.query.filter_by(username=form.username.data).first()
            if user is None or not user.check_password(form.password.data):
                flash('Invalid username or password')
                return redirect(url_for('login'))
            login_user(user, remember=form.remember_me.data)
            next_page = request.args.get('next')
            if not next_page or url_parse(next_page).netloc != '':
                next_page = url_for('index')
            return redirect(next_page)
        # ...

Сразу после того, как пользователь выполнил вход, вызвав функцию `login_user()` из *Flask-Login* , вы получите значение `next` -аргумента строки запроса. Flask содержит переменную запроса, содержащую всю информацию, которую клиент отправил с запросом. В частности, атрибут `request.args` предоставляет содержимое строки запроса в формате дружественного словаря. На самом деле существует три возможных случая, которые необходимо учитывать, чтобы определить, где перенаправить после успешного входа в систему:

-   Если URL-адрес входа не имеет следующего аргумента, пользователь перенаправляется на индексную страницу.
-   Если URL-адрес входа включает аргумент `next` , который установлен в относительный путь (или, другими словами, URL-адрес без части домена), тогда пользователь перенаправляется на этот URL-адрес.
-   Если URL-адрес входа включает аргумент `next` , который установлен на полный URL-адрес, который включает имя домена, то пользователь перенаправляется на страницу индекса.

Первый и второй случаи не требуют пояснений. Третий случай заключается в том, чтобы сделать приложение более безопасным. Злоумышленник может вставить URL-адрес на злоумышленный сайт в аргумент `next` , поэтому приложение перенаправляет только URL-адрес, что гарантирует, что перенаправление останется на том же сайте, что и приложение. Чтобы определить, является ли URL относительным или абсолютным, я анализирую его с помощью функции `url_parse()` *Werkzeug* , а затем проверяю, установлен ли компонент `netloc` или нет.

### Отображение вошедшего в систему пользователя в шаблонах

Помните ли вы, что еще в **главе 2** я создал ложного пользователя, чтобы помочь мне разработать домашнюю страницу приложения, прежде чем была создана подсистема пользователя? Ну, теперь приложение имеет реальных пользователей, так что теперь я могу удалить поддельных и начать работать с реальными. Вместо фейковых можно использовать Flask-Login-овых current\_user в шаблоне:

> `app/templates/index.html` : Передаём текущего пользователя в шаблон

    {% extends "base.html" %}

    {% block content %}
        <h1>Hi, {{ current_user.username }}!</h1>
        {% for post in posts %}
        <div><p>{{ post.author.username }} says: <b>{{ post.body }}</b></p></div>
        {% endfor %}
    {% endblock %}

И я могу удалить аргумент `user` в функции `view` ( *microblog\\app\\routes.py* ):

> app/routes.py: Do not pass user to template anymore

    @app.route('/')
    @app.route('/index')
    def index():
        # ...
        return render_template("index.html", title='Home Page', posts=posts)

Кажется наступил подходящий момент для проверки работоспособности входа и выхода. Поскольку регистрация пользователей по-прежнему отсутствует, единственный способ добавить пользователя в базу данных --- сделать это через оболочку Python, поэтому запустите `flask shell` и введите следующие команды для регистрации пользователя:

    >>> u = User(username='susan', email='susan@example.com')
    >>> u.set_password('cat')
    >>> db.session.add(u)
    >>> db.session.commit()

Если вы запустите приложение и попытаетесь получить доступ к `http:// localhost:5000/` или `http://localhost:5000/index` , вы будете немедленно перенаправлены на страницу входа в систему. И после завершения процедуры входа в систему, используя учетные данные пользователя, который вы добавили в свою базу данных, вы будете возвращены на исходную страницу, в которой вы увидите персонализированное приветствие.

### Регистрация пользователя

Последняя часть функциональности, которую я собираюсь построить в этой главе, --- это форма регистрации, чтобы пользователи могли зарегистрироваться через веб-форму. Начнем с создания класса веб-формы в *app/forms.py* :

    from flask_wtf import FlaskForm
    from wtforms import StringField, PasswordField, BooleanField, SubmitField
    from wtforms.validators import ValidationError, DataRequired, Email, EqualTo
    from app.models import User

    # ...

    class RegistrationForm(FlaskForm):
        username = StringField('Username', validators=[DataRequired()])
        email = StringField('Email', validators=[DataRequired(), Email()])
        password = PasswordField('Password', validators=[DataRequired()])
        password2 = PasswordField(
            'Repeat Password', validators=[DataRequired(), EqualTo('password')])
        submit = SubmitField('Register')

        def validate_username(self, username):
            user = User.query.filter_by(username=username.data).first()
            if user is not None:
                raise ValidationError('Please use a different username.')

        def validate_email(self, email):
            user = User.query.filter_by(email=email.data).first()
            if user is not None:
                raise ValidationError('Please use a different email address.')

В этой новой форме есть несколько интересных вещей, связанных с проверкой. Во-первых, для поля электронной почты `email` я добавил второй валидатор после DataRequired, называемый *Email* . Это еще один валидатор (в оригинале «stock validator», т.е. правильнее это перевести как встроенный, стандартный), который поставляется с WTForms, который гарантирует, что то, что пользователь вводит в этом поле, соответствует структуре адреса электронной почты.

Поскольку это форма регистрации, обычно принято запрашивать у пользователя два раза ввести пароль, чтобы уменьшить риск опечатки. По этой причине у меня есть `password` и `password2` . Во втором поле пароля используется еще один стандартный валидатор *EqualTo* , который проверяет, что его значение идентично значению для первого поля пароля.

Я также добавил к этому классу два метода: `validate_username()` и `validate_email()` . Когда вы добавляете какие-либо методы, соответствующие шаблону `validate_<имя_поля>` , WTForms принимает их как пользовательские валидаторы и вызывает их в дополнение к стандартным валидаторам. В этом случае я хочу убедиться, что имя пользователя и адрес электронной почты, введенные пользователем, еще не находятся в базе данных, поэтому эти два метода выдают запросы к базе данных, ожидая, что результатов не будет. В случае, если результат существует, ошибка проверки инициируется вызовом *ValidationError* . Сообщение, включенное в качестве аргумента в исключение, будет сообщением, которое будет отображаться рядом с полем для просмотра пользователем.

Чтобы отобразить эту форму на веб-странице, мне нужно иметь HTML-шаблон, который я собираюсь хранить в файле *app/templates/register.html* . Этот шаблон построен так же, как и для формы входа:

    {% extends "base.html" %}

    {% block content %}
        <h1>Register</h1>
        <form action="" method="post">
            {{ form.hidden_tag() }}
            <p>
                {{ form.username.label }}<br>
                {{ form.username(size=32) }}<br>
                {% for error in form.username.errors %}
                <span style="color: red;">[{{ error }}]</span>
                {% endfor %}
            </p>
            <p>
                {{ form.email.label }}<br>
                {{ form.email(size=64) }}<br>
                {% for error in form.email.errors %}
                <span style="color: red;">[{{ error }}]</span>
                {% endfor %}
            </p>
            <p>
                {{ form.password.label }}<br>
                {{ form.password(size=32) }}<br>
                {% for error in form.password.errors %}
                <span style="color: red;">[{{ error }}]</span>
                {% endfor %}
            </p>
            <p>
                {{ form.password2.label }}<br>
                {{ form.password2(size=32) }}<br>
                {% for error in form.password2.errors %}
                <span style="color: red;">[{{ error }}]</span>
                {% endfor %}
            </p>
            <p>{{ form.submit() }}</p>
        </form>
    {% endblock %}

Шаблон формы входа в систему нуждается в ссылке, которая отправляет новых пользователей в регистрационную форму, прямо под формой:

    <p>New User? <a href="{{ url_for('register') }}">Click to Register!</a></p>

И, наконец, мне нужно написать функцию просмотра, которая будет обрабатывать регистрацию пользователей в *app/routes.py* :

    from app import db
    from app.forms import RegistrationForm

    # ...

    @app.route('/register', methods=['GET', 'POST'])
    def register():
        if current_user.is_authenticated:
            return redirect(url_for('index'))
        form = RegistrationForm()
        if form.validate_on_submit():
            user = User(username=form.username.data, email=form.email.data)
            user.set_password(form.password.data)
            db.session.add(user)
            db.session.commit()
            flash('Congratulations, you are now a registered user!')
            return redirect(url_for('login'))
        return render_template('register.html', title='Register', form=form)

Сначала я убеждаюсь, что пользователь не вошел в систему. Схема работы такая же, как и для входа в систему. Логика, выполняемая внутри условия `if validate_on_submit()` , создает нового пользователя с именем, электронной почтой и паролем, записывает их в базу данных и затем перенаправляет запрос на вход, чтобы пользователь мог войти в систему.

![](https://habrastorage.org/getpro/habr/post_images/739/afd/926/739afd9265644988690702d4e6f15c3f.png)
:::

Глава 6: Страница профиля и аватары
-----------------------------------

::: {#post-content-body .post__text .post__text-html io-article-url="https://habr.com/ru/post/346348/"}
### Страница профиля пользователя

Чтобы создать страницу профиля пользователя, давайте сначала напишем новую функцию просмотра, которая будет отображаться в */user/\<имя пользователя\>* URL.

    @app.route('/user/<username>')
    @login_required
    def user(username):
        user = User.query.filter_by(username=username).first_or_404()
        posts = [
            {'author': user, 'body': 'Test post #1'},
            {'author': user, 'body': 'Test post #2'}
        ]
        return render_template('user.html', user=user, posts=posts)

Декоратор `@app.route` , который я использовал для объявления этой функции просмотра, немного отличается от предыдущих. В этом случае у меня есть динамический компонент, который обозначается как компонент URL-адреса `<username>` , который заключен в треугольные скобки, `<` и `>` . Когда маршрут имеет динамический компонент, Flask принимает любой текст в этой части URL-адреса и вызывает функцию просмотра с фактическим текстом в качестве аргумента. Например, если клиентский браузер запрашивает URL: */user/susan* , функция `view` будет вызываться с именем пользователя в качестве аргумента, установленным на `«susan»` . Эта функция просмотра будет доступна только для зарегистрированных пользователей, поэтому я добавил обработчик `@login_required` из Flask-Login.

Реализация этой функции просмотра довольно проста. Сначала я пытаюсь загрузить пользователя из базы данных, используя запрос по имени пользователя. Вы уже видели, что запрос базы данных может быть выполнен путем вызова `all()` , если вы хотите получить все результаты, или `first()` , если вы хотите получить только первый результат или, если же ничего, соответствующего критериям поиска, не найдется, то эти методы вернут None. В этой функции представления я использую вариант `first()` , называемый `first_or_404(),` который работает точно так же, как `first()` , когда есть результаты, но в случае отсутствия результатов автоматически обратно клиенту отправляется *ошибка 404* . Выполняя запрос таким образом, я не могу проверить, возвратился ли запрос пользователя, потому что, когда имя пользователя не существует в базе данных, функция не вернется, и вместо этого будет вызвано исключение *404* .

Если запрос базы данных не вызывает *ошибку 404* , это означает, что был найден пользователь с указанным именем пользователя. Затем я инициализирую временный список сообщений для этого пользователя, наконец, создаю новый шаблон `user.html` , которому передаю объект пользователя и список сообщений.

Шаблон *user.html* показан ниже:

    {% extends "base.html" %}

    {% block content %}
        <h1>User: {{ user.username }}</h1>
        <hr>
        {% for post in posts %}
        <p>
        {{ post.author.username }} says: <b>{{ post.body }}</b>
        </p>
        {% endfor %}
    {% endblock %}

Страница профиля завершена, но ссылка на нее не существует нигде на веб-сайте. Чтобы пользователям было проще проверить собственный профиль, я добавлю ссылку на него в панели навигации вверху:

    <div>
      Microblog:
      <a href="{{ url_for('index') }}">Home</a>
      {% if current_user.is_anonymous %}
      <a href="{{ url_for('login') }}">Login</a>
      {% else %}
      <a href="{{ url_for('user', username=current_user.username) }}">Profile</a>
      <a href="{{ url_for('logout') }}">Logout</a>
      {% endif %}
    </div>

Единственное интересное изменение здесь --- вызов `url_for()` , который используется для создания ссылки на страницу профиля. Поскольку функция просмотра профиля пользователя принимает динамический аргумент, функция `url_for()` получает значение для него как аргумент ключевого слова. Поскольку это ссылка, которая указывает на профиль пользователя в журнале, я могу использовать `current_user` Flask-Login для генерации правильного URL-адреса.

![](https://habrastorage.org/webt/t5/zb/cj/t5zbcjrvd0bar7zqrdpp6fxdiee.png)

Попробуйте! Нажав ссылку «Профиль» вверху страницы, вы попадете на свою страницу пользователя. На этом этапе нет ссылок, которые будут отображаться на странице профиля других пользователей, но если вы хотите получить доступ к этим страницам, вы можете ввести URL-адрес вручную в адресной строке браузера. Например, если у вас есть пользователь с именем «john», зарегистрированный в вашем приложении, вы можете просмотреть соответствующий профиль пользователя, введя *<http://localhost:5000/user/> john* в адресной строке.

### Аватары

Я уверен, вы согласитесь с тем, что страницы профиля, которые я только что построил, довольно скучны. Чтобы сделать их более интересными, я собираюсь добавить пользовательские аватары, но вместо того, чтобы иметь дело с возможно большой коллекцией загруженных изображений на сервере, я собираюсь использовать сервис *[Gravatar](http://gravatar.com/)* для предоставления изображений для всех пользователей.

Сервис *Gravatar* очень прост в использовании. Чтобы запросить изображение для данного пользователя, URL-адрес с форматом *<https://www.gravatar.com/avatar/> , где `<hash>` --- хеш MD5 адреса электронной почты пользователя. Ниже вы можете увидеть, как получить URL-адрес Gravatar для пользователя с адресом электронной почты `john@example.com` :*

    >>> from hashlib import md5
    >>> 'https://www.gravatar.com/avatar/' + md5(b'john@example.com').hexdigest()
    'https://www.gravatar.com/avatar/d4c74594d841139328695756648b6bd6'

Если вы хотите увидеть фактический пример, можно использовать мой собственный URL-адрес Gravatar --- *<https://www.gravatar.com/avatar/729e26a2a2c7ff24a71958d4aa4e5f35>* ( \' <https://www.gravatar.com/avatar/4f3699b436c12996ae54771200f21888> \' ). Вот что Gravatar возвращает для этого URL:

![](https://habrastorage.org/webt/1c/ue/o-/1cueo-lqtgsw7apk7667qvo5jvu.jpeg)

По умолчанию возвращенный размер изображения составляет 80x80 пикселей, но другой размер можно запросить, добавив аргумент `s` в строку запроса URL. Например, чтобы получить мой собственный аватар в виде изображения размером 128x128, URL-адрес: *<https://www.gravatar.com/avatar/729e26a2a2c7ff24a71958d4aa4e5f35?s=128>* .

Другим интересным аргументом, который может быть передан Gravatar в качестве аргумента строки запроса, является `d` , который определяет, какое изображение Gravatar предоставляет пользователям, у которых нет аватара, зарегистрированного в службе. Мой любимый называется «идентификатор», который возвращает приятный геометрический дизайн, который отличается для каждого письма. Например:

![](https://habrastorage.org/webt/_q/sb/lr/_qsblrgar21tbvvvcxzzzskwr_g.png)

Обратите внимание, что некоторые расширения веб-браузера, такие как Ghostery, блокируют изображения Gravatar, поскольку они считают, что Automattic (владельцы Gravatar) могут определять, какие сайты вы посещаете, на основе запросов, которые они получают для вашего аватара. Если вы не видите аватары в своем браузере, скорее всего проблема в расширениях браузера.

Поскольку аватары связаны с пользователями, имеет смысл добавить логику, которая генерирует URL-адреса аватара для пользовательской модели.

    from hashlib import md5
    # ...

    class User(UserMixin, db.Model):
        # ...
        def avatar(self, size):
            digest = md5(self.email.lower().encode('utf-8')).hexdigest()
            return 'https://www.gravatar.com/avatar/{}?d=identicon&s={}'.format(
                digest, size)

Новый метод `avatar()` класса `User` возвращает URL-адрес изображения аватара пользователя, масштабируется до требуемого размера в пикселях. Для пользователей, у которых нет зарегистрированного аватара, будет создано изображение «идентификатор». Чтобы сгенерировать хэш MD5, я конвертирую адрес электронной почты в нижний регистр, поскольку этого требует Gravatar. Затем, конвертирую полученный hash-объект в шестнадцатеричную строку (метод .hexdigest()), прежде чем передавать ее хэш-функции.

Если вы заинтересованы в ознакомлении с другими вариантами, предлагаемыми службой Gravatar, посетите их [сайт документации](https://gravatar.com/site/implement/images) .

Следующий шаг --- вставить изображения аватара в шаблон профиля пользователя:

    {% extends "base.html" %}

    {% block content %}
        <table>
            <tr valign="top">
                <td><img src="{{ user.avatar(128) }}"></td>
                <td><h1>User: {{ user.username }}</h1></td>
            </tr>
        </table>
        <hr>
        {% for post in posts %}
        <p>
        {{ post.author.username }} says: <b>{{ post.body }}</b>
        </p>
        {% endfor %}
    {% endblock %}

Большой плюс заключается в том, что пользовательский класс отвечает за возвращение URL-адресов аватаров.И если в какой-то день я решу, что аватары Gravatar не то, что я хочу, я могу просто переписать метод `avatar()` , чтобы возвращать разные URL-адреса, и все шаблоны начнут показывать новые аватары автоматически.

У меня есть хороший большой аватар в верхней части страницы профиля пользователя, но на самом деле нет причин останавливаться на достигнутом. У меня есть несколько сообщений от пользователя внизу, в которых каждый может иметь маленький аватар. Конечно, для страницы профиля пользователя все сообщения будут иметь один и тот же аватар, но тогда я могу реализовать ту же функциональность на главной странице, а затем каждый пост будет украшен аватаром автора, и это будет выглядеть очень красиво.

Чтобы показать аватары для отдельных сообщений, мне просто нужно сделать еще одно небольшое изменение в шаблоне:

    {% extends "base.html" %}

    {% block content %}
        <table>
            <tr valign="top">
                <td><img src="{{ user.avatar(128) }}"></td>
                <td><h1>User: {{ user.username }}</h1></td>
            </tr>
        </table>
        <hr>
        {% for post in posts %}
        <table>
            <tr valign="top">
                <td><img src="{{ post.author.avatar(36) }}"></td>
                <td>{{ post.author.username }} says:<br>{{ post.body }}</td>
            </tr>
        </table>
        {% endfor %}
    {% endblock %}

Вот так у Сьюзен, которой нет

![](https://habrastorage.org/webt/g3/c_/1r/g3c_1rhcu2qm20jgqupsmzj1jgi.png)

*(Прим. переводчика)* А вот так с реальным аккаунтом Gravatar.

![](https://habrastorage.org/webt/wg/js/ow/wgjsowjlzhpgzheugu4tgvwfdpa.png)

### Использование sub-templates Jinja2

Я разработал страницу профиля пользователя, чтобы отображать сообщения, написанные пользователем, вместе со своими аватарами. Теперь я хочу, чтобы страница индекса также отображала сообщения с похожим расположением. Я мог бы просто закопипастить часть шаблона, которая касается рендеринга сообщения, но это не правильно, потому что позже, если я решу внести изменения в этот макет, мне придется помнить об обновлении обоих шаблонов.

Вместо этого я собираюсь сделать подшаблон, который просто отображает одно сообщение, а затем я буду ссылаться на него как с шаблонов *user.html* , так и с *index.html* . Для начала я могу создать подшаблон, с разметкой HTML для одного сообщения. Назову, пожалуй, это шаблонное нечто *app/templates/\_post.html* . Префикс \`\_\' --- это просто соглашение об именах, которое помогает распознавать, какие файлы шаблонов являются подшаблонами.

    <table>
        <tr valign="top">
            <td><img src="{{ post.author.avatar(36) }}"></td>
            <td>{{ post.author.username }} says:<br>{{ post.body }}</td>
        </tr>
    </table>

Чтобы вызвать этот подшаблон из шаблона user.html, я использую оператор `include` Jinja2:

    {% extends "base.html" %}

    {% block content %}
        <table>
            <tr valign="top">
                <td><img src="{{ user.avatar(128) }}"></td>
                <td><h1>User: {{ user.username }}</h1></td>
            </tr>
        </table>
        <hr>
        {% for post in posts %}
            {% include '_post.html' %}
        {% endfor %}
    {% endblock %}

Страница index приложения на самом деле еще не сформирована, поэтому я пока не собираюсь добавлять эту функциональность.

### Более интересные профили

Одна из проблем, с которой сталкиваются новые страницы профиля пользователя, заключается в том, что они на самом деле многого не показывают. Пользователи любят рассказывать о чем то на этих страницах, поэтому я позволю им написать что-то о себе, чтобы показать здесь. Я также буду следить за тем, когда последний раз каждый пользователь обращался к сайту, а также показывать его на странице своего профиля.

Первое, что мне нужно сделать для поддержки всей этой дополнительной информации, --- это расширить таблицу пользователей в базе данных двумя новыми полями:

    class User(UserMixin, db.Model):
        # ...
        about_me = db.Column(db.String(140))
        last_seen = db.Column(db.DateTime, default=datetime.utcnow)

Каждый раз, когда база данных изменяется, необходимо создать миграцию базы данных. В **главе 4** я показал вам, как настроить приложение для отслеживания изменений базы данных с помощью сценариев миграции. Теперь у меня есть два новых поля, которые я хочу добавить в базу данных, поэтому первым шагом будет создание сценария миграции:

------------------------------------------------------------------------

*Прим. переводчика* : советую команды, да и тексты набирать самому. Получать ошибки/опечатки. Исправлять их. Все это процесс обучения, который сильно поможет в будущем.

Вот пример ошибки:

    (venv) C:\microblog>flask db upgrade
    INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
    INFO  [alembic.runtime.migration] Will assume non-transactional DDL.

    (venv) C:\microblog>flask db mograte -m "new fields in user model"
    Usage: flask db [OPTIONS] COMMAND [ARGS]...

    Error: No such command "mograte".

продолжаем\...

------------------------------------------------------------------------

    (venv) C:\microblog>flask db migrate -m "new fields in user model"
    INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
    INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
    INFO  [alembic.autogenerate.compare] Detected added column 'user.about_me'
    INFO  [alembic.autogenerate.compare] Detected added column 'user.last_seen'
    Generating C:\microblog\migrations\versions\45833c85abc8_new_fields_in_user_model.py ... done

    (venv) C:\microblog>

Результат команды `migrate` выглядит хорошо, поскольку он показывает, что были обнаружены два новых поля в классе User. Теперь я могу применить это изменение к базе данных:

    (venv) C:\microblog>flask db upgrade
    INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
    INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
    INFO  [alembic.runtime.migration] Running upgrade f8c5670875a3 -> 45833c85abc8, new fields in user model

Надеюсь, вы понимаете, насколько полезно работать с инфраструктурой миграции. Любые пользователи, которые находились в базе данных, все еще существуют, структура миграции оперативно применяет изменения в сценарии миграции, не разрушая никаких данных.

На следующем шаге я собираюсь добавить эти два новых поля в шаблон профиля пользователя:

    {% extends "base.html" %}

    {% block content %}
        <table>
            <tr valign="top">
                <td><img src="{{ user.avatar(128) }}"></td>
                <td>
                    <h1>User: {{ user.username }}</h1>
                    {% if user.about_me %}<p>{{ user.about_me }}</p>{% endif %}
                    {% if user.last_seen %}<p>Last seen on: {{ user.last_seen }}</p>{% endif %}
                </td>
            </tr>
        </table>
        ...
    {% endblock %}

Обратите внимание, что я обертываю эти два поля в условных выражениях Jinja2, потому что хочу, чтобы они были видимыми, если они заполнены. На этом этапе эти два новых поля пусты для всех пользователей, поэтому вы не увидите эти поля, если запустите приложение прямо сейчас.

### Запись последнего времени посещения для пользователя

Начнем с поля `last_seen` , более простого из двух. То, что я хочу сделать, это записать текущее время в этом поле для конкретного пользователя всякий раз, когда пользователь отправляет запрос на сервер. Добавление логина для установки этого поля во всевозможные функции просмотра, которые могут быть запрошены у браузера, очевидно, нецелесообразно, но выполнение немного общей логики перед запросом, отправляемым в функцию просмотра, является общей задачей в веб-приложениях, которые Flask предлагает его как родную функцию. Взгляните на решение:

    from datetime import datetime

    @app.before_request
    def before_request():
        if current_user.is_authenticated:
            current_user.last_seen = datetime.utcnow()
            db.session.commit()

Декоратор `@before_request` от Flask регистрирует декорированную функцию, которая должна быть выполнена непосредственно перед функцией просмотра. Это очень полезно, потому что теперь я могу вставить код, который я хочу выполнить перед любой функцией просмотра в приложении, и я могу использовать его в одном месте. Реализация просто проверяет, зарегистрирован ли `current_user` , и в этом случае устанавливает последнее поле в текущее время. Я уже упоминал об этом, серверное приложение должно работать в единых единицах времени, а стандартная практика --- использовать часовой пояс UTC. Использование локального времени системы не является хорошей идеей, потому что то, что происходит в базе данных, зависит от вашего местоположения. Последним шагом является фиксация сеанса базы данных, так что сделанное выше изменение записывается в базу данных. Если вам интересно, почему перед фиксацией нет `db.session.add()` , подумайте, что когда вы ссылаетесь на `current_user` , Flask-Login будет вызывать функцию обратного вызова загрузчика пользователя, который будет запускать запрос базы данных, который поместит целевого пользователя в сеанс базы данных. Таким образом, вы можете добавить пользователя снова в эту функцию, но это не обязательно, потому что он уже существует.

Если вы просмотрите страницу своего профиля после внесения этого изменения, вы увидите строку \"Last seen on\" (Последнее посещение) с временем, близким к текущему. И если вы перейдете от страницы профиля и затем вернетесь, вы увидите, что время постоянно обновляется.

Тот факт, что я храню эти временные метки в часовом поясе UTC, делает время, отображаемое на странице профиля, также в формате UTC. До кучи ко всему этому, формат времени --- это не то, что вы ожидаете, поскольку видим отображение внутреннего представление объекта `datetime` Python. На данный момент я не буду беспокоиться об этих двух проблемах, так как я расскажу о теме обработки дат и времени в веб-приложении в следующей главе.

![](https://habrastorage.org/webt/pg/sg/2o/pgsg2o6-6pmssz5-g4trd19f5eg.png)

### Редактор профиля

По хорошему пользователям нужно предоставить форму, в которой они могут ввести некоторую информацию о себе. Форма позволит пользователям изменить свой логин и другие данные, а также написать что-то о себе, чтобы быть сохраненным в новом поле *about\_me* . Давайте напишем класс для такой формы:

    from wtforms import StringField, TextAreaField, SubmitField
    from wtforms.validators import DataRequired, Length

    # ...

    class EditProfileForm(FlaskForm):
        username = StringField('Username', validators=[DataRequired()])
        about_me = TextAreaField('About me', validators=[Length(min=0, max=140)])
        submit = SubmitField('Submit')

Я использую новый тип поля и новый валидатор в этой форме. Для поля «About» я использую `TextAreaField` , который представляет собой многострочное поле, в котором пользователь может вводить текст. Чтобы проверить это поле, я использую `Length` , который будет следить за тем, чтобы введенный текст находился между 0 и 140 символами, который является пространством, которое я выделил для соответствующего поля в базе данных.

Шаблон, который отображает эту форму, показан ниже:

> app/templates/edit\_profile.html

    {% extends "base.html" %}

    {% block content %}
        <h1>Edit Profile</h1>
        <form action="" method="post">
            {{ form.hidden_tag() }}
            <p>
                {{ form.username.label }}<br>
                {{ form.username(size=32) }}<br>
                {% for error in form.username.errors %}
                <span style="color: red;">[{{ error }}]</span>
                {% endfor %}
            </p>
            <p>
                {{ form.about_me.label }}<br>
                {{ form.about_me(cols=50, rows=4) }}<br>
                {% for error in form.about_me.errors %}
                <span style="color: red;">[{{ error }}]</span>
                {% endfor %}
            </p>
            <p>{{ form.submit() }}</p>
        </form>
    {% endblock %}

И, наконец, вот функция, которая связывает все вместе:

    from app.forms import EditProfileForm

    @app.route('/edit_profile', methods=['GET', 'POST'])
    @login_required
    def edit_profile():
        form = EditProfileForm()
        if form.validate_on_submit():
            current_user.username = form.username.data
            current_user.about_me = form.about_me.data
            db.session.commit()
            flash('Your changes have been saved.')
            return redirect(url_for('edit_profile'))
        elif request.method == 'GET':
            form.username.data = current_user.username
            form.about_me.data = current_user.about_me
        return render_template('edit_profile.html', title='Edit Profile',
                               form=form)

Эта функция просмотра несколько отличается от другой, обрабатывающей форму. Если `validate_on_submit()` возвращает `True` , я копирую данные из формы в объект пользователя, а затем записываю объект в базу данных. Но когда `validate_on_submit()` возвращает `False` , это может быть вызвано двумя разными причинами. Во-первых, это может быть связано с тем, что браузер просто отправил запрос `GET` , на который мне нужно ответить, предоставив исходную версию шаблона формы. Во-вторых, это также возможно в случае, когда браузер отправляет запрос `POST` с данными формы, но что-то в этих данных является недопустимым. Для этой формы мне нужно рассматривать эти два случая отдельно. Когда форма запрашивается в первый раз с запросом `GET` , я хочу предварительно заполнить поля данными, которые хранятся в базе данных, поэтому мне нужно сделать обратное тому, что я сделал в случае отправки, и переместить данные, хранящиеся в полях пользователя, в форму, поскольку это гарантирует, что эти поля формы имеют текущие данные, хранящиеся для пользователя. Но в случае ошибки проверки я не хочу ничего писать в поля формы, потому что они уже были заполнены *WTForms* . Чтобы различать эти два случая, я проверяю `request.method` , который будет `GET` для первоначального запроса, и `POST` для отправки, которая не прошла проверку.

![](https://habrastorage.org/webt/om/ks/9q/omks9q7lihufpsaoubqy6xearei.png)

Чтобы пользователи могли получить доступ к странице редактора профилей, следует добавить ссылку на страницу профиля:

                {% if user == current_user %}
                <p><a href="{{ url_for('edit_profile') }}">Edit your profile</a></p>
                {% endif %}

Обратите внимание на хитрый условный код, который я использую, чтобы убедиться, что ссылка «Редактировать» появляется, когда вы просматриваете свой собственный профиль, но не когда кто то просматриваете ваш. Или вы профиль кого-то другого.

![](https://habrastorage.org/webt/bv/xp/7e/bvxp7e2b5oed2ijpiywsbwr9hpw.png)
:::

Глава 7: Обработка ошибок
-------------------------

::: {#post-content-body .post__text .post__text-html io-article-url="https://habr.com/ru/post/346880/"}
### Режим отладки

То, как ошибки обрабатываются выше, отлично подходит для системы, которая работает на production сервере. Если есть ошибка, пользователь получает страницу с неопределенной ошибкой (хотя я собираюсь сделать эту страницу с ошибкой более приятной), а важные данные об ошибке --- в выводе сервера или в файле журнала.

Но когда вы разрабатываете приложение, вы можете включить режим отладки, режим, в котором Flask выводит действительно хороший отладчик непосредственно в ваш браузер. Чтобы активировать режим отладки, остановите приложение, а затем установите следующую переменную среды:

    (venv) $ export FLASK_DEBUG=1

Если вы работаете в ОС Microsoft Windows, не забудьте использовать `set` вместо экспорта.

После того, как вы установили FLASK\_DEBUG, перезапустите сервер. Строки на вашем терминале будут немного отличаться от того, что вы привыкли видеть:

    (venv) microblog2 $ flask run
     * Serving Flask app "microblog"
     * Forcing debug mode on
     * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
     * Restarting with stat
     * Debugger is active!
     * Debugger PIN: 177-562-960

Теперь устроим приложению аварийный сбой еще раз, чтобы увидеть интерактивный отладчик в вашем браузере:

![](https://habrastorage.org/webt/64/ec/um/64ecumjr_lxgo9dlmsectaksb1g.png)

Отладчик позволяет развернуть каждый уровень стека и увидеть соответствующий исходный код. Вы также можете открыть Python для любого из фреймов и выполнить любые допустимые выражения Python, например, чтобы проверить значения переменных.

Крайне важно, чтобы вы никогда не запускали приложение Flask в режиме отладки на рабочем сервере. Отладчик позволяет удаленно выполнять код на сервере, поэтому он может стать неожиданным подарком злоумышленнику, который хочет проникнуть в ваше приложение или на ваш сервер. В качестве дополнительной меры безопасности отладчик, запущенный в браузере, закроется, и при первом использовании запросит PIN-код, который вы можете увидеть на выходе команды `flask run` .

Поскольку я говорю о режиме отладки, следует упомянуть про вторую важную функцию, которая включена в режиме отладки --- перезагрузка. Это очень полезная функция разработки, которая автоматически перезапускает приложение при изменении исходного файла. Если вы выполните `flask run` в режиме отладки, можно продолжать работать в своем приложении и при каждом сохранении файла, приложение перезапустится, чтобы забрать новый код.

### Пользовательские страницы ошибок

Flask предоставляет механизм приложения для создания собственных страниц ошибок, так что вашим пользователям не нужно видеть простые и скучные значения по умолчанию. В качестве примера давайте определим пользовательские страницы ошибок для ошибок HTTP 404 и 500, двух наиболее распространенных. Определение страниц для других ошибок работает одинаково.

Чтобы объявить пользовательский обработчик ошибок, используется декоратор `@errorhandler` . Я собираюсь поместить обработчики ошибок в новый модуль *app/errors.py* .

    from flask import render_template
    from app import app, db

    @app.errorhandler(404)
    def not_found_error(error):
        return render_template('404.html'), 404

    @app.errorhandler(500)
    def internal_error(error):
        db.session.rollback()
        return render_template('500.html'), 500

Функции ошибок работают аналогично функциям просмотра. Для этих двух ошибок я возвращаю содержимое их соответствующих шаблонов. Обратите внимание, что обе функции возвращают второе значение после шаблона, который является номером кода ошибки. Для всех функций представления, которые я создал до сих пор, мне не нужно было добавлять второе возвращаемое значение, потому что по умолчанию 200 (код состояния для успешного завершения) --- это то, что я хотел. Сейчас это страницы с ошибками, поэтому я хочу, чтобы код состояния ответа это отражал.

Обработчик ошибок для 500-й ошибки может быть вызван после возникновения сбоя базы данных, которая на самом деле была вызвана умышленным случаем дубликата имени пользователя. Чтобы убедиться, что неудачные сеансы базы данных не мешают доступу к базе данных, вызванным шаблоном, я выдаю откат сеанса. Это сбрасывает сеанс в чистое состояние.

Вот шаблон для ошибки 404:

    {% extends "base.html" %}

    {% block content %}
        <h1>File Not Found</h1>
        <p><a href="{{ url_for('index') }}">Back</a></p>
    {% endblock %}

И вот одна из ошибок 500:

    {% extends "base.html" %}

    {% block content %}
        <h1>An unexpected error has occurred</h1>
        <p>The administrator has been notified. Sorry for the inconvenience!</p>
        <p><a href="{{ url_for('index') }}">Back</a></p>
    {% endblock %}

Оба шаблона наследуют шаблон `base.html` , так что страница с ошибками имеет тот же внешний вид, что и обычные страницы приложения.

Чтобы получить эти обработчики ошибок, зарегистрированные в Flask, мне нужно импортировать новый модуль `app/errors.py` после создания экземпляра приложения:

    # ...

    from app import routes, models, errors

Если вы установили `FLASK_DEBUG = 0` в сеансе терминала и затем снова вызвали ошибку повторного имени пользователя, вы увидите более приятную страницу с ошибкой.

![](https://habrastorage.org/webt/ea/cn/vn/eacnvnhobuzutlix1tkqjznxl18.png)

*Или так! Рекомендую придумать что то свое в качестве упражнения.*

![](https://habrastorage.org/webt/er/xx/3s/erxx3s-jcfrlcja1_vqbfq59yu4.png)

### Отправка ошибок по электронной почте

Другая проблема с обработкой ошибок по умолчанию, предоставляемой Flask, заключается в том, что нет уведомлений! Трассировка стека ошибки печатается на терминале, а это означает, что вывод процесса сервера должен контролироваться на обнаружение ошибок. Когда вы запускаете приложение во время разработки, это нормально, но как только приложение будет развернуто на production сервере, никто не будет смотреть на результат, поэтому необходимо создать более надежное решение.

Я думаю, что очень важно, чтобы я активно реагировал на ошибки. Если в production версии приложения возникает ошибка, я хочу знать сразу. Таким образом, моим первым решением будет сконфигурировать Flask для отправки мне сообщения по email сразу после возникновения ошибки с трассировкой стека ошибки в сообщении электронной почты.

Первым шагом является добавление данных сервера электронной почты в файл конфигурации:

    class Config(object):
        # ...
        MAIL_SERVER = os.environ.get('MAIL_SERVER')
        MAIL_PORT = int(os.environ.get('MAIL_PORT') or 25)
        MAIL_USE_TLS = os.environ.get('MAIL_USE_TLS') is not None
        MAIL_USERNAME = os.environ.get('MAIL_USERNAME')
        MAIL_PASSWORD = os.environ.get('MAIL_PASSWORD')
        ADMINS = ['your-email@example.com']

Переменные конфигурации для электронной почты содержат сервер и порт, флаг для включения зашифрованных соединений и необязательное имя пользователя и пароль. Пять переменных конфигурации получены из их сопоставлений переменным среды. Если сервер электронной почты не установлен в среде, то я буду использовать это как знак того, что ошибки электронной почты должны быть отключены. Порт сервера электронной почты также можно указать в переменной среды, но если он не установлен, используется стандартный порт 25. Учетные данные почтового сервера по умолчанию не используются, но могут быть предоставлены при необходимости. Переменная конфигурации `ADMINS` представляет собой список адресов электронной почты, которые будут получать отчеты об ошибках, поэтому ваш собственный адрес электронной почты должен быть в этом списке.

Flask использует пакет `logging` Python для ведения своих журналов, а этот пакет уже имеет возможность отправлять журналы по электронной почте. Все, что мне нужно сделать, чтобы отправлять электронные сообщения, содержащие ошибки, --- это добавить экземпляр [SMTPHandler](https://docs.python.org/3.6/library/logging.handlers.html#smtphandler) в объект журнала Flask, которым является `app.logger` :

    import logging
    from logging.handlers import SMTPHandler

    # ...

    if not app.debug:
        if app.config['MAIL_SERVER']:
            auth = None
            if app.config['MAIL_USERNAME'] or app.config['MAIL_PASSWORD']:
                auth = (app.config['MAIL_USERNAME'], app.config['MAIL_PASSWORD'])
            secure = None
            if app.config['MAIL_USE_TLS']:
                secure = ()
            mail_handler = SMTPHandler(
                mailhost=(app.config['MAIL_SERVER'], app.config['MAIL_PORT']),
                fromaddr='no-reply@' + app.config['MAIL_SERVER'],
                toaddrs=app.config['ADMINS'], subject='Microblog Failure',
                credentials=auth, secure=secure)
            mail_handler.setLevel(logging.ERROR)
            app.logger.addHandler(mail_handler)

Как видно, я включил регистратор электронной почты только, когда приложение работает без режима отладки, что определено приложением в `app.debug` как `True` , а также когда сервер электронной почты существует в конфигурации.

Настройка почтового регистратора несколько утомительна из-за необходимости обрабатывать дополнительные параметры безопасности, которые присутствуют на многих серверах электронной почты. Но в сущности, вышеприведенный код создает экземпляр `SMTPHandler` , устанавливает его уровень, чтобы он отправлял только сообщения об ошибках, а не предупреждения, информационные или отладочные сообщения и, наконец, прикреплял их к `app.logger` из Flask.

Существует два подхода к проверке работоспособности этой функции. Самый простой способ --- использовать SMTP-сервер отладки от Python. Это ложный почтовый сервер, который принимает сообщения электронной почты, но вместо их отправки выводит их на консоль. Чтобы запустить этот сервер, откройте второй сеанс терминала и запустите на нем следующую команду:

    (venv) $ python -m smtpd -n -c DebuggingServer localhost:8025

Оставьте запущенный SMTP-сервер отладки и вернитесь к своему первому терминалу и установите `export` `MAIL_SERVER = localhost` и `MAIL_PORT = 8025` (используйте `set` вместо `export` , если вы используете Microsoft Windows). Убедитесь, что для переменной `FLASK_DEBUG` установлено значение `0` или не установлено вообще, так как приложение не будет отправлять электронные письма в режиме отладки. Запустите приложение и вызовите ошибку SQLAlchemy еще раз, чтобы узнать, как сеанс терминала, на котором работает поддельный почтовый сервер, показывает электронное письмо с полным содержимым стека ошибки.

Второй метод тестирования для этой функции --- настроить настоящий почтовый сервер. Ниже приведена конфигурация для использования почтового сервера для учетной записи *Gmail* :

    export MAIL_SERVER=smtp.googlemail.com
    export MAIL_PORT=587
    export MAIL_USE_TLS=1
    export MAIL_USERNAME=<your-gmail-username>
    export MAIL_PASSWORD=<your-gmail-password>

Если вы используете Microsoft Windows, не забудьте использовать `set` вместо `export` в каждой из приведенной выше инструкции.

Функции безопасности вашей учетной записи Gmail могут препятствовать приложению отправлять электронную почту через нее, если вы явно не разрешаете \"less secure apps\" («менее безопасным приложениям») доступ к вашей учетной записи Gmail. Прочитать об этом можно [здесь](https://support.google.com/accounts/answer/6010255?hl=en) , и если вас беспокоит безопасность вашей учетной записи, можно создать вторичную учетную запись, которую настройте только для проверки электронной почты, или временно включите разрешение для менее безопасных приложений на время запуска этого теста, а затем вернитесь к умолчанию.

### Запись лога в файл

Получение ошибок по электронной почте полезно, но иногда недостаточно. Есть некоторые случаи сбоя, которые не описываются исключением Python и не являются серьезной проблемой, но они все равно могут быть достаточно интересными для сохранения в целях отладки. По этой причине я также буду поддерживать логфайл для приложения.

Чтобы включить ведение журнала другого обработчика, на этот раз типа `RotatingFileHandler` необходимо включить logger приложения аналогично обработчику электронной почты.

    # ...
    from logging.handlers import RotatingFileHandler
    import os

    # ...

    if not app.debug:
        # ...

        if not os.path.exists('logs'):
            os.mkdir('logs')
        file_handler = RotatingFileHandler('logs/microblog.log', maxBytes=10240,
                                           backupCount=10)
        file_handler.setFormatter(logging.Formatter(
            '%(asctime)s %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]'))
        file_handler.setLevel(logging.INFO)
        app.logger.addHandler(file_handler)

        app.logger.setLevel(logging.INFO)
        app.logger.info('Microblog startup')

Я пишу логфайл с именем `microblog.log` в каталоге *logs* , который я создаю, если он еще не существует.

Класс `RotatingFileHandler` удобен, потому что он переписывает журналы, гарантируя, что файлы журнала не будут слишком большими, если приложение работает в течение длительного времени. В этом случае я ограничиваю размер логфайла 10 КБ, и храню последние десять файлов журнала в качестве резервных копий.

Класс `logging.Formatter` предоставляет настройку формата сообщений журнала. Поскольку эти сообщения отправляются в файл, я хочу, чтобы они содержали как можно больше информации. Поэтому я использую формат, который включает отметку времени, уровень ведения журнала, сообщение, исходный файл и номер строки, откуда возникла запись в журнале.

Чтобы сделать регистрацию более полезной, я также понижаю уровень ведения журнала до категории `INFO` , как в регистраторе приложений, так и в обработчике файлов. Если вы не знакомы с категориями ведения журнала, это `DEBUG` , `INFO` , `WARNING` , `ERROR` и `CRITICAL` в порядке возрастания степени тяжести.

В качестве первого полезного использования логфайла сервер записывает строку в журнал каждый раз, когда он запускается. Когда приложение запускается на production сервере, эти записи журнала сообщают вам, когда сервер был перезапущен.

### Исправление дубля имени пользователя

Я слишком долго использовал ошибку дублирования имени пользователя. Теперь, когда я показал вам, как подготовить приложение для обработки подобных ошибок, я могу наконец-то это исправить.

Если вы помните, `RegistrationForm` уже выполняет проверку для имен пользователей, но требования формы редактирования немного отличаются. Во время регистрации мне нужно убедиться, что имя пользователя, введенное в форму, не существует в базе данных. В форме профиля редактирования я должен выполнить ту же проверку, но с одним исключением. Если пользователь оставляет исходное имя пользователя нетронутым, то проверка должна его разрешить, поскольку это имя пользователя уже назначено этому пользователю. Ниже вы можете увидеть, как я выполнил проверку имени пользователя для этой формы:

    class EditProfileForm(FlaskForm):
        username = StringField('Username', validators=[DataRequired()])
        about_me = TextAreaField('About me', validators=[Length(min=0, max=140)])
        submit = SubmitField('Submit')

        def __init__(self, original_username, *args, **kwargs):
            super(EditProfileForm, self).__init__(*args, **kwargs)
            self.original_username = original_username

        def validate_username(self, username):
            if username.data != self.original_username:
                user = User.query.filter_by(username=self.username.data).first()
                if user is not None:
                    raise ValidationError('Please use a different username.')

Реализация выполняется в специальном методе проверки, функция super в конструкторе класса, который принимает исходное имя пользователя в качестве аргумента. Это имя пользователя сохраняется как переменная экземпляра и проверяется в методе `validate_username()` . Если имя пользователя, введенное в форму, совпадает с исходным именем пользователя, то нет причин проверять базу данных на наличие дубликатов.

Чтобы использовать этот новый метод проверки, мне нужно добавить исходный аргумент имени пользователя в функцию вида, где создается объект формы:

    @app.route('/edit_profile', methods=['GET', 'POST'])
    @login_required
    def edit_profile():
        form = EditProfileForm(current_user.username)
        # ...

Теперь ошибка исправлена, и дубликаты в форме профиля редактирования будут предотвращены в большинстве случаев. Это не идеальное решение, поскольку оно может не работать, когда два или несколько процессов одновременно обращаются к базе данных. В этой ситуации *состояние гонки* может привести к валидации, но спустя мгновение при попытке переименования база данных уже была изменена другим процессом и не может переименовать пользователя. Это несколько маловероятно, за исключением очень занятых приложений, у которых много серверных процессов, поэтому я пока не буду беспокоиться об этом.

На этом этапе вы можете попытаться воспроизвести ошибку еще раз, чтобы увидеть, как ее предотвращает метод проверки формы.

[\<\<\< предыдущая](https://habrahabr.ru/post/346348/) [следующая \>\>\>](https://habrahabr.ru/post/347450/)

P.S.

### Работа над ошибками

*От переводчика*

Решил я проверить получение сообщений ошибки админу на почту. Для этого я испортил модуль `routes.py` . Для этой самой \"порчи\", я закомментировал декоратор `@app.route('/edit_profile', methods=['GET', 'POST'])` перед `def edit_profile()` . В итоге получил ошибку и в файл лога все это вывалилось, а вот письмо не прилетело. Я использую Python 3.3. Возможно в более новых версиях этого и не случится. Но в Windows 7 с русской раскладкой это случилось.

При попытке отправить сообщение админу приложение получило ошибку кодировки при формировании сообщения. В окне консоли содержались такие строки:

![](https://habrastorage.org/webt/pb/xi/wy/pbxiwyup8n2sa1-rhrpqfaordps.png)

Как видим ссылка указывает на директорию в стандартном питоне, а не в виртуальном окружении.

`logging` в 3-й версии является стандартной библиотекой Python, поэтому вам не нужно устанавливать ее используя `pip` .

::: {.spoiler}
**Про стандартные модули**

::: {.spoiler_text}
И модуль протоколирования, который вы можете найти в PyPI, устаревший, а не Python3-совместимый.

(Согласно файлу README его последняя версия была выпущена 02 марта 2005 года.)

Поэтому просто не пытайтесь установить logging. Возьмите новый модуль в стандартной библиотеке как должное. Если вам принципиально использовать его в виртальной библиотеке.

После копии в *venv\\Lib* `logging` импортируется из виртуальной среды

![](https://habrastorage.org/webt/jz/ar/fc/jzarfczhqicy7f6mke2skzqdumo.png)

Еще раз получаю ошибку

![](https://habrastorage.org/webt/x_/q0/k3/x_q0k3zhdps1-saypzabsa_n-nw.png)

`logging` теперь виртуальный. А вот `smtplib` стандартный.

Не думаю, что надо тащить все библиотеки из стандартной среды в виртуальную. Ошибка от этого не исчезнет.
:::
:::

::: {.spoiler}
**Про стандартный модуль email**

::: {.spoiler_text}
Проблема с кодировкой в сообщении решается использованием стандартного пакета `email` для создания сообщения с указанием предпочитаемой кодировки.

Вот [пример](http://python.su/forum/topic/6076/) с просторов интернета для этого пакета :

    # -*- coding: utf-8 -*-
    from email.mime.multipart import MIMEMultipart
    from email.mime.text import MIMEText
    import quopri
    def QuoHead(String):
        s = quopri.encodestring(String.encode('UTF-8'), 1, 0)
        return "=?utf-8?Q?" + s.decode('UTF-8') + "?="
    FIOin = "Хрюша Степашкин"
    emailout = "some@test.ru"
    emailin = "some2@test.ru"
    msg = MIMEMultipart()
    msg["Subject"] = QuoHead("Добрый день " + FIOin).replace('=\n', '')
    msg["From"] = (QuoHead("Каркуша Федоровна") + "  <" + emailout + ">").replace('=\n', '') 
    msg["To"] = (QuoHead(FIOin) + "  <" + emailin + ">").replace('=\n', '')
    m = """Добрый день.
      Это тестовое письмо.
    Пожалуйста, не отвечайте на него."""
    text = MIMEText(m.encode('utf-8'), 'plain', 'UTF-8')
    msg.attach(text)
    print(msg.as_string())

Но, как это применить для отправки сообщений об ошибке?! Может кто-то предложит в комментариях к статье.
:::
:::

В модуле `flask-mail` эта ситуевина вроде как [поправлена](https://github.com/mattupstate/flask-mail/pull/85/commits/868e31590420a8e8d4b197cd2204d5d37140f370) . Но тут используется `logging` и `smtplib`

В итоге **пока** так. Поправил я строку в модуле `smtplib.py` .

Добавил `encode('utf-8')`

![](https://habrastorage.org/webt/bz/7v/yg/bz7vygxmlekgbi4de4e-ccgevby.png)

И после перезапуска сервера при искусственной ошибке я, наконец-то, получил сообщение на почту.
:::

Глава 8: Подписчики, контакты и друзья
--------------------------------------

::: {#post-content-body .post__text .post__text-html io-article-url="https://habr.com/ru/post/347450/"}
### Снова связи базы данных

Как я сказал выше, хочу поддерживать список пользователей «отслеживаемых» и «подписчиков» *( \"followed\" and \"follower\" )* для каждого пользователя. К сожалению, реляционная база данных не имеет типа `list` список, который я могу использовать для этих самых списков, все, что есть --- это таблицы с записями и отношениями между этими записями.

В базе данных есть таблица, представляющая пользователей `users` , так что осталось придумать правильный тип отношений, который может моделировать *followed/follower* ссылку. Давайте просмотрим базовые типы отношений в базе данных:

#### Один ко многим ( One-to-Many )

Я уже использовал отношения *«один ко многим»* в [**главе 4**](https://habrahabr.ru/post/346344/) . Вот диаграмма для этой связи:

![](https://habrastorage.org/webt/sr/2u/1c/sr2u1cy4uzvxvxn5nyairks7qns.png)

Двумя объектами, связанными этим отношением, являются пользователи и сообщения. Видим, что у пользователя *много* сообщений, а у сообщения есть *один* пользователь (или автор). Связь представлена ​​в базе данных с использованием внешнего ключа *foreign key* на стороне «много». В вышеприведенной связи внешний ключ --- это поле `user_id` , добавленное в таблицу сообщений `posts` . Это поле связывает каждое сообщение с записью его автора в пользовательской таблице.

Очевидно, что поле `user_id` обеспечивает прямой доступ к автору данного сообщения, но как насчет обратного направления? Чтобы связь была полезной, я должен иметь возможность получить список сообщений, написанных данным пользователем. Поле `user_id` в таблице `posts` также является достаточным для ответа на этот вопрос, поскольку базы данных имеют индексы, которые позволяют создавать эффективные запросы, так что мы «извлекаем ( retrieve ) все сообщения, которые имеют user\_id из X».

#### Многие-ко-многим ( Many-to-Many )

Отношение «многие ко многим» несколько сложнее. В качестве примера рассмотрим базу данных, в которой есть студенты `students` и преподаватели `teachers` . Могу сказать, что у студента много учителей, а у учителя много учеников. Это похоже на два взаимосвязанных отношения «один ко многим» с обоих концов. Для отношений этого типа я должен быть в состоянии запросить базу данных и получить список учителей, которые учат данного учащегося, и список учеников в классе учителя. Это нетривиально для представления в реляционной базе данных, поскольку это невозможно сделать, добавив внешние ключи к существующим таблицам.

Представление многозначного представления, `many-to-many` требуют использования вспомогательной таблицы, называемой таблицей ассоциаций *association table* . Вот пример организации поиска студентов и преподавателей в базе:

![](https://habrastorage.org/webt/5a/s8/0v/5as80vr1zyjj5lsm3ckpubokbpo.png)

Возможно кому то это может показаться неясным, таблица ассоциаций с двумя внешними ключами эффективно отвечает на все запросы о взаимоотношениях.

#### «Много-к-одному» и «один-к-одному» ( Many-to-One and One-to-One )

Много-к-одному похоже на отношение один-ко-многим. Разница в том, что эта связь рассматривается со стороны «Много».

Один-к-одному --- частный случай «один ко многим». Представление аналогично, но в базу данных добавляется ограничение, чтобы предотвратить сторону «Много», запрещающее иметь более одной ссылки. Хотя бывают случаи, когда этот тип отношений полезен, но он не так распространен, как другие типы.

### Представление подписчиков

По сумме анализа всех представленных выше типов отношений, легко определить, что правильная модель данных для отслеживания подписчиков *followers* --- это отношения «многие ко многим», поскольку отслеживаемый (follows) следит за *многими* пользователями (users), а пользователь (user) имеет *много* подписчиков (followers). Но тут есть подстава. В примере с учениками и учителями у меня было два объекта, которые были связаны между собой отношениями «многие ко многим». Но в случае с подписчиками (followers) у меня есть пользователи, которые следуют за другими пользователями, поэтому есть только пользователи. Итак, какова вторая структура отношений «многие-ко-многим»?

Второй объект отношений --- это также пользователи. Отношение, в котором экземпляры класса связаны с другими экземплярами одного и того же класса, называется самореферентным отношением ( self-referential relationship ), и именно это я здесь и имею.

Вот диаграмма самореферентных отношений «многие ко многим» отслеживания подписчиков:

![](https://habrastorage.org/webt/rm/7y/9v/rm7y9viomscnk0u2uq1nwbscjra.png)

Таблица `followers` --- это таблица ассоциаций отношений или таблицей относительных связей. Внешние ключи ( foreign keys ) в этой таблице указывают на записи в пользовательской таблице, поскольку они связывают пользователей с пользователями. Каждая запись в этой таблице представляет собой одну связь между пользователем-подписчиком follower user и подписанным пользователем followed user. Как пример учеников и учителей, такая настройка, как эта, позволяет базе данных отвечать на все вопросы о подписанных и подписчиках, которые мне когда-либо понадобятся. Довольно аккуратно.

### Представление модели базы данных

Давайте сначала добавим последователей в базу данных. Вот таблица ассоциаций подписчиков:

    followers = db.Table('followers',
        db.Column('follower_id', db.Integer, db.ForeignKey('user.id')),
        db.Column('followed_id', db.Integer, db.ForeignKey('user.id'))
    )

Это прямая трансляция таблицы ассоциаций из моей диаграммы выше. Обратите внимание, что я не объявляю эту таблицу в качестве модели, как я сделал для таблиц пользователей и сообщений. Поскольку это вспомогательная таблица, которая не имеет данных, отличных от внешних ключей, я создал ее без соответствующего класса модели.

Теперь я могу объявить отношения «многие ко многим» в таблице users:

    class User(UserMixin, db.Model):
        # ...
        followed = db.relationship(
            'User', secondary=followers,
            primaryjoin=(followers.c.follower_id == id),
            secondaryjoin=(followers.c.followed_id == id),
            backref=db.backref('followers', lazy='dynamic'), lazy='dynamic')

> *Прим. переводчика* followers. **c** .follower\_id «c» --- это атрибут таблиц SQLAlchemy, которые не определены как модели. Для этих таблиц столбцы таблицы отображаются как субатрибуты этого атрибута «c».

Настройка отношения нетривиальна. Как и в случае отношений `posts` «один-ко-многим», я использую функцию `db.relationship` для определения отношений в классе модели. Эта взаимосвязь связывает экземпляры `User` с другими экземплярами `User` , так как соглашение позволяет сказать, что для пары пользователей, связанных этим отношением, пользователь левой стороны следит за пользователем правой стороны. Я определяю связь, как видно из левой стороны с именем `followed` , потому что, когда я запрашиваю эту связь с левой стороны, я получу список последующих пользователей (т.e. тех, на правой стороне). Давайте рассмотрим все аргументы вызова `db.relationship()` один за другим:

-   `'User'` --- это правая сторона связи (левая сторона --- это родительский класс). Поскольку это самореферентное отношение, я должен использовать тот же класс с обеих сторон.
-   `secondary` кофигурирует таблицу ассоциаций, которая используется для этой связи, которую я определил прямо над этим классом.
-   `primaryjoin` указывает условие, которое связывает объект левой стороны (follower user) с таблицей ассоциаций. Условием объединения для левой стороны связи является идентификатор пользователя, соответствующий полю `follower_id` таблицы ассоциаций. Выражение `followers.c.follower_id` ссылается на столбец `follower_id` таблицы ассоциаций.
-   `secondaryjoin` определяет условие, которое связывает объект правой стороны (followed user) с таблицей ассоциаций. Это условие похоже на `primaryjoin` , с той лишь разницей, что теперь я использую `followed_id` , который является другим внешним ключом в таблице ассоциаций.
-   `backref` определяет, как эта связь будет доступна из правой части объекта. С левой стороны отношения пользователи называются `followed` , поэтому с правой стороны я буду использовать имя `followers` , чтобы представить всех пользователей левой стороны, которые связаны с целевым пользователем в правой части. Дополнительный `lazy` аргумент указывает режим выполнения этого запроса. Режим `dynamic` настройки запроса не позволяет запускаться до тех пор, пока не будет выполнен конкретный запрос, что также связано с тем, как установлено отношения «один ко многим». - `lazy` похож на параметр с тем же именем в `backref` , но этот относится к левой, а не к правой стороне.

Не беспокойтесь, если это трудно понять. Я покажу вам, как работать с этими запросами и тогда в одно мгновение все станет понятнее.

Изменения в базе данных необходимо записать в новой миграции базы данных:

    (venv) $ flask db migrate -m "followers"
    INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
    INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
    INFO  [alembic.autogenerate.compare] Detected added table 'followers'
      Generating /home/miguel/microblog/migrations/versions/ae346256b650_followers.py ... done

    (venv) $ flask db upgrade
    INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
    INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
    INFO  [alembic.runtime.migration] Running upgrade 37f06a334dbf -> ae346256b650, followers

### Добавление и удаление \"follows\" (подписчика)

Благодаря ORM SQLAlchemy пользователь, подписывающийся на отслеживание другого пользователя, может быть записан в базу данных, как `followed` если бы это был список. Например, если у меня было два пользователя, которые хранятся в переменных `user1` и `user2` , я могу сделать первого `user1` следящим за вторым `user2` с помощью этого простого оператора:

    user1.followed.append(user2)

Чтобы `user1` отказаться от слежения за пользователем `user2` , надо сделать так:

    user1.followed.remove(user2)

Несмотря на то, что добавление и удаление подписчиков делается довольно легко, я хочу упростить повторное использование в своем коде, поэтому я не собираюсь \"добавлять\" (appends) и \"удалять\" (removes) через код. Вместо этого я собираюсь реализовать функциональность \"follow\" и \"unfollow\" как методы в `User` модели. Всегда лучше переместить логику приложения подальше от функций просмотра в модель или в другие вспомогательные классы или модули, потому что, как вы увидите далее в этой главе, это делает модульное тестирование намного проще.

Ниже приведены изменения в пользовательской модели для добавления и удаления связей:

    class User(UserMixin, db.Model):
        #...

        def follow(self, user):
            if not self.is_following(user):
                self.followed.append(user)

        def unfollow(self, user):
            if self.is_following(user):
                self.followed.remove(user)

        def is_following(self, user):
            return self.followed.filter(
                followers.c.followed_id == user.id).count() > 0

Методы `follow()` и `unfollow()` используют методы `append()` и `remove()` объекта, как показано выше, но прежде чем они будут применены, они используют метод проверки `is_following()` , чтобы убедиться, что запрошенное действие обладает смыслом. Например, если я попрошу *user1* следить за *user2* , но оказывается, что такая задача уже существует в базе данных, то зачем создавать дубликат. Та же логика может быть применена к `unfollowing` .

Метод `is_following()` формирует запрос на проверку отношения, существует ли связь между двумя пользователями. Раньше я уже использовал метод `filter_by()` запроса SQLAlchemy, например, чтобы найти пользователя по его *username* . Метод `filter()` , который я использую здесь, аналогичен, но является более низкоуровневым, поскольку он может включать произвольные условия фильтрации, в отличие от `filter_by()` , который может только проверять равенство на постоянное значение. Условие, которое я использую в `is_following()` , ищет элементы в таблице ассоциаций, которые имеют внешний ключ левой стороны, установленный для `self` пользователя, а правая сторона --- для аргумента `user` . Запрос завершается методом `count()` , который возвращает количество записей. Результатом этого запроса будет `0` или `1` , поэтому проверка того, что счетчик равен 1 или больше 0, фактически эквивалентен. Другие терминаторы запросов, которые вы видели в прошлом, --- это `all()` и `first()` .

### Получение сообщений от Followed Users

Поддержка подписчиков в базе данных почти завершена, но на самом деле у меня отсутствует одна важная функция. На странице *index* приложения я собираюсь показать записи в блогах, написанные всеми людьми, за которыми следит зарегистрированный пользователь, поэтому мне нужно сформировать запрос базы данных, который вернет эти сообщения.

Наиболее очевидным решением является запуск запроса, который вернет список followed пользователей, который, как вы уже знаете, будет `user.followed.all()` . Затем для каждого из этих пользователей я могу запустить запрос для получения их сообщений. Когда у меня будут все сообщения, я могу объединить их в один список и отсортировать их по дате. Звучит хорошо? Ну не совсем.

У этого подхода есть несколько проблем. Что произойдет, если подписка пользователя будет насчитывать тысячи людей? Мне нужно выполнить тысячи запросов базы данных, чтобы собрать все сообщения. И тогда мне нужно будет объединить и отсортировать тысячи списков в памяти. В качестве вторичной проблемы учесть, что домашняя страница приложения в конечном итоге будет выполняться с *разбивкой* по страницам, поэтому она не отобразит все доступные сообщения, а только первые несколько, со ссылкой, чтобы получить больше, если потребуется. Если я собираюсь отображать сообщения, отсортированные по их дате, как я могу узнать, какие сообщения являются последними из всех отслеживаемых (followed) пользователей, если только я не получу все сообщения и не сортирую их в первую очередь? Это действительно жуткое решение, которое плохо масштабируется.

Нет никакого способа избежать этого объединения и сортировки сообщений в блогах, но выполнение *ЭТОГОТАКОГО* в приложении приводит к очень неэффективному процессу. Такая работа --- это то, чем отличаются реляционные базы данных. База данных имеет индексы, которые позволяют ей выполнять запросы и сортировку гораздо более эффективным способом. Так что я действительно хочу создать единый запрос базы данных, который определяет информацию, которую я хочу получить, а затем дать базе данных понять, как извлечь эту информацию наиболее эффективным способом.

Вот этот запрос:

    class User(db.Model):
        #...
        def followed_posts(self):
            return Post.query.join(
                followers, (followers.c.followed_id == Post.user_id)).filter(
                    followers.c.follower_id == self.id).order_by(
                        Post.timestamp.desc())

Это, пожалуй, самый сложный запрос, который я использовал в этом приложении. Я попытаюсь расшифровать этот запрос за один раз. Если вы посмотрите на структуру этого запроса, вы заметите, что существуют три основных раздела, разработанные методами `join()` , `filter()` и `order_by()` объекта запроса SQLAlchemy:

    Post.query.join(...).filter(...).order_by(...)

#### операции объединения --- Joins

Чтобы понять, что делает операция объединения, давайте рассмотрим пример. Предположим, что у меня есть таблица User со следующим содержимым:

![](https://habrastorage.org/webt/8q/qj/oj/8qqjoja7fzaij0ukyghjenay2ck.png)

Для простоты, я не показываю все поля в пользовательской модели, а только те, которые важны для этого запроса.

Предположим, что таблица ассоциаций `followers` говорит, что пользователь `john` следит за пользователями `susan` и `david` , пользователь `susan` следит за `mary` , а пользователь `mary` следит за `david` . Данные, которые представляют собой выше, таковы:

![](https://habrastorage.org/webt/dw/1z/fk/dw1zfkmrzwtdv0owu6ywbui6atw.png)

В итоге, таблица `posts` возвращает по одному сообщению от каждого пользователя:

Вот вызов `join()` , который я определил для этого запроса еще раз:

`Post.query.join(followers, (followers.c.followed_id == Post.user_id))`

Я вызываю операцию *join* в таблице *posts* . Первый аргумент --- таблица ассоциаций подписчиков, а второй аргумент --- условие объединения. То, что я формирую с этим вызовом, заключается в том, что я хочу, чтобы база данных создавала временную таблицу, которая объединяет данные из таблиц posts и подписчиков. Данные будут объединены в соответствии с условием, которое я передал в качестве аргумента.

Условие, которое я использовал, говорит, что поле `followed_id` таблицы последователей должно быть равно `user_id` таблицы *posts* . Чтобы выполнить это слияние, база данных берет каждую запись из таблицы сообщений (левая часть соединения) и добавляет любые записи из таблицы `followers` (правая сторона соединения), которые соответствуют условию. Если несколько записей в `followers` соответствуют условию, то запись будет повторяться для каждого. Если для данного сообщения в followers нет совпадений, то эта запись не является частью join.

Результат операции объединения:

![](https://habrastorage.org/webt/gn/fe/e7/gnfee7xrm0kofw9nnqbz4qdfa6o.png)

Обратите внимание, что во всех случаях столбцы `user_id` и `followed_id` равны, так как это условие соединения. Сообщение от пользователя john не отображается в объединенной таблице, потому что нет записей в подписках, у которых есть john в качестве интересного пользователя, или, другими словами, никто не отслеживает сообщения john. А вот записи касательно david появляются дважды, потому что за этим пользователем следят два разных пользователя.

Не совсем сразу понятно, что я получу, выполнив этот запрос, но продолжаю, так как это всего лишь одна часть большего запроса.

### фильтры

Операция join дала мне список всех сообщений, за которыми следит какой-то пользователь, и это объем данных превышающий, тот который я действительно хочу. Меня интересует только подмножество этого списка, сообщения, за которыми следит только один пользователь, поэтому мне нужно обрезать все записи, которые мне не нужны и я могу сделать это вызовом `filter()` .

Вот часть фильтра запроса:

    filter(followers.c.follower_id == self.id)

Поскольку этот запрос находится в методе класса `User` , выражение `self.id` относится к идентификатору user интересующего вас пользователя. Вызов `filter()` выбирает элементы в объединенной таблице, для которых столбец `follower_id` указывает на этого пользователя, который, другими словами, означает, что я сохраняю только записи, в которых этот пользователь является подписчиком.

Предположим, что меня интересует пользователь `john` , у которого его поле `id` установлено равным `1` . Вот как выглядит результат запроса после фильтрации:

![](https://habrastorage.org/webt/_y/fu/az/_yfuaza6yfzgy26mokohm23jt1e.png)

И это именно те посты, которые я хотел увидеть!

Помните, что запрос был направлен для класса Post, поэтому, несмотря на то, что я получил временную таблицу, созданную базой данных как часть этого запроса, результатом будут записи, включенные в эту временную таблицу, без дополнительных столбцов, добавленных операцией join.

#### Сортировка

Последним этапом является сортировка результатов. Часть запроса, которая гласит:

    order_by(Post.timestamp.desc())

Здесь я говорю, что хочу, чтобы результаты отсортировались по полю timestamp сообщения в порядке убывания. При таком условии первым результатом будет самый последний пост в блоге.

### Объединение собственных сообщений и сообщений на которые подписан

Запрос, который я продемонстрировал в функции `followed_posts ()` , чрезвычайно полезен, но имеет одно ограничение. Люди ожидают увидеть свои собственные сообщения, в их хронологии совместно с подписанными, но не тут то было. Запрос не имеет такой возможности.

Существует два возможных способа расширить этот запрос, включив собственные записи пользователя. Самый простой способ --- оставить запрос таким, какой он есть, но убедиться, что все пользователи следят за собой. Если вы являетесь вашим собственным подписчиком, тогда запрос, как показано выше, найдет ваши собственные сообщения вместе с запросами всех кто вас интересует. Недостатком этого метода является то, что он влияет на статистику относительно подписчиков. Все счетчики будут увеличены на единицу, поэтому их нужно будет скорректировать, до того как они будут отображены. Второй способ сделать это --- создать второй запрос, который возвращает собственные сообщения пользователя, а затем использовать оператор union, чтобы объединить два запроса в один.

Рассмотрев оба варианта, я решил пойти вторым путем. Ниже вы можете увидеть функцию `follow_posts()` после того, как она была расширена, чтобы включить сообщения пользователя через объединение:

    def followed_posts(self):
        followed = Post.query.join(
            followers, (followers.c.followed_id == Post.user_id)).filter(
                followers.c.follower_id == self.id)
        own = Post.query.filter_by(user_id=self.id)
        return followed.union(own).order_by(Post.timestamp.desc())

Обратите внимание, как `followed` и `собственные` запросы объединяются в один, до сортировки.

### UnitTest для User Model

Хотя я не рассматриваю имплементацию подписчиков, я создал «сложную» функцию, и думаю, что она также не тривиальна. Моя проблема, когда я пишу нетривиальный код, заключается в том, чтобы этот код продолжал работать в будущем, поскольку я вношу изменения в разные части приложения. Лучший способ гарантировать, что код, который вы уже написали, продолжает работать в будущем, --- это создать набор автоматических тестов, которые вы можете повторно запускать каждый раз, когда будут сделаны изменения.

Python включает очень полезный пакет `unittest` , который упрощает запись и выполнение модульных тестов. Давайте напишем некоторые модульные тесты для существующих методов в классе `User` в модуле *tests.py* :

    from datetime import datetime, timedelta
    import unittest
    from app import app, db
    from app.models import User, Post

    class UserModelCase(unittest.TestCase):
        def setUp(self):
            app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite://'
            db.create_all()

        def tearDown(self):
            db.session.remove()
            db.drop_all()

        def test_password_hashing(self):
            u = User(username='susan')
            u.set_password('cat')
            self.assertFalse(u.check_password('dog'))
            self.assertTrue(u.check_password('cat'))

        def test_avatar(self):
            u = User(username='john', email='john@example.com')
            self.assertEqual(u.avatar(128), ('https://www.gravatar.com/avatar/'
                                             'd4c74594d841139328695756648b6bd6'
                                             '?d=identicon&s=128'))

        def test_follow(self):
            u1 = User(username='john', email='john@example.com')
            u2 = User(username='susan', email='susan@example.com')
            db.session.add(u1)
            db.session.add(u2)
            db.session.commit()
            self.assertEqual(u1.followed.all(), [])
            self.assertEqual(u1.followers.all(), [])

            u1.follow(u2)
            db.session.commit()
            self.assertTrue(u1.is_following(u2))
            self.assertEqual(u1.followed.count(), 1)
            self.assertEqual(u1.followed.first().username, 'susan')
            self.assertEqual(u2.followers.count(), 1)
            self.assertEqual(u2.followers.first().username, 'john')

            u1.unfollow(u2)
            db.session.commit()
            self.assertFalse(u1.is_following(u2))
            self.assertEqual(u1.followed.count(), 0)
            self.assertEqual(u2.followers.count(), 0)

        def test_follow_posts(self):
            # create four users
            u1 = User(username='john', email='john@example.com')
            u2 = User(username='susan', email='susan@example.com')
            u3 = User(username='mary', email='mary@example.com')
            u4 = User(username='david', email='david@example.com')
            db.session.add_all([u1, u2, u3, u4])

            # create four posts
            now = datetime.utcnow()
            p1 = Post(body="post from john", author=u1,
                      timestamp=now + timedelta(seconds=1))
            p2 = Post(body="post from susan", author=u2,
                      timestamp=now + timedelta(seconds=4))
            p3 = Post(body="post from mary", author=u3,
                      timestamp=now + timedelta(seconds=3))
            p4 = Post(body="post from david", author=u4,
                      timestamp=now + timedelta(seconds=2))
            db.session.add_all([p1, p2, p3, p4])
            db.session.commit()

            # setup the followers
            u1.follow(u2)  # john follows susan
            u1.follow(u4)  # john follows david
            u2.follow(u3)  # susan follows mary
            u3.follow(u4)  # mary follows david
            db.session.commit()

            # check the followed posts of each user
            f1 = u1.followed_posts().all()
            f2 = u2.followed_posts().all()
            f3 = u3.followed_posts().all()
            f4 = u4.followed_posts().all()
            self.assertEqual(f1, [p2, p4, p1])
            self.assertEqual(f2, [p2, p3])
            self.assertEqual(f3, [p3, p4])
            self.assertEqual(f4, [p4])

    if __name__ == '__main__':
        unittest.main(verbosity=2)

Я добавил четыре теста, которые используют хэширование пароля, пользовательский аватар и функции последователей в пользовательской модели. Методы `setUp()` и `tearDown()` --- это специальные методы, которые инфраструктура модульного тестирования выполняет до и после каждого теста соответственно. Я реализовал небольшой хак в `setUp()` , чтобы предотвратить использование модульных тестов в обычной базе данных, которую я использую для разработки. Изменив конфигурацию приложения на `sqlite://` я направляю SQLAlchemy для использования базы данных SQLite в памяти во время тестов. Вызов `db.create_all()` создает все таблицы базы данных. Это быстрый способ создания базы данных с нуля, которая полезна для тестирования. Для разработки и производства я уже показал вам, как создавать таблицы базы данных через миграции баз данных.

Вы можете запустить весь набор тестов с помощью следующей команды:

    (venv) $ python tests.py
    test_avatar (__main__.UserModelCase) ... ok
    test_follow (__main__.UserModelCase) ... ok
    test_follow_posts (__main__.UserModelCase) ... ok
    test_password_hashing (__main__.UserModelCase) ... ok

    ----------------------------------------------------------------------
    Ran 4 tests in 0.494s

    OK

С этого момента каждый раз, когда в приложение вносятся изменения, вы можете повторно запустить тесты, чтобы убедиться, что тестируемые функции не были испорчены. Кроме того, каждый раз, когда к приложению добавляется еще одна функция, для нее следует записать тест.

### Интеграция подписчиков с помощью приложения

Поддержка подписчиков в базе данных и моделях завершена, но у меня нет ни одной из этих функций, включенных в приложение, поэтому я собираюсь добавить это сейчас. Хорошо то, что в этом нет больших проблем, все это основано на тех концепциях, которые вы уже узнали.

Давайте добавим два новых маршрута в приложение, чтобы создавать и отменить подписку на пользователя:

    @app.route('/follow/<username>')
    @login_required
    def follow(username):
        user = User.query.filter_by(username=username).first()
        if user is None:
            flash('User {} not found.'.format(username))
            return redirect(url_for('index'))
        if user == current_user:
            flash('You cannot follow yourself!')
            return redirect(url_for('user', username=username))
        current_user.follow(user)
        db.session.commit()
        flash('You are following {}!'.format(username))
        return redirect(url_for('user', username=username))

    @app.route('/unfollow/<username>')
    @login_required
    def unfollow(username):
        user = User.query.filter_by(username=username).first()
        if user is None:
            flash('User {} not found.'.format(username))
            return redirect(url_for('index'))
        if user == current_user:
            flash('You cannot unfollow yourself!')
            return redirect(url_for('user', username=username))
        current_user.unfollow(user)
        db.session.commit()
        flash('You are not following {}.'.format(username))
        return redirect(url_for('user', username=username))

Вроде бы все понятно, но обратите внимание на все проверки ошибок, что я делаю, чтобы предотвратить непредвиденные проблемы и попытаться выдать полезное сообщение для пользователя, когда возникнет проблема.

Теперь, когда функции View находятся на месте, я могу связать их со страницами приложения. Я собираюсь добавить ссылки для создания и отмены подписки на странице профиля каждого пользователя:

        ...
        <h1>User: {{ user.username }}</h1>
        {% if user.about_me %}<p>{{ user.about_me }}</p>{% endif %}
        {% if user.last_seen %}<p>Last seen on: {{ user.last_seen }}</p>{% endif %}
        <p>{{ user.followers.count() }} followers, {{ user.followed.count() }} following.</p>
        {% if user == current_user %}
        <p><a href="{{ url_for('edit_profile') }}">Edit your profile</a></p>
        {% elif not current_user.is_following(user) %}
        <p><a href="{{ url_for('follow', username=user.username) }}">Follow</a></p>
        {% else %}
        <p><a href="{{ url_for('unfollow', username=user.username) }}">Unfollow</a></p>
        {% endif %}
        ...

Изменения, внесенные в шаблон профиля пользователя, добавляют строку ниже последней отметки времени просмотра, показывающую количество подписчиков этого пользователя. И линия, которая имеет ссылку \"Редактировать\" (Edit), когда вы просматриваете свой собственный профиль теперь может иметь одну из трех возможных ссылок:

-   Если пользователь просматривает свой профиль, ссылка \"Edit\" отображается, как раньше.

![](https://habrastorage.org/webt/6w/dd/ys/6wddyssufd_9m6la_59t2zomxjm.png)

-   Если пользователь просматривает пользователя, который в настоящее время не в подписке, ссылка \"Follow\".

![](https://habrastorage.org/webt/sw/fh/jy/swfhjysyo0twjtaqpizdaaiofb0.png)

-   Если пользователь просматривает пользователя, который в настоящее время есть в подписке, ссылка \"Unfollow\".

![](https://habrastorage.org/webt/z8/2p/aq/z82paqnsxc7x0uwzs8pt9c13m-o.png)

На этом этапе вы можете запустить приложение, создать несколько пользователей и поиграться с подписчиками и свободными от подписок пользователями. Единственное, что вам нужно сделать, это ввести URL страницы профиля пользователя, которому вы хотите добавиться в подписчики или избавиться от подписки, так как в настоящее время нет способа увидеть список пользователей. Например, если вы хотите следить за пользователем с именем пользователя `susan` , вам нужно будет ввести <http://localhost:5000/user/susan> в адресной строке браузера, чтобы получить доступ к странице профиля для этого пользователя. Проверьте, как изменяется количество пользователей в подписке, по мере того, как вы выходите или подписываетесь или отказываетесь от подписки.

Я должен показывать список cообщений из подписки на index странице приложения, но у меня нет реализации всех частей, чтобы сделать это, так как пользователи пока не могут писать сообщения в блоге. Поэтому я собираюсь отложить это изменение до тех пор, пока эта функциональность не будет там где ей положено.
:::

Глава 9: Разбивка на страницы
-----------------------------

::: {#post-content-body .post__text .post__text-html io-article-url="https://habr.com/ru/post/347926/"}
### Представление сообщений в блогах

Начнем с чего-то простого. Домашняя страница должна иметь форму, в которой пользователи могут вводить новые сообщения. Сначала я создаю класс формы:

    class PostForm(FlaskForm):
        post = TextAreaField('Say something', validators=[
            DataRequired(), Length(min=1, max=140)])
        submit = SubmitField('Submit')

Теперь можно добавить эту форму в шаблон для главной страницы приложения:

    {% extends "base.html" %}

    {% block content %}
        <h1>Hi, {{ current_user.username }}!</h1>
        <form action="" method="post">
            {{ form.hidden_tag() }}
            <p>
                {{ form.post.label }}<br>
                {{ form.post(cols=32, rows=4) }}<br>
                {% for error in form.post.errors %}
                <span style="color: red;">[{{ error }}]</span>
                {% endfor %}
            </p>
            <p>{{ form.submit() }}</p>
        </form>
        {% for post in posts %}
        <p>
        {{ post.author.username }} says: <b>{{ post.body }}</b>
        </p>
        {% endfor %}
    {% endblock %}

Изменения в этом шаблоне аналогичны тем, что были сделаны в других формах. В заключение --- следует добавить создание формы и обработку в функции просмотра:

    from app.forms import PostForm
    from app.models import Post

    @app.route('/', methods=['GET', 'POST'])
    @app.route('/index', methods=['GET', 'POST'])
    @login_required
    def index():
        form = PostForm()
        if form.validate_on_submit():
            post = Post(body=form.post.data, author=current_user)
            db.session.add(post)
            db.session.commit()
            flash('Your post is now live!')
            return redirect(url_for('index'))
        posts = [
            {
                'author': {'username': 'John'},
                'body': 'Beautiful day in Portland!'
            },
            {
                'author': {'username': 'Susan'},
                'body': 'The Avengers movie was so cool!'
            }
        ]
        return render_template("index.html", title='Home Page', form=form,
                               posts=posts)

Давайте разберем изменения в этой функции просмотра по порядку:

-   Добавился новый импорт: классы `Post` и `PostForm`
-   `POST` -запросы в обоих маршрутах, связанных с функцией просмотра страницы `index` , в дополнение к запросам `GET` , так как эта функция просмотра теперь получает данные формы.
-   Логика обработки формы добавляет новую запись `Post` в базу данных.
-   Шаблон получает объект `form` как дополнительный аргумент, так что он может отображать текстовое поле.

Прежде чем продолжить, я хотел бы обратить внимание на ряд важных моментов, связанных с обработкой веб-форм. Обратите внимание, что после обработки данных формы я завершаю запрос, отправив *redirect* на главную страницу *index* . Я мог бы легко пропустить переадресацию и позволить функции продолжать работать в части *template rendering* , так как это уже функция просмотра *index* .

Итак, зачем redirect?

![](https://habrastorage.org/webt/cb/ud/7x/cbud7xj8sm4rpctv9qprulhyqjg.png)

Стандартная практика --- отвечать [( *response* ) на ( *request* )](https://youtu.be/DjVB2P15iUo) запроса `POST` , созданного при отправке веб-формы с переадресацией. Это поможет как то избежать приступов раздражения при использовании команды обновления в веб-браузерах. Ведь когда вы нажимаете кнопку обновить, веб-браузер, выдаст последний запрос. Если запрос `POST` с представлением формы возвращает регулярный ответ, то обновление будет повторно отправлять форму. Поскольку это всегда неожиданно, браузер попросит пользователя подтвердить повторную отправку, но большинство пользователей не поймут, что надо браузеру.

Но если на запрос `POST` отвечает перенаправление, браузер получит указание отправить запрос `GET` , чтобы захватить страницу, указанную в перенаправлении, поэтому теперь последний запрос больше не является POST-запросом, а команда обновления работает более предсказуемым образом.

Этот простой трюк не что иное, как паттерн [Post/Redirect/Get.](https://en.wikipedia.org/wiki/Post/Redirect/Get) . Он избегает вставки повторяющихся сообщений, когда пользователь непреднамеренно обновляет страницу после отправки веб-формы.

### Просмотр сообщений в блогах

Если вы помните, я создал пару сообщений в блогах, которые я долгое время показывал на домашней странице. Эти поддельные объекты создаются явно в функции просмотра *index* в виде простого списка Python:

    posts = [
        { 
            'author': {'username': 'John'}, 
            'body': 'Beautiful day in Portland!' 
        },
        { 
            'author': {'username': 'Susan'}, 
            'body': 'The Avengers movie was so cool!' 
        }
    ]

Но теперь у меня есть метод `followed_posts()` в модели `User` , который возвращает сообщения, которые данный пользователь хотел бы увидеть. Итак, теперь я могу заменить временные сообщения реальными:

    @app.route('/', methods=['GET', 'POST'])
    @app.route('/index', methods=['GET', 'POST'])
    @login_required
    def index():
        # ...
        posts = current_user.followed_posts().all()
        return render_template("index.html", title='Home Page', form=form,
                               posts=posts)

Метод `followed_posts` класса `User` возвращает объект запроса *SQLAlchemy* , который настроен на захват сообщений, на которые подписан пользователь из базы данных. Вызов `all()` по этому запросу запускает его выполнение, а возвращаемое значение представляет собой список со всеми результатами.

Таким образом, я получаю структуру, которая очень похожа на ту, что формировала временные сообщения, которые я использовал до сих пор. Это настолько похоже, что шаблон даже не нужно менять.

### Облегчить поиск пользователей

Надеюсь что, вы заметили, то как приложение работает на данный момент, не совсем удобно использовать, позволяя пользователям находить других пользователей. Фактически, на самом деле нет способа увидеть, что другие пользователи там есть вообще. Я собираюсь исправить это с помощью нескольких простых изменений.

Надо бы создать новую страницу, которую я собираюсь назвать страницей «Explore». Эта страница будет работать как домашняя страница, но вместо того, чтобы показывать только сообщения от следующих пользователей, она будет показывать глобальный поток сообщений от всех пользователей. Вот новая функция просмотра:

    @app.route('/explore')
    @login_required
    def explore():
        posts = Post.query.order_by(Post.timestamp.desc()).all()
        return render_template('index.html', title='Explore', posts=posts)

Вы заметили что-то странное в этой функции? Вызов `render_template()` ссылается на шаблон *index.html* , который я использую на главной странице приложения. Поскольку эта страница будет очень похожа на главную страницу, я решил повторно использовать шаблон.

Но одно отличие от главной страницы заключается в том, что на странице «Explore» я не хочу иметь форму для записи сообщений в блоге, поэтому в этой функции просмотра я **не** включил аргумент `form` в вызов шаблона.

Чтобы предотвратить сбой шаблона *index.html* , при попытке отобразить веб-форму, которой не существует, я добавлю условие, которое отображает форму, только если она определена:

    {% extends "base.html" %}

    {% block content %}
        <h1>Hi, {{ current_user.username }}!</h1>
        {% if form %}
        <form action="" method="post">
            ...
        </form>
        {% endif %}
        ...
    {% endblock %}

Я также добавлю ссылку на эту новую страницу в панели навигации:

    <a href="{{ url_for('explore') }}">Explore</a>

Помните подшаблон *`_post.html`* , в [главе 6](https://habrahabr.ru/post/346348/) , чтобы отображать сообщения в блоге на странице профиля пользователя? Это небольшой шаблон, который был извлечен из шаблона страницы профиля пользователя и стал отдельным, чтобы его можно было использовать и из других шаблонов. Я сейчас сделаю небольшое улучшение, которое позволит показать имя пользователя сообщения в блоге как ссылку:

    <table>
        <tr valign="top">
            <td><img src="{{ post.author.avatar(36) }}"></td>
            <td>
                <a href="{{ url_for('user', username=post.author.username) }}">
                    {{ post.author.username }}
                </a>
                says:<br>{{ post.body }}
            </td>
        </tr>
    </table>

Теперь я могу использовать этот суб-шаблон для визуализации и изучения блога на домашней странице:

    ...
    {% for post in posts %}
        {% include '_post.html' %}
    {% endfor %}
    ...

Вложенный шаблон ожидает, что переменная с именем `post` будет существовать, и именно так будет называться переменная цикла в шаблоне index, так что это нормально работает.

Благодаря этим небольшим изменениям, удобство использования приложения значительно улучшилось. Теперь пользователь может посетить страницу читать сообщения в блоге от неизвестных пользователей и на основе этих сообщений найти новых, чтобы добавить подписку, что очень просто сделать, нажав на имя пользователя для доступа к странице профиля. Удивительно, правда?

На этом этапе я предлагаю вам попробовать приложение еще раз, так что бы вы сами испытали эти последние улучшения пользовательского интерфейса.

![](https://habrastorage.org/webt/bp/rw/qd/bprwqdj3eh5me3baxsrgtsruqis.png)

### Деление записей в блогах

Приложение выглядит лучше, чем было, но отображение всех записей на домашней странице станет проблемой гораздо раньше, чем можно себе представить. Что произойдет, если у пользователя есть тысяча записей? Или миллион? Управление таким большим списком сообщений будет крайне медленным и неэффективным.

Чтобы решить эту проблему, я собираюсь разбить список сообщений. Это означает, что изначально я буду показывать только ограниченное количество сообщений одновременно и включать ссылки для навигации по всему остальному списку сообщений. Flask-SQLAlchemy поддерживает разбиение на страницы изначально методом запроса `paginate()` . Если, например, мне надо получить первые двадцать записей пользователя, я могу заменить вызов `all()` в конце запроса:

    >>> user.followed_posts().paginate(1, 20, False).items

Метод `paginate` можно вызвать для любого объекта запроса из Flask-SQLAlchemy. Это требует трех аргументов:

-   номер страницы, начиная с 1
-   количество элементов на странице
-   флаг ошибки. Если `True` , когда запрашивается страница вне диапазона, 404 ошибка будет автоматически возвращена клиенту. Если `False` , пустой список будет возвращен для страниц вне диапазона.

Возвращаемое значение из `paginate` --- объект `Pagination` . Атрибут `items` этого объекта содержит список элементов на запрошенной странице. В объекте Pagination есть еще полезные вещи, о которых я расскажу позже.

Теперь давайте подумаем о том, как можно было бы реализовать разбиение на страницы в функции просмотра `index()` . Можно начать с добавления в приложение элемента конфигурации, определяющего, сколько элементов будет отображаться на странице.

    class Config(object):
        # ...
        POSTS_PER_PAGE = 3

Это хорошая идея, чтобы эти «knobs» для всего приложения могли влиять на его поведение из файла конфигурации, потому что тогда я могу все корректировки вносить в одном месте. В итоге я, конечно, буду использовать большее количество, чем три элемента на странице, но для тестирования полезно работать с небольшими числами.

Далее, мне нужно решить, каким образом номер страницы будет включен в URL-адреса приложений. Достаточно распространенным способом является использование аргумента *query string* для указания необязательного номера страницы, по умолчанию на стр. 1, если он не указан. Вот несколько примеров URL-адресов, которые показывают, как я буду реализовывать это:

-   Page 1, implicit: *<http://localhost:5000/index>*
-   Page 1, explicit: *<http://localhost:5000/index?page=1>*
-   Page 3: *<http://localhost:5000/index?page=3>*

Чтобы получить доступ к аргументам, указанным в строке запроса, я могу использовать объект `request.args` объекта Flask. Вы уже видели это в [главе 5](https://habrahabr.ru/post/346346/) , где я внедрил URL-адреса для входа пользователя из Flask-Login, которые могут включать аргумент строки запроса.

Следующий пример демонстрирует, как я добавил разбивку домашней страницы на несколько и исследовать функции просмотра:

    @app.route('/', methods=['GET', 'POST'])
    @app.route('/index', methods=['GET', 'POST'])
    @login_required
    def index():
        # ...
        page = request.args.get('page', 1, type=int)
        posts = current_user.followed_posts().paginate(
            page, app.config['POSTS_PER_PAGE'], False)
        return render_template('index.html', title='Home', form=form,
                               posts=posts.items)

    @app.route('/explore')
    @login_required
    def explore():
        page = request.args.get('page', 1, type=int)
        posts = Post.query.order_by(Post.timestamp.desc()).paginate(
            page, app.config['POSTS_PER_PAGE'], False)
        return render_template("index.html", title='Explore', posts=posts.items)

В этих изменениях два оба маршрута определяют номер страницы для отображения, либо из аргумента `page` запроса страницы, либо по умолчанию это 1. Затем используется метод `paginate()` для извлечения только нужной страницы с результатами. Элемент конфигурации `POSTS_PER_PAGE` , который определяет размер страницы, доступен через объект `app.config` .

Обратите внимание, насколько легки эти изменения, и как мало влияют на каждый кусок кода. Я пытаюсь написать каждую часть, абстрагируясь от работы других части, и это позволяет мне писать модульные и надежные приложения, которые легче расширить и протестировать. При этом вероятность получить фатал или мелкую ошибку существенно мала.

Двигаем дальше! И вам следует испытать функциональность разбивки на страницы. Предварительно убедитесь, что у вас более трех сообщений в блоге. Это легче увидеть на странице поиска (explore page), где отображаются сообщения от всех пользователей. Теперь вам видны только три последних сообщения. Если вы хотите увидеть следующие три, введите `http://localhost:5000/explore?page=2` в адресной строке браузера.

### Навигация по страницам

Следующее изменение заключается в добавлении ссылок в нижней части списка сообщений блога, которые позволяют пользователям перейти на следующую и/или предыдущие страницы. Помните, что я упомянул, что возвращаемое значение из вызова `paginate()` является объектом класса Pagination из Flask-SQLAlchemy? До сих пор я использовал атрибут *items* этого объекта, который содержит список элементов, полученных для выбранной страницы. Но у этого объекта есть несколько других атрибутов, которые полезны при создании ссылок на страницы:

-   has\_next: True, если после текущей есть хотя бы одна страница
-   has\_prev: True, если есть еще одна страница перед текущей
-   next\_num: номер страницы для следующей страницы
-   prev\_num: номер страницы для предыдущей страницы

С помощью этих четырех элементов я могу создать ссылки на страницы (следующие и предыдущие) и передать их шаблонам для отображения:

    @app.route('/', methods=['GET', 'POST'])
    @app.route('/index', methods=['GET', 'POST'])
    @login_required
    def index():
        # ...
        page = request.args.get('page', 1, type=int)
        posts = current_user.followed_posts().paginate(
            page, app.config['POSTS_PER_PAGE'], False)
        next_url = url_for('index', page=posts.next_num) \
            if posts.has_next else None
        prev_url = url_for('index', page=posts.prev_num) \
            if posts.has_prev else None
        return render_template('index.html', title='Home', form=form,
                               posts=posts.items, next_url=next_url,
                               prev_url=prev_url)

     @app.route('/explore')
     @login_required
     def explore():
        page = request.args.get('page', 1, type=int)
        posts = Post.query.order_by(Post.timestamp.desc()).paginate(
            page, app.config['POSTS_PER_PAGE'], False)
        next_url = url_for('explore', page=posts.next_num) \
            if posts.has_next else None
        prev_url = url_for('explore', page=posts.prev_num) \
            if posts.has_prev else None
        return render_template("index.html", title='Explore', posts=posts.items,
                              next_url=next_url, prev_url=prev_url)

В `next_url` и `prev_url` в этих двух функциях будет примене URL-адрес, возвращаемый `url_for()` , только если есть страница в этом направлении. Если текущая страница находится на одном из концов коллекции сообщений, атрибуты `has_next` или `has_prev` объекта `Pagination` будут `False` , и в этом случае ссылка в этом направлении будет установлена ​​на `None` .

Один интересный аспект функции `url_for()` , о котором я умолчал ранее, заключается в том, что вы можете добавить к нему любые аргументы ключевого слова, и если имена этих аргументов напрямую не указаны в URL-адресе, тогда Flask будет включать их в URL-адрес как аргументы запроса.

Связи со страницами устанавливаются в шаблоне *index.html* , поэтому теперь давайте отобразим их на странице, прямо под списком сообщений:

    ...
    {% for post in posts %}
        {% include '_post.html' %}
    {% endfor %}
    {% if prev_url %}
    <a href="{{ prev_url }}">Newer posts</a>
    {% endif %}
    {% if next_url %}
    <a href="{{ next_url }}">Older posts</a>
    {% endif %}
    ...

Это дополнение добавляет ссылку ниже списка сообщений как для главной страницы index, так и по исследуемым страницам. Первая ссылка помечена как «Новые сообщения» (\"Newer posts\"), и она указывает на предыдущую страницу (имейте в виду, что я показываю сообщения, отсортированные по последним данным, поэтому первая страница --- с новейшим контентом).

Вторая ссылка помечена как «Старые сообщения» (\"Older posts\") и указывает на следующую страницу сообщений.

Если какая-либо из этих двух ссылок --- `None` , то ссылка не будет показана на странице через условное выражение.

![](https://habrastorage.org/webt/3b/w3/zq/3bw3zqyb7q-jvr0p5reitn2oxjo.png)

### Разбиение страницы профиля пользователя

На данный момент изменений для страницы index достаточно. Тем не менее, на странице профиля пользователя также должен быть список сообщений, в котором отображаются только сообщения от владельца профиля. Чтобы быть последовательным, страницу профиля пользователя следует изменить аналогично странице index.

Я начинаю с обновления функции просмотра профиля пользователя, в которой по-прежнему имеется список временных сообщений.

    @app.route('/user/<username>')
    @login_required
    def user(username):
        user = User.query.filter_by(username=username).first_or_404()
        page = request.args.get('page', 1, type=int)
        posts = user.posts.order_by(Post.timestamp.desc()).paginate(
            page, app.config['POSTS_PER_PAGE'], False)
        next_url = url_for('user', username=user.username, page=posts.next_num) \
            if posts.has_next else None
        prev_url = url_for('user', username=user.username, page=posts.prev_num) \
            if posts.has_prev else None
        return render_template('user.html', user=user, posts=posts.items,
                               next_url=next_url, prev_url=prev_url)

Чтобы получить список сообщений от пользователя, я воспользуюсь тем, что отношение `user.posts` является запросом, который уже настроен SQLAlchemy в результате определения `db.relationship()` в модели User. Я возьму этот запрос и добавлю `order_by()` , чтобы сначала получить самые новые сообщения, а затем сделаю разбивку на страницы точно так же, как я сделал для сообщений в index и explore. Обратите внимание, что ссылки на страницы, которые генерируются функцией `url_for()` , нуждаются в дополнительном аргументе `username` , поскольку они указывают на страницу профиля пользователя, которая имеет это username в качестве динамического компонента URL-адреса.

В заключение, изменения в шаблоне *user.html* идентичны тем, которые я сделал на индексной странице:

    ...
    {% for post in posts %}
        {% include '_post.html' %}
    {% endfor %}
    {% if prev_url %}
    <a href="{{ prev_url }}">Newer posts</a>
    {% endif %}
    {% if next_url %}
    <a href="{{ next_url }}">Older posts</a>
    {% endif %}

После того, как вы закончите экспериментировать с функцией разбивки на страницы, вы можете установить для элемента конфигурации `POSTS_PER_PAGE` более разумное значение:

    class Config(object):
        # ...
        POSTS_PER_PAGE = 25
:::

Глава 10: Поддержка электронной почты
-------------------------------------

::: {#post-content-body .post__text .post__text-html io-article-url="https://habr.com/ru/post/348566/"}
### Введение в Flask-Mail

Что касается отправки электронной почты, то Flask имеет для этой цели расширение под названием [Flask-Mail](https://pythonhosted.org/Flask-Mail/) , которое поможет сделать эту задачу очень простой. Как всегда, оно (это расширение) устанавливается с помощью pip:

    (venv) $ pip install flask-mail

Ссылки на сброс пароля должны содержать в себе безопасный токен. Чтобы сгенерировать эти токены, я собираюсь использовать [JSON Web Tokens](https://jwt.io/) , который также имеет популярный пакет для Python:

    (venv) $ pip install pyjwt

Расширение Flask-Mail настроено из объекта `app.config` . Помните, когда в [главе 7](https://habrahabr.ru/post/346880/) я добавил конфигурацию электронной почты для отправки электронной почты всякий раз, когда произошла ошибка в производстве? Тогда я не сказал вам об этом, но мой выбор переменных конфигурации был смоделирован после требований Flask-Mail, поэтому нет необходимости в какой-либо дополнительной работе, переменные конфигурации уже находятся в приложении.

Как и для большинства расширений Flask, вам нужно создать экземпляр сразу после создания приложения Flask. В этом случае это объект класса `Mail` :

    # ...
    from flask_mail import Mail

    app = Flask(__name__)
    # ...
    mail = Mail(app)

> *Прим. переводчика:* Очень важно что бы строка `mail = Mail(app)` располагалась после `app.config.from_object(Config)` .

Для того, что бы протестировать отправку электронных писем, у вас есть те же два варианта, о которых я упоминал в [главе 7](https://habrahabr.ru/post/346880/) . Если вы хотите использовать эмулированный почтовый сервер, то Python предоставляет вариант для запуска во втором терминале с помощью следующей команды:

    (venv) $ python -m smtpd -n -c DebuggingServer localhost:8025

Чтобы настроить этот сервер, необходимо установить две переменные среды:

    (venv) $ export MAIL_SERVER=localhost
    (venv) $ export MAIL_PORT=8025

Если вы предпочитаете отправлять электронные письма \"по-взрослому\", вам необходимо использовать настоящий почтовый сервер. Если он у вас есть, вам просто нужно установить для него переменные среды `MAIL_SERVER` , `MAIL_PORT` , `MAIL_USE_TLS` , `MAIL_USERNAME` и `MAIL_PASSWORD` . Для особо ленивых, напоминаю, как использовать учетную запись *Gmail* для отправки электронной почты со следующими настройками:

    (venv) $ export MAIL_SERVER=smtp.googlemail.com
    (venv) $ export MAIL_PORT=587
    (venv) $ export MAIL_USE_TLS=1
    (venv) $ export MAIL_USERNAME=<your-gmail-username>
    (venv) $ export MAIL_PASSWORD=<your-gmail-password>

Если вы используете *Microsoft Windows* , вам необходимо заменить `export` на `set` в каждой из указанных выше `export` -ных инструкций.

Помните, что параметры безопасности вашей учетной записи Gmail могут препятствовать приложению отправлять электронную почту через нее, если вы явно не разрешаете «менее безопасным приложениям» доступ к вашей учетной записи Gmail. Вы можете прочитать об этом [здесь](https://support.google.com/accounts/answer/6010255?hl=en) , и если вас беспокоит безопасность вашей учетной записи, вы можете создать вторичную, которую вы настраиваете только для проверки электронных писем, или вы можете временно включить параметр разрешить доступ «менее безопасные приложениям» для запуска своих тестов, а затем вернуться назад к более безопасному по умолчанию.

### Использование Flask-Mail

Для демонстрации работы Flask-Mail, я покажу вам, как отправить электронное письмо из оболочки Python. Для этого запустите Python с flask shell, а затем выполните следующие команды:

    >>> from flask_mail import Message
    >>> from app import mail
    >>> msg = Message('test subject', sender=app.config['ADMINS'][0],
    ... recipients=['your-email@example.com'])
    >>> msg.body = 'text body'
    >>> msg.html = '<h1>HTML body</h1>'
    >>> mail.send(msg)

Фрагмент кода, приведенный выше, отправит электронное письмо на список адресов электронной почты, которые вы указали в аргументе `recipients` . В качестве отправителя (sender) я использую настройку администратора (я добавил переменную в конфиге `ADMINS` см.в [главе 7](https://habrahabr.ru/post/346880/) ). Письмо будет иметь простой текст в HTML-версии, поэтому в зависимости от того, как настроен ваш почтовый клиент, вы можете увидеть тот или иной вариант.

Короче, это довольно просто. Теперь давайте интегрируем электронные письма в приложение.

### Простой Email Framework

Начнем с написания вспомогательной функции, отправляющей электронное письмо. В общих чертах она повторяет собой упражнение flask shell из предыдущего раздела. Я положу эту функцию в новый модуль под названием `app/email.py` :

    from flask_mail import Message
    from app import mail

    def send_email(subject, sender, recipients, text_body, html_body):
        msg = Message(subject, sender=sender, recipients=recipients)
        msg.body = text_body
        msg.html = html_body
        mail.send(msg)

Flask-Mail поддерживает некоторые интересные функции, которые я здесь не использую. Такие как списки `Cc` и `Bcc` . Обязательно ознакомьтесь с [документацией Flask-Mail](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-x-email-support) , если вас заинтересовали эти параметры.

### Запрос сброса пароля

Напомню что, задача которую мы решаем, заключается в предоставлении пользователю возможности сбросить свой пароль. Для этого я собираюсь добавить ссылку на страницу входа:

    <p>
        Forgot Your Password?
        <a href="{{ url_for('reset_password_request') }}">Click to Reset It</a>
    </p>

Когда пользователь нажмет на ссылку *Click to Reset It* , появится новая веб-форма, которая запрашивает адрес электронной почты пользователя в качестве способа инициирования процесса сброса пароля. Вот класс формы:

    class ResetPasswordRequestForm(FlaskForm):
        email = StringField('Email', validators=[DataRequired(), Email()])
        submit = SubmitField('Request Password Reset')

И вот соответствующий HTML-шаблон:

    {% extends "base.html" %}

    {% block content %}
        <h1>Reset Password</h1>
        <form action="" method="post">
            {{ form.hidden_tag() }}
            <p>
                {{ form.email.label }}<br>
                {{ form.email(size=64) }}<br>
                {% for error in form.email.errors %}
                <span style="color: red;">[{{ error }}]</span>
                {% endfor %}
            </p>
            <p>{{ form.submit() }}</p>
        </form>
    {% endblock %}

Понадобится также view-функция для обработки этой формы:

    from app.forms import ResetPasswordRequestForm
    from app.email import send_password_reset_email

    @app.route('/reset_password_request', methods=['GET', 'POST'])
    def reset_password_request():
        if current_user.is_authenticated:
            return redirect(url_for('index'))
        form = ResetPasswordRequestForm()
        if form.validate_on_submit():
            user = User.query.filter_by(email=form.email.data).first()
            if user:
                send_password_reset_email(user)
            flash('Check your email for the instructions to reset your password')
            return redirect(url_for('login'))
        return render_template('reset_password_request.html',
                               title='Reset Password', form=form)

Это функция просмотра сильно смахивает на другие, которые обрабатывают форму. Стартуем с того, что пользователь не вошел в систему. Если пользователь вошел в систему, то нет смысла использовать функцию сброса пароля, а следует перенаправить вывод на страницу index.

Когда форма отправлена ​​и действительна, я ищу пользователя по электронной почте, предоставленной пользователем в форме. Если пользователь найден, отправлю электронное письмо с сбросом пароля. Для этого используется вспомогательная функцию `send_password_reset_email()` . Я покажу вам эту функцию ниже.

После отправки сообщения электронной почты я вывел сообщение, предлагающее пользователю проверить электронную почту в своем ящике, где он должен обнаружить послание с инструкциями и перенаправлением обратно на страницу входа в систему. Вы можете заметить, что это сообщение отображается в любом случае. Это значит, что клиенты не могут использовать эту форму, чтобы выяснить, зарегестрирован данный пользователь или нет.

### Токены сброса пароля

Прежде чем реализовать функцию `send_password_reset_email()` , мне нужно придумать способ создания ссылки на запрос пароля. Это будет ссылка, которая будет отправлена ​​пользователю по электронной почте. При щелчке по ссылке пользователю предоставляется страница, где может быть установлен новый пароль. Сложная часть этого плана --- убедиться, что для сброса пароля учетной записи можно использовать только действительные ссылки сброса.

Ссылки будут снабжены токеном, и этот токен будет проверен, прежде чем разрешить изменение пароля, в качестве доказательства того, что пользователь, который запросил электронное письмо, имеет доступ к адресу электронной почты в учетной записи. Очень популярным стандартом токена для этого типа процесса является JSON Web Token, или JWT. Самое приятное в JWT заключается в том, что они самодостаточны. Вы можете отправить токен пользователю по электронной почте, и когда пользователь нажмет на ссылку, которая возвращает токен обратно в приложение, его можно проверить самостоятельно.

Что бы разобраться как работают JWT? Ничего лучше не придумать, как испытать это в сеансе оболочки Python:

    >>> import jwt
    >>> token = jwt.encode({'a': 'b'}, 'my-secret', algorithm='HS256')
    >>> token
    b'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJhIjoiYiJ9.dvOo58OBDHiuSHD4uW88nfJikhYAXc_sfUHq1mDi4G0'
    >>> jwt.decode(token, 'my-secret', algorithms=['HS256'])
    {'a': 'b'}

Словарь `{'a': 'b'}` представляет собой пример полезной нагрузки, которая будет записана в токен. Чтобы сделать токен безопасным, необходимо предоставить секретный ключ для использования при создании криптографической подписи. В этом примере я использовал строку `my-secret` , но с приложением я собираюсь использовать `SECRET_KEY` из конфигурации. Аргумент `algorithm` указывает, как должен генерироваться токен. Наиболее широко используется алгоритм `HS256` .

Как видите, итоговый токен --- это длинная последовательность символов. Но не думайте, что это зашифрованный токен. Содержимое токена, включая полезную нагрузку, может быть легко декодировано любым пользователем (не верите мне? Скопируйте вышеуказанный токен, а затем введите его в [отладчик JWT](https://jwt.io/#debugger-io) , чтобы просмотреть его содержимое). Что делает маркер безопасным, так это то, что полезная нагрузка имеет подпись. Если кто-то пытался подделать или манипулировать полезной нагрузкой в ​​токене, тогда подпись будет признана недействительной, а для создания новой подписи необходим секретный ключ. Когда токен проверен, содержимое полезной нагрузки декодируется и возвращается обратно вызывающему абоненту. Если подпись токена была подтверждена, то полезной нагрузке можно доверять как аутентичной.

Полезная нагрузка, которую я буду использовать для токенов сброса пароля, будет иметь формат `{'reset_password': user_id, 'exp': token_expiration}` . Поле `exp` является стандартным для JWT, и если оно присутствует, то это указывает на время истечения срока действия токена. Если у токена есть действительная подпись, но она превысила отметку времени истечения срока действия, то такая подпись будет считаться недействительной. Для функции сброса пароля я собираюсь дать этим токенам 10 минут жизни.

Когда пользователь нажимает на ссылку в письме полученном по электронной почте, токен будет отправлен обратно в приложение как часть URL-адреса, и первым делом функция просмотра, обрабатывающая этот URL-адрес, будет проверять его. Если подпись действительна, то пользователь может быть идентифицирован идентификатором, хранящимся в полезной нагрузке. Далее, как только идентификация пользователя пройдет проверку, приложение может запросить новый пароль и установить его в учетной записи пользователя.

Поскольку эти токены принадлежат пользователям, я собираюсь написать функции генерации и проверки токена как методы в модели `User` :

    from time import time
    import jwt
    from app import app

    class User(UserMixin, db.Model):
        # ...

        def get_reset_password_token(self, expires_in=600):
            return jwt.encode(
                {'reset_password': self.id, 'exp': time() + expires_in},
                app.config['SECRET_KEY'], algorithm='HS256').decode('utf-8')

        @staticmethod
        def verify_reset_password_token(token):
            try:
                id = jwt.decode(token, app.config['SECRET_KEY'],
                                algorithms=['HS256'])['reset_password']
            except:
                return
            return User.query.get(id)

Функция `get_reset_password_token()` генерирует токен JWT в виде строки. Обратите внимание, что `decode('utf-8')` необходим, потому что функция `jwt.encode()` возвращает токен в виде последовательности байтов, но в приложении удобнее иметь токен в виде строки.

Функция проверки `verify_reset_password_token()` является статическим методом, что означает, что он может быть вызван непосредственно из класса. Статический метод похож на метод класса, с той лишь разницей, что статические методы не требуют создавать экземпляр класса. Если попроще, то отсутствует первый аргумент self. Этот метод принимает токен и пытается его декодировать, вызывая функцию `jwt.decode()` PyJWT. Если токен не может быть проверен или истек его срок, будет вызвано исключение, и в этом случае я перехвачу его, чтобы предотвратить последствия ошибки, а затем возвращу `None` . Если токен действителен, тогда значение ключа `reset_password` из полезной нагрузки токена является идентификатором пользователя, поэтому я могу загрузить пользователя и вернуть его на страницу.

### Отправка электронной почты для сброса пароля

Теперь, когда у меня есть токены, я могу сгенерировать электронные письма для сброса пароля. Функция `send_password_reset_email()` зависит от функции `send_email()` , которую я написал выше.

    from flask import render_template
    from app import app

    # ...

    def send_password_reset_email(user):
        token = user.get_reset_password_token()
        send_email('[Microblog] Reset Your Password',
                   sender=app.config['ADMINS'][0],
                   recipients=[user.email],
                   text_body=render_template('email/reset_password.txt',
                                             user=user, token=token),
                   html_body=render_template('email/reset_password.html',
                                             user=user, token=token))

Интересной частью этой функции является то, что текст и содержимое HTML для электронных писем генерируются из шаблонов с использованием знакомой функции `render_template()` . Шаблоны принимают пользователя и токен в качестве аргументов, так что может генерироваться персонализированное сообщение электронной почты. Вот текстовый шаблон для сброса пароля:

    Дорогой наш {{ user.username }},

    ты забыл пароль? И похоже, не впервый раз. Бывает!

    Чтобы сбросить пароль, жмакни на следующую ссылку:

    {{ url_for('reset_password', token=token, _external=True) }}

    Если ты не запрашивал сброс пароля, просто забей на это сообщение.

    С уважением,

    Команда Microblog

Или вот так, поприличней, в HTML-версии почти того же письма с более приличным текстом:

    <p>Уважаемый {{ user.username }},</p>
    <p>
        Чтобы сбросить пароль
        <a href="{{ url_for('reset_password', token=token, _external=True) }}">
            кликните по ссылке
        </a>.
    </p>
    <p>Кроме того, вы можете вставить следующую ссылку в адресную строку браузера:</p>
    <p>{{ url_for('reset_password', token=token, _external=True) }}</p>
    <p>Если вы не запрашивали сброс пароля, просто проигнорируйте это сообщение.</p>
    <p>С Уважением,</p>
    <p>Команда Microblog</p>

Обратите внимание, что маршрут `reset_password` , на который ссылается вызов `url_for()` в этих двух шаблонах электронной почты, еще не существует, он будет добавлен в следующем разделе.

### Сброс пароля пользователя

Когда пользователь нажимает на ссылку электронной почты, сработает второй маршрут, связанный с этой функцией. Вот функция просмотра запроса пароля:

    from app.forms import ResetPasswordForm

    @app.route('/reset_password/<token>', methods=['GET', 'POST'])
    def reset_password(token):
        if current_user.is_authenticated:
            return redirect(url_for('index'))
        user = User.verify_reset_password_token(token)
        if not user:
            return redirect(url_for('index'))
        form = ResetPasswordForm()
        if form.validate_on_submit():
            user.set_password(form.password.data)
            db.session.commit()
            flash('Your password has been reset.')
            return redirect(url_for('login'))
        return render_template('reset_password.html', form=form)

В этой функции просмотра я сначала удостоверяюсь, что пользователь не вошел в систему, а затем я определяю, кто пользователь, вызывая метод проверки токена в классе `User` . Этот метод возвращает пользователя, если токен действителен, или `None` , если нет. Если токен недействителен, я перенаправляюсь на домашнюю страницу *index* .

Если токен действителен, то я представляю пользователю вторую форму, в которой запрашивается новый пароль. Эта форма обрабатывается таким же образом, как и предыдущие формы, и в результате удачной отправки формы я вызываю метод `set_password()` класса `User` , чтобы изменить пароль, а затем перенаправить на страницу входа, где теперь пользователь может войти.

Вот класс `ResetPasswordForm` :

    class ResetPasswordForm(FlaskForm):
        password = PasswordField('Password', validators=[DataRequired()])
        password2 = PasswordField(
            'Repeat Password', validators=[DataRequired(), EqualTo('password')])
        submit = SubmitField('Request Password Reset')

А это соответствующий шаблон HTML:

    {% extends "base.html" %}

    {% block content %}
        <h1>Reset Your Password</h1>
        <form action="" method="post">
            {{ form.hidden_tag() }}
            <p>
                {{ form.password.label }}<br>
                {{ form.password(size=32) }}<br>
                {% for error in form.password.errors %}
                <span style="color: red;">[{{ error }}]</span>
                {% endfor %}
            </p>
            <p>
                {{ form.password2.label }}<br>
                {{ form.password2(size=32) }}<br>
                {% for error in form.password2.errors %}
                <span style="color: red;">[{{ error }}]</span>
                {% endfor %}
            </p>
            <p>{{ form.submit() }}</p>
        </form>
    {% endblock %}

Вот сейчас функция сброса пароля завершена. Давайте, попробуйте.

### Асинхронные сообщения

Если вы используете имитацию сервера электронной почты, который предоставляет Python, возможно, вы этого не заметили, но отправка электронной почты значительно замедляет приложение. Все взаимодействия, которые должны произойти при отправке электронной почты, делают задачу медленной, обычно требуется несколько секунд, чтобы получить электронную почту, и, возможно, больше, если сервер электронной почты адресата работает медленно или если есть несколько адресатов.

Хотелось бы, чтобы функция `send_email()` была асинхронной. Что это значит? Это означает, что при вызове этой функции задача отправки электронной почты запланирована в фоновом режиме, освобождая `send_email()` для немедленного возврата, чтобы приложение могло продолжать работать одновременно с отправляемым электронным письмом.

У Python есть поддержка для запуска асинхронных задач, фактически более чем одним способом. Могут выполняться [поточные, и многопроцессорные](http://www.williamspublishing.com/PDF/978-5-8459-1793-5/part.pdf) ( `threading` и `multiprocessing` ) модули. Запуск фонового потока для отправленного сообщения намного менее ресурсоемкий, чем запуск совершенно нового процесса, поэтому я собираюсь пойти именно таким путем:

    from threading import Thread
    # ...

    def send_async_email(app, msg):
        with app.app_context():
            mail.send(msg)

    def send_email(subject, sender, recipients, text_body, html_body):
        msg = Message(subject, sender=sender, recipients=recipients)
        msg.body = text_body
        msg.html = html_body
        Thread(target=send_async_email, args=(app, msg)).start()

Функция `send_async_email` теперь работает в фоновом потоке, поскольку вызывается через класс `Thread()` в последней строке `send_email()` . Отправка по электронной почте теперь будет выполняться в отдельном потоке, и когда процесс завершится, поток завершится и очистится. Если вы настроили и используете настоящий почтовый сервер, вы обязательно заметите улучшение скорости, когда вы нажмете кнопку «Отправить» в форме запроса сброса пароля.

Вероятно, вы ожидали, что в поток будет отправлен только аргумент `msg` , но, как видно в коде, я также отправляю экземпляр `app` . При работе с потоками есть важный аспект дизайна Flask, который нужно иметь в виду. Flask использует *contexts* , чтобы избежать необходимости передавать аргументы через функции. Я не собираюсь подробно останавливаться на этом, но знаю, что существуют два типа контекстов, контекст приложения и контекст запроса ( *application context* и *request context* ). В большинстве случаев эти контексты автоматически управляются инфраструктурой, но когда приложение запускает пользовательские потоки, контексты для этих потоков могут потребовать ввода вручную.

Существует множество расширений, для которых требуется, чтобы контекст приложения работал, потому что это позволяет им найти экземпляр приложения Flask без его передачи в качестве аргумента. Причина, по которой многие расширения должны знать экземпляр приложения, заключается в том, что они имеют конфигурацию, хранящуюся в объекте `app.config` . Это как раз ситуация с Flask-Mail. Метод `mail.send()` должен получить доступ к значениям конфигурации для почтового сервера, и это может быть сделано только зная, что такое app. Контекст приложения, созданный с вызовом `with app.app_context()` , делает экземпляр приложения доступным через переменную `current_app` из Flask.
:::

Глава 11: Реконструкция
-----------------------

::: {#post-content-body .post__text .post__text-html io-article-url="https://habr.com/ru/post/349060/"}
### CSS-фреймворки

Хотя вы можете утверждать, что \"кодить\" тяжко, ваша боль ничто по сравнению с тем, что испытывают веб-дизайнеры, создающие шаблоны, которые должны иметь приятный и лаконичный вид для всего списка веб-браузеров. В последние годы стало получше! Но еще есть странные ошибки или причуды в некоторых браузерах, которые сильно усложняют задачу проектирования веб-страниц таким образом, что бы они отображались везде и всегда одинаково хорошо. Это еще сложнее, если вам также нужно выполнить настройки отображения с учетом ограничений экранов для планшетов и смартфонов.

Если вы, как и я, являетесь разработчиком, который просто хочет получить хороший вид веб-страниц, но не имеете времени или интереса, чтобы изучать глубины механизмов для достижения этой эффективности путем написания RAW HTML и CSS, то единственным практическим решением является использование `CSS framework` для упрощения этой задачи. Вы потеряете некоторую творческую свободу, принимая этот путь, но с другой стороны, ваши веб-страницы будут прилично выглядеть во всех браузерах при минимуме приложенных усилий. framework CSS предоставляет коллекцию классов CSS высокого уровня с готовыми стилями для распространенных типов элементов пользовательского интерфейса. Большинство из этих фреймворков также предоставляют JavaScript дополнения для решений, которые не могут быть сделаны строго с HTML и CSS.

### Знакомство с Bootstrap

Одной из самых популярных платформ CSS является [Bootstrap](http://getbootstrap.com/) , созданный Twitter. Если вы хотите увидеть своими глазами страницы, которые могут быть разработаны с этой платформой в документации есть несколько [примеров](https://getbootstrap.com/docs/3.3/getting-started/#examples) .

Вот некоторые из преимуществ использования Bootstrap для стиля веб-страниц:

-   Похожие отображения во всех основных веб-браузерах
-   Обработка настольных, планшетных и телефонных размеров экрана
-   Настраиваемые макеты
-   Красиво стилизованные навигационные панели, формы, кнопки, оповещения, всплывающие окна и т.д.

Самый простой способ использования Bootstrap --- просто импортировать файл `Bootstrap.min.CSS` в базовый шаблон. Можно либо загрузить копию этого файла и добавить его в проект, либо импортировать непосредственно из [CDN](https://en.wikipedia.org/wiki/Content_delivery_network) . После этого вы можете начать использовать классы CSS общего назначения, которые он предоставляет, в соответствии с [документацией](https://getbootstrap.com/docs/3.3/getting-started/) , что очень удобно. Можно импортировать файл `Bootstrap.min.js` , содержащий JavaScript-код фреймворка, что позволяет использовать самые продвинутые функции.

К счастью, есть расширение Flask называется Flask-Bootstrap. Предоставляет готовый к использованию базовый шаблон, который включает в себя платформу Bootstrap. Давайте установим это расширение:

    (venv) $ pip install flask-bootstrap

### Использование Flask-Bootstrap

Flask-Bootstrap должен быть инициализирован, как и большинство других расширений Flask:

> `app/__init__.py: Инициализация Flask-Bootstrap.`

    # ...
    from flask_bootstrap import Bootstrap

    app = Flask(__name__)
    # ...
    bootstrap = Bootstrap(app)

При инициализации расширения шаблон *bootstrap/base.html* становится доступным в других шаблонах приложения по тегу `extends` .

Как вы помните, я уже использую тег `extends` с моим собственным базовым шаблоном, который позволяет мне формировать общие части страницы в одном месте. Шаблон *base.html* определяет панель навигации, которая включает несколько ссылок, а также экспортирует блок `content` . Все остальные шаблоны в моем приложении наследуют элементы базового шаблона и предоставляют блоку `content` основное содержимое страницы.

Итак, как же мне следует использовать базовый шаблон Bootstrap? Идея состоит в том, чтобы использовать трехуровневую иерархию вместо двух. Шаблон *bootstrap/base.html* предоставляет базовую структуру страницы на основе фреймворка Bootstrap. Этот шаблон экспортирует несколько блоков для производных шаблонов, таких как `title` , `navbar` и `content` (см. Полный список блоков [здесь](https://pythonhosted.org/Flask-Bootstrap/basic-usage.html#available-blocks) ). Я собираюсь изменить свой *base.html* -шаблон, чтобы использовать в нем решения из *bootstrap/base.html* и обеспечить реализации для заголовков( `title` ), навигационных блоков( `navbar` ) и блоков контента( `content` ). В свою очередь, *base.html* будет экспортировать собственный блок `app_content` для своих производных шаблонов определяющих содержимое страницы.

Ниже видно, как выглядит *base.html* после модификации его в наследника базового шаблона Bootstrap. Обратите внимание, что эта структура не включает весь HTML для панели навигации, но вы можете найти полную реализацию на GitHub или загрузить код для этой главы.

> `app/templates/base.html: Переработанный базовый шаблон.`

    {% extends 'bootstrap/base.html' %}

    {% block title %}
        {% if title %}{{ title }} - Microblog{% else %}Welcome to Microblog{% endif %}
    {% endblock %}

    {% block navbar %}
        <nav class="navbar navbar-default">
            ... здесь должна быть навигационная панель  (см. полный код на GitHub) ...
        </nav>
    {% endblock %}

    {% block content %}
        <div class="container">
            {% with messages = get_flashed_messages() %}
            {% if messages %}
                {% for message in messages %}
                <div class="alert alert-info" role="alert">{{ message }}</div>
                {% endfor %}
            {% endif %}
            {% endwith %}

            {# содержимое приложения которое должно быть предоставлено в блоке app_content #}
            {% block app_content %}{% endblock %}
        </div>
    {% endblock %}

Здесь видно, как я использую шаблон из *bootstrap/base.html* , за которым следуют три блока, которые реализуют заголовок страницы, панель навигации и содержимое страницы соответственно.

Блок `title` определяет текст, который будет использоваться в качестве заголовка страницы, с тегами `<title>` . Для этого блока я просто переместил логику, которая находилась внутри тега `<title>` в исходном базовом шаблоне.

Блок `navbar` является необязательным блоком, который обычно используется в качестве панели навигации. Для этого блока я адаптировал пример из документации на панель навигации Bootstrap, так что он включает в себя брендинг сайта, а затем ссылки Home и Explore. После чего я добавил ссылки профиля, входа или выхода из системы, выровненные с правой границей страницы. Как я уже упоминал выше, я опустил HTML в приведенном выше примере, но вы можете получить полный шаблон *base.html* из пакета загрузки для этой главы.

Наконец, в блоке `content` я определяю контейнер верхнего уровня, и внутри него у меня есть логика, которая отображает свернутые сообщения, которые теперь будут отображаться в стиле оповещений Bootstrap. За ним следует новый блок `app_content` , который определяется так, чтобы производные шаблоны могли определять свой собственный контент.

Исходная версия всех шаблонов страниц определяла их содержимое в блоке с именем `content` . Как вы видели выше, блок с именем `content` используется из Flask-Bootstrap, поэтому я переименовал свой `content` -блок как `app_content` . После чего, все мои шаблоны необходимо исправить, чтобы использовать `app_content` в качестве своего `content` -блока(содержимого). В качестве примера: так выглядит модифицированная версия шаблона *404.html* :

> `app/templates/404.html: Переработанный шаблон ошибки 404.`

    {% extends "base.html" %}

    {% block app_content %}
        <h1>File Not Found</h1>
        <p><a href="{{ url_for('index') }}">Back</a></p>
    {% endblock %}

### Bootstrap визуализация форм

Область, в которой Flask-Bootstrap делает фантастическую работу, --- это использование форм. Вместо того, чтобы устанавливать поля формы одно за другим, Flask-Bootstrap пользуется макросом, который принимает объект формы Flask-WTF в качестве аргумента и отображает полную форму с использованием стилей Bootstrap.

Ниже вы можете увидеть переработанный шаблон *register.html* в качестве примера:

> `app/templates/register.html: Шаблон регистрации пользователя.`

    {% extends "base.html" %}
    {% import 'bootstrap/wtf.html' as wtf %}

    {% block app_content %}
        <h1>Register</h1>
        <div class="row">
            <div class="col-md-4">
                {{ wtf.quick_form(form) }}
            </div>
        </div>
    {% endblock %}

Разве это не здорово? `import` в верхней части примера работает аналогично импорту Python. Только в составе шаблона. Эта команда добавляет макрос `wtf.quick_form()` , который в одной строке кода отображает полную форму, включая поддержку ошибок проверки отображения, и все в стиле Bootstrap.

Еще раз повторюсь, я не собираюсь показывать вам все изменения, которые я сделал для других форм в приложении. Но все эти изменения сделаны в том самом коде, который вы можете скачать или проверить на GitHub.

### Визуализация сообщений в блогах

Логика представления, которая отображает отдельные сообщения в блоге, была абстрагирована в подшаблон под названием *\_post.html* . Все, что мне нужно сделать с этим шаблоном, --- это внести небольшие корректировки, чтобы он выглядел в стиле Bootstrap.

> `app/templates/_post.html: Переработанный суб-шаблон сообщений.`

    <table class="table table-hover">
        <tr>
            <td width="70px">
                <a href="{{ url_for('user', username=post.author.username) }}">
                    <img src="{{ post.author.avatar(70) }}" />
                </a>
            </td>
            <td>
                <a href="{{ url_for('user', username=post.author.username) }}">
                    {{ post.author.username }}
                </a>
                says:
                <br>
                {{ post.body }}
            </td>
        </tr>
    </table>

### Отображение ссылок на страницы ленты сообщений

Связывание страниц --- это еще одна область, где Bootstrap обеспечивает прямую поддержку. Для этого я просто обратился еще раз к [документации](https://getbootstrap.com/docs/3.3/components/#optional-disabled-state) Bootstrap и адаптировал один из своих примеров. Вот как они выглядят на странице *index.html* :

> `app/templates/index.html: Переработанный вариант многостраничного отображения сообщений.`

    ...
    <nav aria-label="...">
        <ul class="pager">
            <li class="previous{% if not prev_url %} disabled{% endif %}">
                <a href="{{ prev_url or '#' }}">
                    <span aria-hidden="true">&larr;</span> Newer posts
                </a>
            </li>
            <li class="next{% if not next_url %} disabled{% endif %}">
                <a href="{{ next_url or '#' }}">
                    Older posts <span aria-hidden="true">&rarr;</span>
                </a>
            </li>
        </ul>
    </nav>

Обратите внимание, что в этой реализации вместо того, чтобы скрывать следующую или предыдущую ссылку, когда в этом направлении больше нет контента, я применяю `disabled` состояние, которое сделает ссылку недоступной.

Я не буду показывать все здесь, но подобное изменение должно быть применено к *user.html* . Пакет загрузки для этой главы включает и эти изменения.

### До и после

Чтобы обновить приложение, загрузите zip-файл для этой главы и аккуратненько сравните и обновите свои шаблоны.

Ниже приведены несколько снимков экрана *до и после* , чтобы продемонстрировать трансформацию. Имейте в виду, что эти изменение были достигнуты без изменений логики приложений!

![](https://habrastorage.org/webt/vl/b6/ip/vlb6ipkxuo-28reonh2v4bylbju.png)

![](https://habrastorage.org/webt/ll/2y/p_/ll2yp_ljgyfsb1ytoysbhnlq1-w.png)

#### P.S. От переводчика

На первом скрине приглашение имеет стандартную надпись [\'Please log in to access this page.\']{.underline}

Это умолчание модуля *flask-login* . Если вас эта надпись по каким то причинам не устраивает, то ее можно заменить собственной. Для этого требуется определить свойство `login_message` экземпляра класса `LoginManager` . Однако, следует помнить, что если вы добавляете кириллические символы в модуль, то необходимо, что бы первая строка устанавливала требуемую кодировку.

> `app/__init__.py: Доработанный вариант` .

`# -*- coding: utf-8 -*-` ... login = LoginManager(app) login.login\_view = \'login\' login.login\_message = \"Пожалуйста, войдите, чтобы открыть эту страницу.\" `# <--` я добавил эту строку \...

![](https://habrastorage.org/webt/cb/-u/np/cb-unplmr1pgvb2g5xuw46df3n0.png)
:::

Глава 12: Дата и время
----------------------

::: {#post-content-body .post__text .post__text-html io-article-url="https://habr.com/ru/post/349604/"}
### Адский часовой пояс

Использование функционала Python на сервере для отображения даты и времени, которые отображены пользователям в их веб-браузерах, не очень хорошая идея. Рассмотрим следующий пример. Я пишу это в 16:06 28 сентября 2017. Мой часовой пояс в то время, когда я пишу это, --- это PDT (или UTC-7, если хотите). В интерпретаторе Python я получаю следующее:

    >>> from datetime import datetime
    >>> str(datetime.now())
    '2017-09-28 16:06:30.439388'
    >>> str(datetime.utcnow())
    '2017-09-28 23:06:51.406499'

Вызов `datetime.now()` возвращает правильное время для моего местоположения, а вызов `datetime.utcnow()` возвращает время в часовом поясе UTC. Если бы я мог попросить людей, живущих в разных частях света, запустить этот код в то же время со мной, то функция `datetime.now()` вернула бы разные результаты для каждого человека, но `datetime.utcnow()` всегда будет возвращать одно значение в то же время, независимо от местоположения. Итак, какой вариант, по вашему мнению, лучше использовать в веб-приложении, которое, скорее всего, будет доступно пользователям по всему миру?

Очевидно, что сервер должен управлять временем, которое не зависит от местоположения. Если это приложение будет развиваться и появится необходимость использования нескольких production серверов в разных регионах по всему миру, я бы не хотел, чтобы каждый сервер записывал временные метки в базу данных в соответствии разными часовыми поясами, потому что это затруднит работу с этими данными. Поскольку UTC является наиболее используемым единообразным часовым поясом и поддерживается в классе `datetime` , это то, что надо! И я буду это использовать.

Но в этом варианте появляется одна важная проблема. Для пользователей в разных часовых поясах будет сложно определить, когда реально была сделана запись, если они видят время в часовом поясе UTC. Им нужно заранее понять, что время отображается в UTC и надо суметь мысленно настроить время на свой часовой пояс. Представьте себе пользователя в часовом поясе PDT, который отправляет что-то в 3:00 вечера, и сразу же видит, что сообщение появляется с временем UTC в 22:00 или, точнее, 22:00. Это будет выглядеть запутанно.

Хотя стандартизация временных меток UTC имеет большой смысл с точки зрения сервера, но создает сложности с удобством использования для пользователей. Цель этой главы --- решить эту проблему, сохранив все временные метки, управляемые на сервере в UTC.

### Конверсия часовых поясов

Очевидным решением этой проблемы является преобразование всех временных меток из UTC в локальное время каждого пользователя. Это позволяет серверу продолжать использовать UTC для согласованности, в то время как преобразование «на лету», адаптированное для каждого пользователя, решает проблему удобства. Сложность этого решения заключается в определении местоположение каждого пользователя.

На многих веб-сайтах есть страница конфигурации, где пользователи могут указывать свой часовой пояс. Это потребует от меня добавления новой страницы с формой, в которой я представляю пользователям выпадающий список со списком часовых поясов. Пользователям будет предложено ввести свой часовой пояс, когда они впервые обращаются к сайту, в рамках их регистрации.

Хотя это достойное решение, которое решает проблему, немного странно просить пользователей ввести часть информации, которую они уже настроили в своей операционной системе. Кажется, было бы более эффективно, если бы я мог просто узнать настройку часового пояса у локального компьютера.

Как выясняется, веб-браузер знает часовой пояс пользователя и предоставляет его через стандартные API JavaScript. На самом деле существует два способа использовать информацию о часовом поясе, доступную через JavaScript:

-   Подход «старой школы» заключался бы в том, чтобы веб-браузер каким-то образом отправлял информацию о часовом поясе на сервер, когда пользователь впервые регистрируется в приложении. Это можно сделать с помощью вызова [Ajax](http://en.wikipedia.org/wiki/Ajax_(programming)) или, что еще проще, с [тегом meta refresh](http://en.wikipedia.org/wiki/Meta_refresh) . Как только сервер определил часовой пояс, он может сохранить его в сеансе или записать его в запись пользователя в базе данных, а затем настроить все временные метки во время отображения шаблонов.

-   Подход «новой школы» состоял бы в том, чтобы не изменить ситуацию на сервере и позволить конвертировать с UTC в локальный часовой пояс на клиенте, используя JavaScript. Оба варианта рабочие, но второй имеет большое преимущество. Знать часовой пояс не всегда достаточно, чтобы представить дату и время в ожидаемом пользователем формате. Браузер также имеет доступ к конфигурации локали системы, которая определяет такие вещи, как AM/PM и 24-часовой формат, DD/MM/YYYY против MM/DD/YYYY и многие другие культурные или региональные стили.

И если и этого недостаточно, есть ещё одно преимущество в пользу «новой школы». Существует библиотека с открытым исходным кодом, которая делает все это!

### Знакомство с Moment.js и Flask-Moment

[Moment.js](http://momentjs.com/) --- небольшая библиотека JavaScript с открытым исходным кодом переводит задачу отображения даты и времени совсем на другой уровень, так как предоставляет все мыслимые варианты форматирования. И некоторое время назад я создал Flask-Moment, небольшое расширение Flask, которое упростило включение Moment.js в ваше приложение.

Итак, начнем с установки Flask-Moment:

    (venv) $ pip install flask-moment

Это расширение добавляется в приложение Flask обычным способом:

> `app/__init__.py` : Создаем экземпляр Flask-Moment.

    # ...
    from flask_moment import Moment

    app = Flask(__name__)
    # ...
    moment = Moment(app)

В отличие от других расширений, Flask-Moment работает вместе с *moment.js* , поэтому все шаблоны приложения должны включать эту библиотеку. Чтобы эта библиотека всегда была доступна, я собираюсь добавить ее в базовый шаблон. Это можно сделать двумя способами. Казалось бы, что самый прямой способ --- явно добавить тег `<script>` , который импортирует библиотеку. Но Flask-Moment предлагает вариант еще проще, предоставляя функцию `moment.include_moment()` , которая генерирует тег `<script>` :

> app/templates/base.html: Добавляем moment.js в базовый шаблон.

    ...

    {% block scripts %}
        {{ super() }}
        {{ moment.include_moment() }}
    {% endblock %}

Блок `scripts` , который я здесь добавил, представляет собой еще один, экспортируемый базовым шаблоном Flask-Bootstrap. Это место, в которое должны быть включены импорт(ы) JavaScript. Этот блок отличается от предыдущего тем, что он уже поставляется с некоторым содержимым, определенным в базовом шаблоне. Все, что я хочу сделать, это добавить библиотеку moment.js, не теряя базового содержимого. И это достигается с помощью инструкции `super()` , которая сохраняет контент из базового шаблона. Если вы определяете блок в своем шаблоне без использования `super()` , то любой контент, определенный для этого блока в базовом шаблоне, будет потерян.

### Использование Moment.js

Moment.js предоставляет браузеру доступный `moment` class. Первым шагом для создания временной метки является создание объекта этого класса, передачей требуемой метки времени в формате [ISO 8601](http://en.wikipedia.org/wiki/ISO_8601) . Вот пример:

    t = moment('2017-09-28T21:45:23Z')

Если вы не знакомы со стандартным форматом ISO 8601 для дат и времени, формат выглядит следующим образом: `{{ year }}-{{ month }}-{{ day }}T{{ hour }}:{{ minute }}:{{ second }}{{ timezone }}` . Я уже решил, что я буду работать только с часовым поясом UTC, поэтому последняя часть всегда будет `Z` , которая представляет собой UTC в стандарте ISO 8601.

Объект `moment` предоставляет несколько методов для разных вариантов отображения. Ниже приведены некоторые из наиболее распространенных вариантов:

    moment('2017-09-28T21:45:23Z').format('L')
    "09/28/2017"
    moment('2017-09-28T21:45:23Z').format('LL')
    "September 28, 2017"
    moment('2017-09-28T21:45:23Z').format('LLL')
    "September 28, 2017 2:45 PM"
    moment('2017-09-28T21:45:23Z').format('LLLL')
    "Thursday, September 28, 2017 2:45 PM"
    moment('2017-09-28T21:45:23Z').format('dddd')
    "Thursday"
    moment('2017-09-28T21:45:23Z').fromNow()
    "7 hours ago"
    moment('2017-09-28T21:45:23Z').calendar()
    "Today at 2:45 PM"

В этом примере создается объект `moment` , инициализированный строкой 28 сентября 2017 года в 21:45 по UTC. Вы можете видеть, что все параметры, которые я пробовал выше, отображаются в UTC-7, который является часовым поясом, настроенным на моем компьютере. Вы можете ввести приведенные выше команды в консоль вашего браузера, убедившись, что страница, на которой вы открываете консоль, содержит moment.js. Вы можете сделать это в микроблоге, если вы внесли изменения выше, включив moment.js, а также на <https://momentjs.com/> .

Обратите внимание, как разные методы создают разные представления. При помощи `format()` вы управляете форматом вывода с помощью строки имени формата, аналогичной функции [strftime](https://docs.python.org/3.6/library/time.html#time.strftime) из Python. Методы `fromNow()` и `calendar()` интересны тем, что они отображают временную метку по отношению к текущему времени, поэтому вы получаете строку вывода, такую как «минута назад» или «через два часа» и т.д.

Если бы вы работали непосредственно в JavaScript, приведенные выше вызовы возвратили строку с отображением временной метки. Значит для добавления этого текста в нужное место на странице, требуется использование JavaScript для работы с [DOM](https://en.wikipedia.org/wiki/Document_Object_Model) . Расширение Flask-Moment значительно упрощает использование moment.js, позволяя вашим шаблонам включающим объект `moment` , включать требуемую магию JavaScript, чтобы отобразить время на странице правильным образом.

Давайте посмотрим на метку времени, которая появляется на странице профиля. Текущий шаблон *user.html* позволяет Python генерировать строковое представление времени. Теперь я могу сделать эту метку времени с помощью Flask-Moment следующим образом:

> app/templates/user.html: Метка времени с использованием moment.js.

                {% if user.last_seen %}
                <p>Last seen on: {{ moment(user.last_seen).format('LLL') }}</p>
                {% endif %}

Как вы можете видеть, Flask-Moment использует синтаксис, похожий на синтаксис библиотеки JavaScript, с одним маленьким отличием, которым является то, что аргумент `moment()` теперь является объектом Python `datetime` , а не строкой ISO 8601. Данный вызов moment() в шаблоне также автоматически генерирует необходимый код JavaScript для вставки оказываемых меток в нужное место DOM.

Второе место, где можно воспользоваться Flask-Moment и moment.js находится в *`_post.html`* sub-шаблоне, который вызывается из индексной и пользовательской страниц. В текущей версии шаблона каждому сообщению предшествовала строка \"username says:\". Теперь я могу добавить временную метку с помощью `fromnow()` :

> app/templates/\_post.html: Отметка времени субшаблоне сообщения.

                <a href="{{ url_for('user', username=post.author.username) }}">
                    {{ post.author.username }}
                </a>
                said {{ moment(post.timestamp).fromNow() }}:
                <br>
                {{ post.body }}

Вот так выглядят обе эти метки времени при визуализации с помощью Flask-Moment и moment.js:

![](https://habrastorage.org/webt/mm/lh/c1/mmlhc17urv9gi3mgxjak0q79m04.png)

#### P.S. от переводчика

Если вам вдруг требуется, как и мне, отобразить дату на языке отличающемся от английского, например русском. Расширение flask-moment имеет для этой цели в своем арсенале метод `lang()` .

![](https://habrastorage.org/webt/1j/pp/py/1jpppyqpbanphn3omd8xkqrpapu.png)

> app/templates/base.html: Добавил в блок moment.js в базовом шаблоне метод lang.

    ...

    {% block scripts %}
        {{ super() }}
        {{ moment.include_moment() }}
        {{ moment.lang('ru') }}     <!-- Я добавил эту строку -->
    {% endblock %}
:::

Глава 13: I18n и L10n
---------------------

::: {#post-content-body .post__text .post__text-html io-article-url="https://habr.com/ru/post/350148/"}
### Введение в Flask-Babel

Как вы, наверное, уже догадались, существует расширение Flask, которое упрощает работу с переводами. Расширение называется [Flask-Babel](https://pythonhosted.org/Flask-Babel/) и устанавливается с помощью pip:

    (venv) $ pip install flask-babel

Flask-Babel инициализируется, как и большинство других расширений Flask:

> *`app/__init__.py`* : Инициализация Flask-Babel.

    # ...
    from flask_babel import Babel

    app = Flask(__name__)
    # ...
    babel = Babel(app)

В качестве примера, я расскажу вам, как перевести приложение на испанский язык, поскольку я, случается, говорю на этом языке. Я мог бы также работать с переводчиками, которые знают другие языки и поддерживают их. Чтобы отслеживать список поддерживаемых языков, следует добавить переменную конфигурации:

> *config.py* : Список поддерживаемых языков.

    class Config(object):
        # ...
        LANGUAGES = ['en', 'es']

Я использую двухбуквенные коды языков для этого приложения, но если вам нужно быть более конкретным, можно добавить код страны. Например, вы можете использовать `en-US` , `en-GB` и `en-CA` для поддержки английского с разными диалектами США, Великобритания или Канада.

Экземпляр `Babel` предоставляет декоратор `localeselector` . Декорированная функция вызывается для каждого запроса, чтобы выбрать перевод языка для использования:

> *`app/__init__.py`* : Выбор предпочтительного языка.

    from flask import request

    # ...

    @babel.localeselector
    def get_locale():
        return request.accept_languages.best_match(app.config['LANGUAGES'])

Здесь я использую атрибут объекта Flask `request` , называемый `accept_languages` . Этот объект обеспечивает интерфейс высокого уровня для работы с заголовком [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language) , отправляемым клиентами с запросом. Этот заголовок указывает язык клиента и языковые предпочтения в виде средневзвешенного списка. Содержимое этого заголовка можно настроить на странице настроек браузера, при этом по умолчанию обычно импортируются из языковых настроек в операционной системе компьютера. Большинство людей даже не знают, что такая настройка существует, но это полезно, поскольку пользователи могут предоставить список предпочтительных языков, каждый из которых имеет вес. Если вам интересно, вот пример сложного заголовка `Accept-Languages` :

    Accept-Language: da, en-gb;q=0.8, en;q=0.7

Видим, что Датский ( `da` ) является предпочтительным языком (значение веса по умолчанию 1,0), а затем Британский английский ( `en-gb` ) с весом 0,8, и в качестве последнего варианта Общий Английский ( `en` ) с весом 0,7.

Чтобы выбрать лучший язык, вам нужно сравнить список языков, запрашиваемых клиентом, с языками, которые поддерживает приложение, и, используя предоставленные клиентом веса, найти лучший язык. Возможно вам кажется эта логика слишком сложной, но все это инкапсулируется в метод `best_match()` , который принимает список языков, предлагаемых приложением в качестве аргумента и возвращает лучший выбор.

### Маркировка текстов для перевода в исходном коде Python

Рано обрадовались. Теперь о грустном. Обычный рабочий процесс при создании приложения на нескольких языках заключается в разметке всех текстов, требующие перевода в исходном коде. После того, как тексты будут помечены, Flask-Babel будет сканировать все файлы и извлекать эти тексты в отдельный файл перевода, используя инструмент [gettext](https://www.gnu.org/software/gettext/) . К сожалению, это утомительная задача, которая должна быть выполнена для перевода.

Я собираюсь показать вам несколько примеров этой маркировки, но получить полный набор изменений вы можете из [пакета](https://github.com/miguelgrinberg/microblog/tree/v0.13) для этой главы или репозитория GitHub.

Способ, которым тексты помечены для перевода, заключается в обертывании их в вызов функции, которая вызывается как соглашение `_()` , просто подчеркивание. Простейшими случаями являются те, где литеральные строки появляются в исходном коде. Ниже приведен пример оператора flash()\`:

    from flask_babel import _
    # ...
    flash(_('Your post is now live!'))

Идея заключается в том, что функция `_()` переносит текст на базовый язык (в данном случае английский). Она будет использовать лучший по ее мнению язык, выбранный функцией `get_locale` , декорированной функцией `localeselector` , чтобы найти правильный перевод для данного клиента. Затем функция `_()` вернет переведенный текст, который в этом случае станет аргументом для `flash()` .

К сожалению, не все случаи так просты. Рассмотрим этот другой вызов `flash()` из приложения:

    flash('User {} not found.'.format(username))

Этот текст имеет динамический компонент, который вставлен в середине статического текста. Функция `_()` имеет синтаксис, поддерживающий этот тип текстов, но основанный на старом синтаксисе подстановки строк:

    flash(_('User %(username)s not found.', username=username))

Есть еще более трудный случай. Некоторые строковые литералы назначаются вне запроса, как правило, когда приложение запускается, поэтому в то время, когда эти тексты оцениваются, нет способа узнать, какой язык использовать. Примером этого являются метки, связанные с полями формы. Единственное решение для обработки этих текстов --- найти способ отложить оценку строки до ее использования, которая будет находиться под фактическим запросом. Flask-Babel предоставляет версию ( *lazy evaluation* ) отложенного вычисления `_()` , которая называется `lazy_gettext()` :

    from flask_babel import lazy_gettext as _l

    class LoginForm(FlaskForm):
        username = StringField(_l('Username'), validators=[DataRequired()])
        # ...

Здесь я импортирую альтернативную функцию перевода и переименовываю ее в `_l ()` , так что она была схожа по названию с оригинальной `_()` . Эта новая функция переносит текст в специальный объект, содержащий метод перевода, который состоится позже, в момент использования строки.

Расширение Flask-Login высвечивает сообщение при каждой переадресации пользователя на страницу входа. Это сообщение написано на английском языке и формируется в умолчаниях самого расширения. Чтобы убедиться, что это сообщение также переведено, я собираюсь переопределить сообщение по умолчанию и предоставить другой вариант декорированный функцией `_l()` для отложенного вызова:

    login = LoginManager(app)
    login.login_view = 'login'
    login.login_message = _l('Please log in to access this page.')

### Разметка текстов для перевода в шаблонах

В предыдущем разделе вы видели, как разметить переводимые тексты в исходном коде модулей Python, но это только часть процесса, так как файлы шаблонов также содержат текст. Функция `_()` также доступна в шаблонах, поэтому процесс сильно похож. Например, рассмотрим этот фрагмент HTML из *404.html* :

    <h1>File Not Found</h1>

Версия с поддержкой перевода:

    <h1>{{ _('File Not Found') }}</h1>

Обратите внимание, что здесь, помимо обертывания текста с помощью `_()` , необходимо добавить `{{...}}` , чтобы заставить `_()` вычислять вместо того, чтобы считаться литералом в шаблоне.

Для более сложных фраз, содержащих динамические компоненты, можно использовать аргументы:

    <h1>{{ _('Hi, %(username)s!', username=current_user.username) }}</h1>

В файле *`_post.html`* есть особенно сложный случай, который заставил меня разбираться:

        {% set user_link %}
            <a href="{{ url_for('user', username=post.author.username) }}">
                {{ post.author.username }}
            </a>
        {% endset %}
        {{ _('%(username)s said %(when)s',
            username=user_link, when=moment(post.timestamp).fromNow()) }}

Проблема здесь заключается в том, что я хотел, чтобы имя пользователя было ссылкой, указывающей на страницу профиля пользователя, а не только именем, так что мне пришлось создать промежуточную переменную под названием `user_link` с помощью `set` и `endset` директивы шаблонов, а затем передать это как аргумент функции перевода.

Как я уже упоминал выше, вы можете [скачать](https://github.com/miguelgrinberg/microblog/tree/v0.13) версию приложения со всеми переводимыми текстами в исходном коде Python и шаблонах.

### Извлечение текста для перевода

После того, как у вас есть приложение со всеми `_()` и `_l()` на своих местах, вы можете использовать команду `pybabel` , чтобы извлечь их в файл *a.pot* , что означает *[portable object template](https://ru.wikipedia.org/wiki/Gettext)* . Это текстовый файл, содержащий все тексты, которые были помечены как нуждающиеся в переводе. Цель этого файла состоит в том, чтобы служить шаблоном для создания файлов перевода на любой другой язык.

Для процесса извлечения требуется небольшой файл конфигурации, который сообщает `pybabel` , какие файлы следует сканировать для переводимых текстов. Ниже вы можете увидеть *babel.cfg* , который я создал для этого приложения:

> *babel.cfg* : PyBabel configuration file.

    [python: app/**.py]
    [jinja2: app/templates/**.html]
    extensions=jinja2.ext.autoescape,jinja2.ext.with_

Первые две строки определяют имена файлов шаблонов Python и Jinja2 соответственно. Третья строка определяет два расширения, предоставляемые движком шаблонов Jinja2, которые помогают Flask-Babel правильно анализировать файлы шаблонов.

Чтобы извлечь все тексты в *.pot* файл, вы можете использовать следующую команду:

    (venv) $ pybabel extract -F babel.cfg -k _l -o messages.pot .

Команда `pybabel extract` считывает файл конфигурации, указанный в параметре `-F` , а затем сканирует все файлы *py* и *html* в каталогах, соответствующих настроенным источникам, начиная с каталога, указанного в команде (текущий каталог или `.` в этом случае.) По умолчанию, `pybabel` будем искать `_()` как текстовый маркер, но я также использовал *lazy* вариант, который я импортировал как `_l()` , так что мне нужно сказать об этом инструменту поиска опцией `-k` `_l` . Параметр `-o` указывает имя выходного файла.

Должен отметить, что *messages.pot* не является файлом, который должен быть включен в проект. Это файл, который можно легко регенерировать в любое время, просто выполнив команду выше снова. Таким образом, нет необходимости передавать этот файл в систему управления версиями.

### Создание Language Catalog

Следующим шагом в процессе является создание перевода для каждого языка, который будет поддерживаться в дополнение к базовому, который в данном случае английский. Я сказал, что собираюсь начать с добавления испанского языка (код языка `es` ), так что команда, которая делает это:

    (venv) $ pybabel init -i messages.pot -d app/translations -l es
    creating catalog app/translations/es/LC_MESSAGES/messages.po based on messages.pot

Команда `pybabel init` принимает файл `messages.pot` в качестве входных данных и создает новый каталог для определенного языка, указанного в параметре `-l` в каталог, указанный в параметре `-d` . Я буду сохранять все переводы в директории *app/translations* , потому что там Flask-Babel будет искать файлы перевода по умолчанию. Команда создаст подкаталог `es` внутри этого каталога для данных на испанском. В частности, там появится новый файл с названием *app/translations/es/LC\_MESSAGES/messages.po* . То есть там, где переводы должны быть сделаны.

Если вы хотите поддержать другие языки, то повторите вышеуказанную команду с каждым из кодов языка. Таким образом, что бы каждый язык получил свой собственный репозитарий с файлом *messages.po* .

Этот *messages.po* -файл, созданный в каждом языковом репозитории, использует формат, который является стандартом де-факто для языковых переводов, Формат, используемый утилитой [gettext](http://www.gnu.org/software/gettext/) . Вот несколько строк начала испанского messages.po:

    # Spanish translations for PROJECT.
    # Copyright (C) 2017 ORGANIZATION
    # This file is distributed under the same license as the PROJECT project.
    # FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
    #
    msgid ""
    msgstr ""
    "Project-Id-Version: PROJECT VERSION\n"
    "Report-Msgid-Bugs-To: EMAIL@ADDRESS\n"
    "POT-Creation-Date: 2017-09-29 23:23-0700\n"
    "PO-Revision-Date: 2017-09-29 23:25-0700\n"
    "Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
    "Language: es\n"
    "Language-Team: es <LL@li.org>\n"
    "Plural-Forms: nplurals=2; plural=(n != 1)\n"
    "MIME-Version: 1.0\n"
    "Content-Type: text/plain; charset=utf-8\n"
    "Content-Transfer-Encoding: 8bit\n"
    "Generated-By: Babel 2.5.1\n"

    #: app/email.py:21
    msgid "[Microblog] Reset Your Password"
    msgstr ""

    #: app/forms.py:12 app/forms.py:19 app/forms.py:50
    msgid "Username"
    msgstr ""

    #: app/forms.py:13 app/forms.py:21 app/forms.py:43
    msgid "Password"
    msgstr ""

Если пропустить заголовок, то видно, что ниже приведен список строк, которые были извлечены из вызовов `_()` и `_l()` . Для каждого текста вы получаете ссылку на расположение текста в приложении. Затем строка `msgid` содержит текст на базовом языке, а следующая строка `msgstr` содержит пустую строку. Эти пустые строки должны быть отредактированы, чтобы иметь текст на целевом языке.

Есть [много приложений](https://localise.biz/free/poeditor) , которые работают с переводом `.po` -файлов. Если вы чувствуете себя комфортно при редактировании текстового файла, то этого достаточно, но если вы работаете с большим проектом, то может быть рекомендовано работать со специализированным редактором. Наиболее популярным приложением для перевода является `poedit` с открытым исходным кодом, который доступен для всех основных операционных систем. Если вы знакомы с `VIM` , то `po.vim` плагин дает некоторые ключевые отображения, которые делают работу с этими файлами проще.

Ниже вы можете увидеть часть испанской версии *messages.po* после того, как я добавил перевод:

    #: app/email.py:21
    msgid "[Microblog] Reset Your Password"
    msgstr "[Microblog] Nueva Contraseña"

    #: app/forms.py:12 app/forms.py:19 app/forms.py:50
    msgid "Username"
    msgstr "Nombre de usuario"

    #: app/forms.py:13 app/forms.py:21 app/forms.py:43
    msgid "Password"
    msgstr "Contraseña"

[Пакет загрузки](https://github.com/miguelgrinberg/microblog/tree/v0.13) для этой главы также содержит этот файл, так что вам не придется беспокоиться об этой части приложения.

Файл *messages.po* -это своего рода файл-источник для переводов. Если вы хотите начать использовать эти переведенные тексты, то файл должен быть скомпилирован в формат, который эффективен для использования приложением во время выполнения. Чтобы собрать все переводы для приложения, вы можете использовать команду компиляции `pybabel compile` следующим образом:

    (venv) $ pybabel compile -d app/translations
    compiling catalog app/translations/es/LC_MESSAGES/messages.po to
    app/translations/es/LC_MESSAGES/messages.mo

Эта операция добавляет файл *messages.mo* рядом с *messages.po* в каждом языковом репозитории. Файл *.mo* --- это файл, который Flask-Babel будет использовать для загрузки переводов в приложение.

После создания *messages.mo* для испанского или любых других языков, добавленных в проект, эти языки готовы к использованию в приложении. Если вы хотите увидеть, как выглядит приложение на испанском языке, Вы можете изменить конфигурацию языка в веб-браузере, чтобы испанский язык был предпочтительным языком. Для Chrome это расширенная часть в настройках:

![](https://habrastorage.org/webt/sf/tf/rv/sftfrvpmnttmnnigxi7mq6i52a0.jpeg)

Если вы предпочитаете не изменять настройки браузера, другой альтернативой является принудительное использование языка, заставляя функцию `localeselector` всегда возвращать один и тот же. Для испанского это выглядит так:

> *`app/__init__.py`* : Выбор испанского ( директивно).

    @babel.localeselector
    def get_locale():
        # return request.accept_languages.best_match(app.config['LANGUAGES'])
        return 'es'

Запуск приложения в браузере, настроенном на испанский язык, или в случае принудительного присвоения значения `es` функции `localeselector` , заставит все тексты появляться на испанском языке в приложении.

### Обновление переводов

Одна из распространенных ситуаций при работе с переводами заключается в том, что вы можете начать использовать файл перевода, даже если он неполный. Это совершенно нормально, можно компилировать неполные файлы *messages.po* . В этом случае будут использоваться po-файлы и любые доступные переводы, а отсутствующие будут использовать базовый язык. Затем можно продолжить работу над переводами и выполнить компиляцию для обновления *messages.mo* .

Другой распространенный случай возникает, если вы пропустили некоторые тексты при добавлении `_()` обертки. В этом случае вы увидите, что те тексты, которые вы пропустили, останутся на английском языке, потому что Flask-Babel ничего о них не знает. В этом случае необходимо добавить `_()` или `_l()` обертки при обнаружении текстов, которые не имеют их, а затем выполнить процедуру обновления, которая включает в себя два шага:

    (venv) $ pybabel extract -F babel.cfg -k _l -o messages.pot .
    (venv) $ pybabel update -i messages.pot -d app/translations

Команда `extract` идентична той, которую я описывал ранее, но теперь она будет генерировать новую версию *messages.pot* со всеми предыдущими текстами плюс что-нибудь новое, которое вы недавно обернули с помощью `_()` или `_l()` . Вызов обновления принимает новый файл *messages.pot* и объединяет его во все файлы *messages.po* , связанные с проектом. Это будет интеллектуальное слияние, в котором любые существующие тексты будут оставлены в покое, в то время как будут затронуты только записи, которые были добавлены или удалены в *messages.pot* .

После обновления *messages.po* вы можете продолжить и перевести все новые тесты, а затем скомпилировать сообщения еще раз, чтобы сделать их доступными для приложения.

### Перевод дат и времени

Теперь у меня есть полный испанский перевод для всех текстов в коде Python и шаблонах. Но если вы запустите приложение на испанском языке и будете хорошим наблюдателем, то вы заметите, что есть еще несколько мест, которые остались на английском языке. Я имею в виду временные метки, созданные Flask-Moment и moment.js, которые, очевидно, не были включены в перевод, потому что ни один из текстов, созданных этими пакетами, не является частью исходного кода или шаблона приложения.

moment.js поддерживает локализацию и интернационализацию, поэтому все, что мне нужно сделать, это настроить правильный язык. Flask-Babel возвращает выбранный язык и локаль для такого случая с помощью функции `get_locale()` , поэтому я собираюсь добавить локаль в объект `g` , чтобы получить доступ к нему из базового шаблона:

> *`app/routes.py`* : Сохраняем выбранный язык в flask.g.

    # ...
    from flask import g
    from flask_babel import get_locale

    # ...

    @app.before_request
    def before_request():
        # ...
        g.locale = str(get_locale())

Функция `get_locale()` из Flask-Babel возвращает объект, но я просто хочу иметь код языка, который может быть получен путем преобразования объекта в строку. Теперь, когда у меня есть `g.locale` , я могу получить к нему доступ из базового шаблона, чтобы настроить *moment.js* с правильным языком:

> *app/templates/base.html* : Устанавливаем языковой стандарт для moment.js.

    ...
    {% block scripts %}
        {{ super() }}
        {{ moment.include_moment() }}
        {{ moment.lang(g.locale) }}
    {% endblock %}

И теперь все даты и время должны появляться на том же языке, что и текст. Ниже вы можете увидеть, как приложение выглядит на испанском языке:

![](https://habrastorage.org/webt/q5/gm/ly/q5gmly3xs-mlkq4coeppx2-4u_i.png)

На этом этапе все тексты, кроме тех, которые были предоставлены пользователем в сообщениях блога или описаниях профиля, должны быть переведены на другие языки.

### Усовершенствования для командной строки

Вы, вероятно, согласитесь со мной, что команды `pybabel` слгка длинны и их трудно запомнить. Я собираюсь использовать эту возможность, чтобы показать вам, как вы можете создавать пользовательские команды, интегрированные с командой flask. До сих пор вы видели использование `flask run` , `flask shell` , и несколько `flask db` суб-команды в Flask-Migrate. На самом деле легко добавить специфичные для приложения команды в flask. Итак, теперь я собираюсь создать несколько простых команд, которые запускают команды `pybabel` со всеми аргументами, которые специфичны для этого приложения. Команды, которые я собираюсь добавить:

-   `flask translate init LANG` добавить новый язык
-   `flask translate update` обновить все языковые репозитории
-   `flask translate compile` для компиляции всех языковых репозиториев

`babel export` не будет командой, потому что генерация файла *messages.pot* всегда является предварительным условием для выполнения команд `init` или `update` . Поэтому реализация этих команд будет генерировать файл шаблона перевода как временный файл.

Flask полагается на [Click](http://click.pocoo.org/5/) для всех своих операций с командной строкой. Команды, такие как `translate` , которые являются корнем для нескольких подкоманд, создаются с помощью декоратора `app.cli.group()` . Я собираюсь поместить эти команды в новый модуль под названием *app/cli.py* :

> *app/cli.py* : Перевести группу команд.

    from app import app

    @app.cli.group()
    def translate():
        """Translation and localization commands."""
        pass

Имя команды происходит от имени декорированной функции, а справочное сообщение поступает из docstring. Поскольку это родительская команда, которая существует только для обеспечения базы для подкоманд, самой функции ничего не нужно делать.

`Update` -обновление и `compile` -компиляцию легко реализовать, поскольку они не принимают никаких аргументов:

> *app/cli.py* : Обновление и компиляция вложенных команд.

    import os

    # ...

    @translate.command()
    def update():
        """Update all languages."""
        if os.system('pybabel extract -F babel.cfg -k _l -o messages.pot .'):
            raise RuntimeError('extract command failed')
        if os.system('pybabel update -i messages.pot -d app/translations'):
            raise RuntimeError('update command failed')
        os.remove('messages.pot')

    @translate.command()
    def compile():
        """Compile all languages."""
        if os.system('pybabel compile -d app/translations'):
            raise RuntimeError('compile command failed')

Обратите внимание, что декоратор из этих функций является производным от родительской функции `translate` . Это может показаться запутанным, так как `translate()` --- это функция, но это стандартный способ, которым Click создает группы команд. Так же, как и в функции `translate()` , *docstrings* -строки документации для этих функций используются в качестве сообщения справки в выводе *\--help* .

Возможно вы заметили, что во всех командах, которые я запускаю есть проверка возвращаемого значения на ноль. Это означает, что команда выполнена и не вернула никакой ошибки. Если в команде ошибка, то я поднимаю `RuntimeError` , что приводит к остановке скрипта. Функция `update()` объединяет шаги извлечения и обновления в одной команде, и если все прошло успешно, она удаляет файл *messages.pot* после завершения обновления, так как этот файл может быть легко регенерирован при необходимости еще раз.

Команда `init` принимает новый код языка в качестве аргумента. Вот реализация:

> *app/cli.py* : **Init** --- sub-команда инициализации.

    import click

    @translate.command()
    @click.argument('lang')
    def init(lang):
        """Initialize a new language."""
        if os.system('pybabel extract -F babel.cfg -k _l -o messages.pot .'):
            raise RuntimeError('extract command failed')
        if os.system(
                'pybabel init -i messages.pot -d app/translations -l ' + lang):
            raise RuntimeError('init command failed')
        os.remove('messages.pot')

Эта команда использует декоратор `@click.argument` для определения кода языка. Click передает значение, указанное в команде функции обработчика в качестве аргумента, а затем я включаю аргумент в команду `init` .

Последним шагом для включения этих команд является их импорт, чтобы команды регистрировались. Я решил сделать это в файле *microblog.py* в каталоге верхнего уровня:

> *microblog.py* : Регистрация команд командной строки.

    from app import cli

Здесь единственное, что мне нужно сделать, это импортировать новый модуль *cli.py* , нет никакой необходимости делать что-либо с ним, так как импорт вызывает декораторы команды для запуска и регистрации команды.

В этот момент, запуск `flask --help` передаст команду `translate` в качестве опции. И `flask translate --help` отобразит вывод трех суб-команд, которые я определил:

    (venv) $ flask translate --help
    Usage: flask translate [OPTIONS] COMMAND [ARGS]...

      Translation and localization commands.

    Options:
      --help  Show this message and exit.

    Commands:
      compile  Compile all languages.
      init     Initialize a new language.
      update   Update all languages.

Так что теперь, рабочий процесс гораздо проще и нет необходимости помнить длинные и сложные команды. Чтобы добавить новый язык, используйте:

    (venv) $ flask translate init <language-code>

Обновить все языки после внесения изменений в маркеры `_()` и `_l()` :

    (venv) $ flask translate update

И компилировать все языки после обновления файлов перевода:

    (venv) $ flask translate compile
:::

Глава 14: Ajax
--------------

::: {#post-content-body .post__text .post__text-html io-article-url="https://habr.com/ru/post/350626/"}
### Серверная и клиентская стороны

В традиционной серверной модели, которой я следовал до сих пор, есть клиент (веб-браузер, которым управляет пользователь), выполняющий HTTP-запросы к серверу приложений. Запрос может просто запросить HTML-страницу, например, когда вы нажимаете ссылку \" *профиль* \", или он может инициировать действие, например, когда вы нажимаете кнопку Отправить ( *Submit* ) после редактирования информации профиля. В обоих типах запросов сервер выполняет запрос путем отправки новой веб-страницы клиенту, либо непосредственно, либо путем перенаправления. Затем клиент заменяет текущую страницу новой. Этот цикл повторяется, пока пользователь остается на веб-сайте приложения. В этой модели сервер делает всю работу, в то время как клиент просто отображает веб-страницы и принимает пользовательский ввод.

Существует другая модель, в которой клиент принимает более активную роль. В этой модели клиент выдает запрос серверу, а сервер отвечает веб-страницей, но в отличие от предыдущего случая, не все данные страницы являются HTML, есть также разделы страницы с кодом, обычно написанные на Javascript. Как только клиент получает страницу, он отображает фрагменты HTML и выполняет код. С этого момента у вас есть активный клиент, который может работать самостоятельно, без какого-либо контакта с сервером. В строгом клиентском приложении всё приложение загружается на клиент с запросом начальной страницы, а затем приложение выполняется полностью на клиенте, только изредка связываясь с сервером для получения или хранения данных и внесения динамических изменений во внешний вид только первой и единственной веб-страницы. Этот тип приложений называется [Single Page Applications](http://http://en.wikipedia.org/wiki/Single-page_application) или SPA.

Большинство приложений являются гибридом между двумя моделями и сочетают технологии обоих. Мое приложение Microblog в основном является серверным приложением, но сегодня я добавлю к нему немного действий на стороне клиента. Чтобы выполнять переводы сообщений в режиме реального времени, клиентский браузер будет отправлять асинхронные запросы на сервер, на которые сервер будет отвечать, не вызывая обновления страницы. Затем клиент будет динамически вставлять переводы в текущую страницу. Этот метод известен как [Ajax](http://en.wikipedia.org/wiki/Ajax_(programming)) , что является сокращением для асинхронного JavaScript и XML (хотя в наши дни XML часто заменяется JSON).

### Рабочий процесс перевода в реальном времени

Приложение имеет хорошую поддержку иностранных языков благодаря *Flask-Babel* , что позволит поддерживать столько языков, сколько я смогу найти переводчиков. Но, конечно, один элемент отсутствует. Пользователи будут писать сообщения в блогах на своих родных языках. Поэтому вполне возможно, что пользователь столкнется с постами, которые написаны на неизвестных ему языках. Качество автоматизированных переводов не всегда велико, но в большинстве случаев это достаточно хорошо, если все, что вы хотите, --- иметь базовое представление о том, что означает текст на другом языке.

Это идеальная возможность для реализации службы AJAX. Учтите, что страницы index или explore могут показывать несколько сообщений, некоторые из которых могут быть на иностранных языках. Если я реализую перевод с использованием традиционных методов на стороне сервера, запрос на перевод приведет к замене исходной страницы новой страницей. Дело в том, что запрос на перевод одного из многих отображаемых сообщений в блогах не является достаточно большим, чтобы требовать полного обновления страницы, эта функция работает намного лучше, если переведенный текст динамически вставляется под исходным текстом, оставляя остальную часть страницы нетронутой.

Для реализации автоматизированных переводов в реальном времени требуется несколько шагов. Во-первых, мне нужен способ определить исходный язык текста для перевода. Мне также нужно знать предпочтительный язык для каждого пользователя, потому что я хочу показать ссылку «перевести» только для сообщений, написанных на других языках. Когда будет предложена ссылка на перевод и пользователь нажмет на нее, мне нужно будет отправить AJAX-запрос на сервер, и сервер свяжется с сторонним API перевода. После того как сервер отправит ответ с переведенным текстом, клиентский код javascript будет динамически вставлять этот текст в страницу. Как вы наверняка заметили, тут несколько нетривиальных проблем. Рассмотрим их одну за другой.

### Language Identification

Первой проблемой является определение того, на каком языке была написана запись. Это не точная наука, поскольку не всегда можно однозначно определить язык, но в большинстве случаев автоматическое обнаружение работает достаточно хорошо. В Python есть хорошая библиотека регистрации языка, называемая `guess_language` . Оригинальная версия этого пакета довольно старая и никогда не была перенесена на Python 3, поэтому я собираюсь установить производную версию, которая поддерживает Python 2 и 3:

    (venv) $ pip install guess-language_spirit

План состоит в том, чтобы скормить каждый пост в блоге этому пакету, чтобы попытаться определить язык. Поскольку этот анализ занимает много времени, я не хочу повторять эту работу каждый раз, когда сообщение отображается на странице. То, что я собираюсь сделать, --- это установить исходный язык для сообщения во время его отправки. Обнаруженный язык затем будет храниться в таблице Posts.

Первым шагом является добавление поля `language` в модель `Post` :

> *app/models.py* : Add detected language to Post model.

    class Post(db.Model):
        # ...
        language = db.Column(db.String(5))

Как вы помните, каждый раз, когда происходят изменения в моделях баз данных, необходимо выполнить миграцию базы данных:

    (venv) $ flask db migrate -m "add language to posts"
    INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
    INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
    INFO  [alembic.autogenerate.compare] Detected added column 'post.language'
      Generating migrations/versions/2b017edaa91f_add_language_to_posts.py ... done

Затем необходимо применить миграцию к базе данных:

    (venv) $ flask db upgrade
    INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
    INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
    INFO  [alembic.runtime.migration] Upgrade ae346256b650 -> 2b017edaa91f, add language to posts

Теперь я могу обнаружить и сохранить язык при отправке сообщения:

> *app/routes.py* : Save language for new posts.

    from guess_language import guess_language

    @app.route('/', methods=['GET', 'POST'])
    @app.route('/index', methods=['GET', 'POST'])
    @login_required
    def index():
        form = PostForm()
        if form.validate_on_submit():
            language = guess_language(form.post.data)
            if language == 'UNKNOWN' or len(language) > 5:
                language = ''
            post = Post(body=form.post.data, author=current_user,
                        language=language)
            # ...

При этом изменении каждый раз, когда отправляется сообщение, я пропускаю текст через функцию `guess_language` , чтобы попытаться определить язык. Если язык возвращается как unknown (неизвестно) или я получаю неожиданно длинный результат, я перестраховываюсь и сохраняю пустую строку в базе данных. Я собираюсь принять соглашение о том, что любое сообщение, у которого есть язык, с присвоенным значением пустая строка, то предполагается, что у него неизвестный язык.

### Отображение ссылки «Перевести»

Второй шаг очень прост. Я добавлю ссылку «Перевести» рядом с любыми сообщениями, которые отличаются от языка, который активен для текущего пользователя.

> *`app/templates/_post.html`* : Add a translate link to posts.

    {% if post.language and post.language != g.locale %}
    <br><br>
    <a href="#">{{ _('Translate') }}</a>
    {% endif %}

Я делаю это в подшаблоне *`_post.html`* , так чтобы эта функциональность отображалась на любой странице, отображающей записи блога. Ссылка на перевод будет отображаться только на сообщениях, для которых был обнаружен язык, и этот язык не соответствует языку, выбранному функцией, декорированной `localeselector` Flask-Babel. Напомним из [главы 13](https://habrahabr.ru/post/350148/) , что выбранная локаль хранится как `g.locale` . Текст ссылки должен быть добавлен таким образом, что он может быть переведен Flask-Babel, поэтому я использую функцию `_()` , для её определения.

Обратите внимание, что я еще не связал действие с этой ссылкой. Сначала я хочу выяснить, как выполнять фактические переводы.

### Использование сторонней службы перевода

Двумя основными службами перевода являются [Google Cloud Translation API](https://developers.google.com/translate/) и [Microsoft Translator Text API](http://www.microsofttranslator.com/dev/) . Обе платные услуги, но предложение Microsoft имеет опцию начального уровня для небольшого объема переводов, что является бесплатным. Google предлагал бесплатную услугу перевода в прошлом, но сегодня, даже самый низкий уровень обслуживания оплачивается. Поскольку я хочу иметь возможность экспериментировать с переводами, не неся расходов, я собираюсь реализовать решение Microsoft.

> *Прим. Перводчика:* Есть еще [Yandex](https://tech.yandex.ru/translate/) о котором Мигель, похоже не знает. Не самый плохой API! Есть [бесплатный вариант](https://translate.yandex.ru/developers/offer) до 1 М символов в день и 10 М в месяц против 2 М в месяц у микрософта.

Прежде чем использовать Microsoft Translator API, необходимо получить учетную запись в Azure, облачной службы Майкрософт. Вы можете выбрать уровень Free, во время предложения предоставить номер кредитной карты в процессе регистрации. Плата с вашей картой не будет взиматься, пока вы остаетесь на этом уровне обслуживания.

После того как у вас появится учетная запись Azure, перейдите на портал Azure и нажмите кнопку \"New\" в левом верхнем углу, а затем введите или выберите \"Translator Text API\". При нажатии кнопки \"Create\" вам будет представлена форма, в которой вы определите новый ресурс транслятора, который будет добавлен в ваш аккаунт. Ниже вы можете увидеть, как я заполнил форму:

![](https://habrastorage.org/webt/qa/6q/x7/qa6qx73esifdx2hwag2igcskc1i.png)

При повторном нажатии кнопки \"Create\" ресурс API-интерфейса переводчика будет добавлен в ваш аккаунт. Если вы подождете несколько секунд, вы получите уведомление в строке сверху панели, что переводчик был развернут. Нажмите кнопку \"Go to resource\" в уведомлении, а затем на \"Keys\" опцию на левой боковой панели. Теперь вы увидите два ключа, помеченные как \"Key 1\" и \"Key 2\". Скопируйте один из ключей в буфер обмена, а затем введите его в переменную среды в вашем терминале (если вы используете Microsoft Windows, замените `export` на `set` ):

    (venv) $ export MS_TRANSLATOR_KEY=<paste-your-key-here>

Этот ключ используется для аутентификации с помощью службы перевода, поэтому его необходимо добавить в конфигурацию приложения:

> *config.py* : Add Microsoft Translator API key to the configuration.

    class Config(object):
        # ...
        MS_TRANSLATOR_KEY = os.environ.get('MS_TRANSLATOR_KEY')

Как всегда со значениями конфигурации, я предпочитаю устанавливать их в переменные окружения и импортировать их в конфигурацию Flask оттуда. Это особенно важно при наличии конфиденциальной информации, такой как ключи или пароли, которые обеспечивают доступ к службам сторонних производителей. Вы определенно не хотите писать их явно в коде.

Microsoft Translator API-это веб-служба, которая принимает запросы HTTP. В Python есть несколько HTTP-клиентов, но самым популярным и простым в использовании является пакет `requests` . Давайте установим его в виртуальную среду:

    (venv) $ pip install requests

Ниже вы можете увидеть функцию, которую я кодировал для перевода текста с помощью API-интерфейса Microsoft Translator. Я добавляю новый модуль *app/translate.py* :

> *app/translate.py* : Text translation function.

    import json
    import requests
    from flask_babel import _
    from app import app

    def translate(text, source_language, dest_language):
        if 'MS_TRANSLATOR_KEY' not in app.config or \
                not app.config['MS_TRANSLATOR_KEY']:
            return _('Error: the translation service is not configured.')
        auth = {'Ocp-Apim-Subscription-Key': app.config['MS_TRANSLATOR_KEY']}
        r = requests.get('https://api.microsofttranslator.com/v2/Ajax.svc'
                         '/Translate?text={}&from={}&to={}'.format(
                             text, source_language, dest_language),
                         headers=auth)
        if r.status_code != 200:
            return _('Error: the translation service failed.')
        return json.loads(r.content.decode('utf-8-sig'))

Функция принимает текст для перевода, а исходный и целевой языки кодируются как аргументы, и возвращает строку с переведенным текстом. Действие начинается с проверки наличия ключа для службы перевода в конфигурации, и если он не существует, то возвращает ошибку. Ошибка также является строкой, поэтому со стороны это будет выглядеть как переведенный текст. Это гарантирует, что в случае ошибки пользователь увидит сообщение об ошибке.

Метод `get()` из пакета `requests` отправляет HTTP-запрос с методом `GET` на URL-адрес, указанный в качестве первого аргумента. Я использую URL */v2/Ajax.svc/Translate* , который является конечной точкой службы перевода, которая возвращает переводы в качестве данных JSON. Текстовые, исходный и целевой языки должны указываться в качестве аргументов строки запроса в URL-адресе с именем `text` , `from` и `to` соответственно. Чтобы выполнить аутентификацию с помощью службы, мне нужно передать ключ, который я добавил в конфигурацию. Этот ключ необходимо указать в пользовательском HTTP-заголовке с именем `Ocp-Apim-Subscription-Key` . Я создал словарь `auth` с этим заголовком, а затем передал его запросам в `headers` аргументе.

Метод `requests.get()` возвращает объект response, содержащий все сведения, предоставленные службой. Сначала нужно проверить, что код состояния 200, который является кодом успешного запроса. Если я получаю другие коды, значит, произошла ошибка, поэтому в этом случае я возвращаю строку ошибки. Если код состояния 200, то тело ответа имеет строку в кодировке JSON с переводом, поэтому все, что мне нужно сделать, это использовать функцию `json.loads()` из стандартной библиотеки Python для декодирования JSON в строку Python, которую я мог бы использовать. Атрибут объекта ответа `content` содержит необработанный текст ответа в качестве байтстроки, который преобразовывается в строку utf-8 и отправил в `json.loads()` .

Ниже вы можете увидеть сеанс консоли Python, в котором я использую новую функцию `translate()` :

    >>> from app.translate import translate
    >>> translate('Hi, how are you today?', 'en', 'es')  # English to Spanish
    'Hola, ¿cómo estás hoy?'
    >>> translate('Hi, how are you today?', 'en', 'de')  # English to German
    'Are Hallo, how you heute?'
    >>> translate('Hi, how are you today?', 'en', 'it')  # English to Italian
    'Ciao, come stai oggi?'
    >>> translate('Hi, how are you today?', 'en', 'fr')  # English to French
    "Salut, comment allez-vous aujourd'hui ?"

Довольно круто, правда? Теперь пришло время интегрировать эту функциональность с приложением.

### Ajax From The Server

Я начну с реализации серверной части. Когда пользователь нажимает ссылку «Перевести», которая появляется под сообщением, на сервер выдается асинхронный HTTP-запрос. Я покажу вам, как это сделать в следующем сеансе, поэтому на данный момент я сосредоточусь на реализации обработки этого запроса сервером.

Асинхронный (или Ajax) запрос похож на маршруты и функции просмотра, которые я создал в приложении, с той лишь разницей, что вместо возврата HTML или перенаправления он просто возвращает данные, отформатированные как [XML](http://en.wikipedia.org/wiki/XML) или чаще [JSON](http://en.wikipedia.org/wiki/JSON) . Ниже вы можете увидеть функцию просмотра перевода, которая вызывает API-интерфейс Microsoft Translator, а затем возвращает переведенный текст в формате JSON:

> *app/routes.py* : Text translation view function.

    from flask import jsonify
    from app.translate import translate

    @app.route('/translate', methods=['POST'])
    @login_required
    def translate_text():
        return jsonify({'text': translate(request.form['text'],
                                          request.form['source_language'],
                                          request.form['dest_language'])})

Как вы можете видеть, это просто. Я выполнил этот маршрут как запрос `POST` . Нет абсолютного правила относительно того, когда следует использовать `GET` или `POST` (или другие методы запросов, которые вы еще не видели). Поскольку клиент будет отправлять данные, я решил использовать запрос `POST` , так как это похоже на запросы, которые представляют данные формы. Атрибут `request.form` --- это словарь, который Flask предоставляет со всеми данными, включенными в представление. Когда я работал с веб-формами, мне не нужно было искать `request.form` , потому что Flask-WTF делает все, что бы работало как надо, но в этом случае на самом деле нет веб-формы, поэтому мне приходится напрямую обращаться к данным.

Итак, разберем что я делаю в этой функции. Вызывается функция `translate()` из предыдущего раздела и с ней передаются три аргумента непосредственно из данных, которые были отправлены с запросом. Результат включается в словарь с одним единственным ключом под именем `text` , а словарь передается как аргумент функции `jsonify()` Flask, которая преобразует словарь в форматированную полезную нагрузку JSON. Возвращаемое значение из `jsonify()` --- это ответ HTTP, который будет отправлен обратно клиенту.

Например, если клиент хочет перевести строку `Hello, World!` на испанский язык ответ от этого запроса будет иметь следующие полезные данные:

    { "text": "Hola, Mundo!" }

### Ajax From The Client

Итак, теперь, когда сервер может предоставлять переводы через URL */translate* , мне нужно вызвать этот URL-адрес, когда пользователь жмакает ссылку «Перевести», которую я добавил выше, передавая текст для перевода, а также исходный и целевой языки. Если вы не знакомы с работой с JavaScript в браузере, это будет хороший опыт обучения.

При работе с JavaScript в браузере отображаемая в данный момент страница внутренне представлена ​​в виде объектной модели документа или только DOM. Это иерархическая структура, ссылающаяся на все элементы, существующие на странице. Код JavaScript, работающий в этом контексте, может вносить изменения в DOM, чтобы инициировать изменения на странице.

Давайте сначала обсудим, как мой JavaScript-код, запущенный в браузере, может получить три аргумента, которые мне нужно отправить в функцию перевода, которая выполняется на сервере. Чтобы получить текст, мне нужно найти узел в DOM, который содержит тело сообщения блога и прочитать его содержимое. Чтобы упростить идентификацию узлов DOM, содержащих записи в блоге, я собираюсь добавить к ним уникальный идентификатор. Если вы посмотрите на шаблон *\_post.html* , строка, отображающая тело сообщения, просто читает `{{post.body}}` . Я собираюсь обернуть это содержимое в элементе `<span>` . Это ничего не изменит визуально, но это дает мне место, где я могу вставить идентификатор:

> *`app/templates/_post.html`* : Add an ID to each blog post.

                <span id="post{{ post.id }}">{{ post.body }}</span>

Это присвоит уникальный идентификатор каждому сообщению в блоге в формате `post1` , `post2` и т.д., где число соответствует идентификатору базы данных для каждого сообщения. Теперь, когда каждый пост в блоге имеет уникальный идентификатор, учитывая значение ID, я могу использовать jQuery для поиска элемента `<span>` для этого сообщения и извлечения текста в нем. Например, если бы я хотел получить текст для сообщения с ID 123, вот, что я сделал бы:

    $('#post123').text()

Здесь знак `$` --- это имя функции, предоставляемой библиотекой jQuery. Эта библиотека используется Bootstrap, поэтому она уже была включена в Flask-Bootstrap. `#` является частью синтаксиса «селектор», используемого jQuery, что означает, что следующим является идентификатор элемента.

Я также хочу иметь место, куда я буду вставлять переведенный текст после получения его с сервера. Поскольку я собираюсь заменить ссылку «Перевести» на переведенный текст, то мне также нужно иметь уникальный идентификатор для этого узла:

> *`app/templates/_post.html`* : Добавляю идентификатор в ссылку перевести.

                <span id="translation{{ post.id }}">
                    <a href="#">{{ _('Translate') }}</a>
                </span>

Итак, теперь для данного ID записи у меня есть `post<ID>` для сообщения в блоге и соответствующий узел `translation<ID>` , где мне нужно будет заменить ссылку «Перевод» на переведенный текст, как только я его получу.

Следующий шаг --- написать функцию, которая может выполнять всю работу по переводу. Эта функция будет принимать входные и выходные узлы DOM, а также исходный и конечный языки, выдавать асинхронный запрос на сервер с тремя необходимыми аргументами и, наконец, заменять ссылку «Перевод» переведенным текстом после ответа сервера. Это звучит как большая работа, но реализация довольно проста:

> *app/templates/base.html* : Функция перевода на стороне клиента.

    {% block scripts %}
        ...
        <script>
            function translate(sourceElem, destElem, sourceLang, destLang) {
                $(destElem).html('<img src="{{ url_for('static', filename='loading.gif') }}">');
                $.post('/translate', {
                    text: $(sourceElem).text(),
                    source_language: sourceLang,
                    dest_language: destLang
                }).done(function(response) {
                    $(destElem).text(response['text'])
                }).fail(function() {
                    $(destElem).text("{{ _('Error: Could not contact server.') }}");
                });
            }
        </script>
    {% endblock %}

Первые два аргумента --- это уникальные ID для сообщений и узлов перевода. Последние два аргумента --- это коды исходного и целевого языков.

Функция начинается с приятного штриха: она добавляет *spinner* , заменяющий ссылку «Перевод», чтобы пользователь знал, что перевод выполняется. Это делается с помощью jQuery, используя функцию `$(destElem).html()` , чтобы заменить исходный HTML, который определил ссылку на перевод с новым содержимым HTML на основе ссылки `<img>` . Для spinner-а я собираюсь использовать небольшой анимированный GIF-чик, который я добавил в каталог *app/static/loading.gif* , который Flask резервирует для статических файлов. Чтобы сгенерировать URL-адрес, ссылающийся на этот образ, я использую функцию `url_for()` , передавая специальное имя маршрута `static` и давая имя файла в качестве аргумента. Вы можете найти изображение load.gif в [пакете загрузки](https://github.com/miguelgrinberg/microblog/tree/v0.14) для этой главы.

Так что теперь у меня есть приличный таймер-спиннер, который заменил ссылку «Перевести» и пользователь теперь знает, что нужно подождать, пока появится перевод.

Следующий шаг --- отправить запрос `POST` на URL */translate* , который я определил в предыдущем разделе. Для этого я также собираюсь использовать jQuery, в этом случае функцию `$.post()` . Эта функция передает данные на сервер в формате, аналогичном тому, как браузер отправляет веб-форму, что удобно, потому что это позволяет Flask включать эти данные в словарь `request.form` . Два аргументы `$.post()` --- это, сначала URL для отправки запроса, а затем словарь (или объект, поскольку они вызываются в JavaScript) с тремя элементами данных, которые ожидает сервер.

Вы, наверное, знаете, что JavaScript много работает с функциями обратного вызова или более продвинутой формой обратных вызовов, называемых `promises` . То, что я хочу сделать сейчас, это побещать, что я сделаю, когда этот запрос завершится и браузер получит ответ. В JavaScript нет такого понятия, как ожидание чего-либо, все асинхронно. Вместо этого необходимо предоставить функцию обратного вызова, которую обозреватель будет вызывать при получении ответа. А также как способ сделать все как можно более надежным, я хочу указать, что делать в случае, если вдруг возникла ошибка, так что второй функцией обратного вызова будет обработка ошибок. Существует несколько способов указать эти обратные вызовы, но в этом случае использование promises делает код достаточно ясным. Синтаксис выглядит следующим образом:

    $.post(<url>, <data>).done(function(response) {
        // success callback
    }).fail(function() {
        // error callback
    })

Синтаксис promise позволяет Вам в основном \"цеплять\" обратные вызовы к возвращаемому значению вызова `$.post()` . При успешном обратном вызове все, что мне нужно сделать, это вызвать `$(destElem).text()` с переведенным текстом, который приходит в словарь под ключ `text` . В случае ошибки я делаю то же самое, но текст, который я покажу, будет общим сообщением об ошибке, которое, я уверен, вводится в базовый шаблон в качестве текста, который можно перевести.

Итак, теперь остается только вызвать функцию `translate()` с правильными аргументами в результате нажатия пользователем ссылки «Перевести». Есть также несколько способов сделать это. То, что я собираюсь сделатьм- это, просто встроить вызов функции в атрибут `href` ссылки:

> *`app/templates/_post.html`* : Translate link handler.

                <span id="translation{{ post.id }}">
                    <a href="javascript:translate(
                                '#post{{ post.id }}',
                                '#translation{{ post.id }}',
                                '{{ post.language }}',
                                '{{ g.locale }}');">{{ _('Translate') }}</a>
                </span>

Элемент `href` ссылки может принимать любой код JavaScript, если он имеет префикс `javascript:` , так что это удобный способ сделать вызов функции перевода. Поскольку эта ссылка будет отображаться на сервере, когда клиент запрашивает страницу, я могу использовать выражения `{{ }}` для генерации четырех аргументов функции. Каждое сообщение будет иметь свою собственную переводную ссылку с ее уникальными аргументами. `#` , который вы видите в качестве префикса для элементов `post<ID>` и `translation<ID>` , указывает, что следующим является ID элемента.

Now the live translation feature is complete! If you have set a valid Microsoft Translator API key in your environment, you should now be able to trigger translations. Assuming you have your browser set to prefer English, you will need to write a post in another language to see the \"Translate\" link. Below you can see an example:

Теперь функция перевода в реальном времени завершена! Если вы установили валидный ключ Microsoft Translator API в своей среде, то теперь вы сможете запускать переводы. Если ваш браузер настроен на предпочтительный английский, вам нужно будет написать сообщение на другом языке, чтобы увидеть ссылку \"перевести\". Ниже вы можете увидеть пример:

![](https://habrastorage.org/webt/jt/mc/dw/jtmcdw1fcyc7zmlvxhhxb_pjcym.png)

В этой главе я представил несколько новых текстов, которые необходимо перевести на все языки, поддерживаемые приложением, поэтому необходимо обновить каталоги переводов:

    (venv) $ flask translate update

Для ваших собственных проектов вам необходимо будет отредактировать файлы messages.po в каждом репозитории языков, чтобы включить переводы для этих новых тестов, но я уже создал испанский перевод в пакете загрузки для этой главы или в репозитории GitHub.

Чтобы опубликовать новые переводы, их необходимо скомпилировать:

    (venv) $ flask translate compile
:::

Глава 15: Улучшение структуры приложения
----------------------------------------

::: {#post-content-body .post__text .post__text-html io-article-url="https://habr.com/ru/post/351218/"}
### Текущие Ограничения

В текущем состоянии приложения есть две основные проблемы. Если вы посмотрите, как структурировано приложение, вы заметите, что существует несколько разных подсистем, которые могут быть идентифицированы, но код, который их поддерживает, весь перемешан, без каких-либо четких границ. Давайте рассмотрим, что это за подсистемы:

-   Подсистема аутентификации пользователя, которая включает некоторые функции просмотра в *app/routes.py* , некоторые формы в *app/forms.py* , некоторые шаблоны в *app/templates* и поддержку электронной почты в *app/email.py* .
-   Подсистема ошибок, которая определяет обработчики ошибок в *app/errors.py* и шаблоны в *app/templates* .
-   Основные функциональные возможности приложения, которые включают в себя отображение и запись сообщений в блогах, профилей пользователей и последующих событий, а также \"живые\" переводы сообщений в блогах, которые распределены в большом числе модулей приложений и шаблонов.

Думая об этих трех подсистемах, которые я определил, и о том, как они структурированы, вы, вероятно, можете заметить закономерность. До сих пор логика организации, которой я следовал, основана на наличии модулей, посвященных различным функциям приложения. Есть модуль для функций просмотра, еще один для веб-форм, один для ошибок, один для писем, каталог для HTML шаблонов и так далее. Хотя это структура, которая имеет смысл для небольших проектов, как только проект начинает расти, он имеет тенденцию делать некоторые из этих модулей действительно большими и грязными.

Один из способов четко увидеть проблему --- рассмотреть, как вы начнете второй проект, повторно используя столько, сколько сможете из первого. Например, часть отвечающая за проверку подлинности пользователя должна хорошо работать и в других приложениях. Но если вы хотите использовать этот код как есть, вам придется перейти в несколько модулей и скопировать/вставить соответствующие разделы в новые файлы в новом проекте. Видишь, как это неудобно? Не было бы лучше, если бы этот проект имел все файлы, связанные с аутентификацией, отделенные от остальной части приложения? *blueprints* особенность Flask помогает достичь более практичной организации, которая упрощает повторное использование кода.

Вторая проблема не столь очевидна. Экземпляр приложения Flask создается как глобальная переменная в *`app/__init__.py`* , а затем импортируется множеством модулей приложений. Хотя это само по себе не является проблемой, использование приложения в качестве глобальной переменной может усложнить некоторые сценарии, в частности связанные с тестированием. Представьте, что вы хотите протестировать это приложение в разных конфигурациях. Поскольку приложение определено как глобальная переменная, на самом деле невозможно создать экземпляр двух приложений, использующих разные переменные конфигурации. Другая ситуация, которая не является идеальной, заключается в том, что все тесты используют одно и то же приложение, поэтому тест может вносить изменения в приложение, которые влияют на другой тест, который выполняется позже. В идеале вы хотите, чтобы все тесты выполнялись на первозданном экземпляре приложения.

Фактически вы можете увидеть все это в модуле *tests.py* . Я прибегаю к трюку изменения конфигурации после того, как она была установлена ​​в приложении, чтобы направить тесты на использование базы данных в памяти вместо базы данных SQLite (по умолчанию) на основе диска. У меня нет другого способа изменить настроенную базу данных, потому что к моменту запуска тестов приложение было уже создано и настроено. Для этой конкретной ситуации изменение конфигурации после того, как она была применена к приложению, кажется, работает нормально, но в других случаях это не поможет, и в любом случае это плохая практика, которая может привести к неясным и трудным для поиска ошибкам.

Лучшим решением было бы не использовать глобальную переменную для приложения, а вместо этого использовать функцию *application factory* для создания функции во время выполнения. Это будет функция, которая принимает объект конфигурации в качестве аргумента и возвращает экземпляр приложения Flask, сконфигурированный этими настройками. Если бы я мог модифицировать приложение для работы с функцией фабрики приложений, то писать тесты, требующие специальной настройки, стало бы проще, потому что каждый тест мог создать свое собственное приложение.

В этой главе я собираюсь реорганизовать приложение введением схемы элементов для трех подсистем, указанных выше, и функции фабрики приложений. Показать вам подробный список изменений будет нецелесообразно, потому что есть небольшие изменения в почти каждом файле, который является частью приложения, поэтому я собираюсь обсудить шаги, которые я предпринял, чтобы сделать рефакторинг, и вы можете [загрузить](https://github.com/miguelgrinberg/microblog/archive/v0.15.zip) приложение с этими изменениями.

### Blueprints

В Flask проект представляет собой логическую структуру, которая представляет собой подмножество приложения. Проект может включать такие элементы, как маршруты, функции просмотра, формы, шаблоны и статические файлы. Если вы пишете свой проект в отдельном пакете Python, у вас есть компонент, который инкапсулирует элементы, относящиеся к определенной функции приложения.

Содержимое схемы элементов изначально находится в состоянии покоя. Чтобы связать эти элементы, необходимо зарегистрировать схему элементов в приложении. Во время регистрации все элементы, добавленные в схему элементов, передаются приложению. Таким образом, можно представить схему элементов как временное хранилище для функциональных возможностей приложения, которое помогает организовать код.

### Обработка ошибок Blueprint

Первая созданная мной схема элементов была инкапсулирована в поддержку обработчиков ошибок. Структура этой концепции такова:

    app/
        errors/                             <-- blueprint пакет
            __init__.py                     <-- blueprint создание
            handlers.py                     <-- error обработчики
        templates/
            errors/                         <-- error шаблоны
                404.html
                500.html
        __init__.py                         <-- blueprint регистрация

В сущности, я переместил модуль *app/errors.py* в *app/errors/handlers.py* и два шаблона ошибок в *app/templates/errors* , чтобы они были отделены от других шаблонов. Мне также пришлось изменить вызовы `render_template()` в обоих обработчиках ошибок, чтобы использовать подкаталог нового шаблона ошибок. После этого я добавил создание blueprint в модуль *`app/errors/__init__.py`* и регистрацию проекта в *`app/__init__.py`* после создания экземпляра приложения.

Я должен отметить, что схемы элементов Flask могут быть настроены на отдельный каталог для шаблонов или статических файлов. Я решил переместить шаблоны в подкаталог каталога шаблонов приложения, чтобы все шаблоны находились в одной иерархии, но если вы предпочитаете иметь шаблоны, принадлежащие схеме элементов внутри пакета схемы элементов, это поддерживается. Например, если добавить аргумент `template_folder= 'templates'` в конструктор `Blueprint()` , можно сохранить шаблоны схемы элементов в *app/errors/templates* .

Создание схемы элементов сильно похоже на создание приложения. Это делается в модуле `__init__.py` пакета blueprint:

> *`app/errors/__init__.py`* : Errors blueprint.

    from flask import Blueprint

    bp = Blueprint('errors', __name__)

    from app.errors import handlers

Класс `Blueprint` принимает имя схемы элементов, имя базового модуля (обычно устанавливается в `__name__` , как в экземпляре приложения Flask), и несколько необязательных аргументов, которые в этом случае мне не нужны. После создания объекта схемы элементов я импортирую *handlers.py* модуль, чтобы обработчики ошибок в нем были зарегистрированы в схеме элементов. Этот импорт находится внизу, чтобы избежать циклических зависимостей.

В модуле *handlers.py* вместо прикрепления обработчиков ошибок к приложению с помощью декоратора `@app.errorhandler` я использую blueprint-декоратор `@bp.app_errorhandler` . Хотя оба декоратора достигают одного и того же конечного результата, идея состоит в том, чтобы попытаться сделать схему элементов независимой от приложения, чтобы она была более портативной. Мне также нужно изменить путь к двум шаблонам ошибок, чтобы учесть новый подкаталог ошибок, в который они были перемещены.

Последним шагом для завершения рефакторинга обработчиков ошибок является регистрация схемы элементов в приложении:

> *`app/__init__.py`* : регистрация схемы элементов в приложении.

    app = Flask(__name__)

    # ...

    from app.errors import bp as errors_bp
    app.register_blueprint(errors_bp)

    # ...

    from app import routes, models  # <-- удалите ошибки из этого импорта!

Для регистрации схемы элементов используется метод `register_blueprint()` экземпляра приложения Flask. При регистрации схемы элементов все функции представления, шаблоны, статические файлы, обработчики ошибок и т. д. подключаются к приложению. Я помещаю импорт схемы элементов прямо над `app.register_blueprint()` , чтобы избежать циклических зависимостей.

### Аутентификация Blueprint

Процесс рефакторинга функций аутентификации приложения в проект довольно похож на процесс обработки обработчиков ошибок. Вот схема рефакторинга:

    app/
        auth/                               <-- blueprint пакет
            __init__.py                     <-- blueprint создание
            email.py                        <-- authentication emails
            forms.py                        <-- authentication forms
            routes.py                       <-- authentication routes
        templates/
            auth/                           <-- blueprint шаблоны
                login.html
                register.html
                reset_password_request.html
                reset_password.html
        __init__.py                         <-- blueprint регистрация

Чтобы создать этот проект, мне пришлось перенести все функции, связанные с проверкой подлинности, в новые модули, которые я создал в проекте. Это включает в себя несколько функций просмотра, веб-форм и функций поддержки, таких как функция, которая отправляет маркеры сброса пароля по электронной почте. Я также переместил шаблоны в подкаталог, чтобы отделить их от остальной части приложения, как это было со страницами ошибок.

При определении маршрутов в схеме элементов использует декоратор `@bp.route` вместо `@app.route` . Также требуется изменение синтаксиса, используемого в `url_for()` для создания URL-адресов. Для обычных функций просмотра, прикрепленных непосредственно к приложению, первым аргументом `url_for()` является имя функции представления. Если маршрут определен в схеме элементов, этот аргумент должен включать имя схемы элементов и имя функции представления, разделенные точкой. Так, например, мне пришлось заменить все вхождения `url_for('login')` на `url_for('auth.логин')` , и то же самое для остальных функций представления.

Чтобы зарегистрировать схему элементов `auth` в приложении, я использовал несколько другой формат:

> *`app/__init__.py`* : Зарегистрируйте схему элементов проверки подлинности в приложении.

    # ...
    from app.auth import bp as auth_bp
    app.register_blueprint(auth_bp, url_prefix='/auth')
    # ...

Вызов `register_blueprint()` в этом случае имеет дополнительный аргумент `url_prefix` . Это совершенно необязательно, но Flask дает вам возможность присоединить схему элементов под префиксом URL, поэтому любые маршруты, определенные в схеме элементов, получают этот префикс в своих URL. Во многих случаях это полезно как своего рода\" пространство имен\", которое отделяет все маршруты в схеме элементов от других маршрутов в приложении или других схемах элементов. Для аутентификации я подумал, что было бы неплохо иметь все маршруты, начинающиеся с *`/auth`* , поэтому я добавил префикс. Таким образом, теперь URL входа будет *<http://localhost:5000/auth/login>* . Поскольку я использую `url_for()` для генерации URL, все URL будут автоматически включать префикс.

### Основная схема элементов приложения

Третья схема элементов содержит основную логику приложения. Для рефакторинга этой схемы элементов требуется тот же процесс, что и для предыдущих двух схем элементов. Я дал этой схеме элементов имя `main` , поэтому все вызовы `url_for()` , ссылающиеся на функции представления, должны были получить `main` . префикс. Учитывая, что это основная функциональность приложения, я решил оставить шаблоны в тех же местах. Это не проблема, потому что я переместил шаблоны из двух других схем элементов в подкаталоги.

### Шаблон \"Фабрика\" приложений

Как я уже упоминал во введении к этой главе, наличие приложения в качестве глобальной переменной приводит к некоторым осложнениям, главным образом в виде ограничений для некоторых сценариев тестирования. Прежде чем я представил схемы элементов, приложение должно было быть глобальной переменной, потому что все функции представления и обработчики ошибок должны были быть декорированы функциями, которые находятся в `app` , такими как `@app.route` . Но теперь, когда все маршруты и обработчики ошибок были перемещены в схемы элементов, есть гораздо меньше причин, чтобы сохранить приложение глобальным.

Поэтому я собираюсь добавить функцию `create_app()` , которая создает экземпляр приложения Flask, и исключить глобальную переменную. Преобразование не было тривиальным, пришлось разобраться в нескольких сложностях, но давайте сначала рассмотрим функцию фабрики приложений:

> *`app/__init__.py`* : Application factory function.

    # ...
    db = SQLAlchemy()
    migrate = Migrate()
    login = LoginManager()
    login.login_view = 'auth.login'
    login.login_message = _l('Please log in to access this page.')
    mail = Mail()
    bootstrap = Bootstrap()
    moment = Moment()
    babel = Babel()

    def create_app(config_class=Config):
        app = Flask(__name__)
        app.config.from_object(config_class)

        db.init_app(app)
        migrate.init_app(app, db)
        login.init_app(app)
        mail.init_app(app)
        bootstrap.init_app(app)
        moment.init_app(app)
        babel.init_app(app)

        # ... нет изменений в blueprint registration

        if not app.debug and not app.testing:
            # ... нет изменений в logging setup

        return app

Вы видели, что большинство расширений Flask инициализируются путем создания экземпляра расширения и передачи приложения в качестве аргумента. Если приложение не существует в качестве глобальной переменной, существует альтернативный режим, в котором расширения инициализируются в два этапа. Экземпляр расширения сначала создается в глобальной области, как и раньше, но аргументы ему не передаются. При этом создается экземпляр расширения, который не присоединен к приложению. Во время создания экземпляра приложения в функции factory необходимо вызвать метод `init_app()` в экземпляре расширения, чтобы привязать его к известному приложению.

Другие задачи, выполняемые при инициализации, остаются неизменными, но переносятся на factory-функцию вместо того, чтобы находиться в глобальной области. Это включает в себя регистрацию схемы элементов и конфигурацию протоколирования. Обратите внимание, что я добавил условие `not app.testing` к условию, которое решает, нужно ли включать или отключать ведение журнала электронной почты и файлов, чтобы все эти протоколирования пропускались во время модульных тестов. Флаг `app.testing` будет `True` при выполнении модульных тестов из-за того, что переменная `TESTING` установлена ​​в `True` в конфигурации.

Итак, кто вызывает функцию фабрики приложений? Очевидным местом для использования этой функции является скрипт верхнего уровня *microblog.py* , который является единственным модулем, в котором приложение теперь существует в глобальной области. Другое место --- в *test.py* , и я буду обсуждать модульное тестирование более подробно в следующем разделе.

Как я уже упоминал выше, большинство ссылок на приложение ушли с введением схемы элементов, но некоторые из них все еще присутствуют в коде, который я должен рассмотреть. Например, все приложения *app/models.py* , *app/translate.py* и *app/main/routes.py* имеют ссылки на `app.config` . К счастью, разработчики Flask попытались упростить функции просмотра для доступа к экземпляру приложения без необходимости импортировать его, как я делал до сих пор. Переменная `current_app` из Flask, представляет собой специальную «контекстную» переменную Flask, которая инициализирует приложение перед отправкой запроса. Вы уже видели другую переменную контекста раньше, `g` -переменную, в которой я храню текущую локаль. Эти две, вместе с `current_user` Flask-Login и еще нескольких других, которых вы еще не видели, являются условно «волшебными» переменными, поскольку они работают как глобальные переменные, но доступны только во время обработки запроса и только в потоке, который его обрабатывает.

Замена `app` переменной `current_app` в Flask устраняет необходимость импорта экземпляра приложения в качестве глобальной переменной. Я смог заменить все упоминания `app.config` на `current_app.config` без каких-либо трудностей с помощью простого поиска и замены.

*app/email.py* модуль представлял собой несколько большую проблему, поэтому мне пришлось использовать небольшой трюк:

> *app/email.py* : Передача экземпляра приложения другому потоку.

    from app import current_app

    def send_async_email(app, msg):
        with app.app_context():
            mail.send(msg)

    def send_email(subject, sender, recipients, text_body, html_body):
        msg = Message(subject, sender=sender, recipients=recipients)
        msg.body = text_body
        msg.html = html_body
        Thread(target=send_async_email,
               args=(current_app._get_current_object(), msg)).start()

В функции `send_email()` экземпляр приложения передается в качестве аргумента в фоновый поток, который затем доставляет электронное письмо без блокировки основного приложения. Использование `current_app` непосредственно в функции `send_async_email()` , которая работает как фоновый поток, не сработало бы, потому что `current_app` --- это переменная контекста, привязанная к потоку, который обрабатывает клиентский запрос. В другом потоке `current_app` не имеет назначенного значения. Передача `current_app` напрямую в качестве аргумента для объекта потока тоже не сработала бы, потому что `current_app` на самом деле является *proxy object* , который динамически сопоставляется с экземпляром приложения. Таким образом, передача прокси-объекта будет такой же, как использование `current_app` непосредственно в потоке. Мне нужно было сделать доступ к реальному экземпляру приложения, который хранится внутри прокси-объекта, и передать его в качестве аргумента приложения. Выражение `current_app._get_current_object()` извлекает фактический экземпляр приложения из объекта прокси, так что это то, что я передал потоку в качестве аргумента.

Еще один \"тяжелый случай\" --- это модуль *app/cli.py* , который реализует несколько команд быстрого доступа для управления языковыми переводами. В этом случае переменная `current_app` не работает, поскольку эти команды регистрируются при запуске, а не во время обработки запроса, который является единственным моментом, когда `current_app` может использоваться. Чтобы удалить ссылку на приложение в этом модуле, я прибегнул к другому трюку, который заключается в перемещении этих пользовательских команд внутри функции `register()` , которая принимает экземпляр `app` в качестве аргумента:

> *app/cli.py* : Регистрация пользовательских команд приложения.

    import os
    import click

    def register(app):
        @app.cli.group()
        def translate():
            """Translation and localization commands."""
            pass

        @translate.command()
        @click.argument('lang')
        def init(lang):
            """Initialize a new language."""
            # ...

        @translate.command()
        def update():
            """Update all languages."""
            # ...

        @translate.command()
        def compile():
            """Compile all languages."""
            # ...

Затем я вызвал эту функцию `register()` из *microblog.py* . Вот полный *microblog.py* после рефакторинга:

> *microblog.py* : Основной модуль приложения после рефакторинга.

    from app import create_app, db, cli
    from app.models import User, Post

    app = create_app()
    cli.register(app)

    @app.shell_context_processor
    def make_shell_context():
        return {'db': db, 'User': User, 'Post' :Post}

### Unit Testing Improvements

Как я намекнул в начале этой главы, большая часть работы, которую я проделал до сих пор, была направлена на улучшение рабочего процесса модульного тестирования. При выполнении модульных тестов необходимо убедиться, что приложение настроено таким образом, чтобы оно не мешало ресурсам разработки, таким как база данных.

Текущая версия *tests.py* прибегает к хитрости изменения конфигурации после того, как она была применена к экземпляру приложения, что является опасной практикой, поскольку не все типы изменений будут работать, если это сделано в последний момент. Я хочу, чтобы у меня была возможность указать мою конфигурацию тестирования, прежде чем она будет добавлена в приложение.

Функция `create_app()` теперь принимает класс конфигурации в качестве аргумента. По умолчанию используется класс `Config` определенный в *config.py* , но теперь я могу создать экземпляр приложения, который использует другую конфигурацию, просто передав новый класс в функцию фабрики. Вот пример класса конфигурации, который можно использовать для модульных тестов:

> *tests.py* : Конфигурация тестирования.

    from config import Config

    class TestConfig(Config):
        TESTING = True
        SQLALCHEMY_DATABASE_URI = 'sqlite://'

Здесь я создаю подкласс класса `Config` приложения и переопределяю конфигурацию SQLAlchemy для использования базы данных SQLite в памяти. Я также добавил атрибут `TESTING` со значением True, который в настоящее время мне не нужен, но может быть полезен, если приложение должно определить, выполняется ли оно в модульных тестах или нет.

Если вы помните, мои модульные тесты основывались на методах `setUp()` и `tearDown()` , которые автоматически вызываются платформой модульного тестирования для создания и уничтожения среды, подходящей для выполнения каждого теста. Теперь я могу использовать эти два метода для создания и уничтожения совершенно нового приложения для каждого теста:

> *tests.py* : Создание приложения для каждого теста.

    class UserModelCase(unittest.TestCase):
        def setUp(self):
            self.app = create_app(TestConfig)
            self.app_context = self.app.app_context()
            self.app_context.push()
            db.create_all()

        def tearDown(self):
            db.session.remove()
            db.drop_all()
            self.app_context.pop()

Новое приложение будет храниться в `self.app` , но создания приложения недостаточно, чтобы все работало. Рассмотрим инструкцию `db.create_all()` , которая создает таблицы базы данных. Экземпляр `db` должен знать, что такое экземпляр приложения, потому что ему нужно получить URI базы данных из `app.config` , но когда вы работаете с фабрикой приложений, вы на самом деле не ограничены одним приложением, может быть создано гораздо больше одного. Итак, как же `db` узнает, что должен использовать экземпляр `self.app` , который я только что создал?

Ответ находится в *контексте приложения* . Помните переменную `current_app` , которая каким-то образом выступает в качестве прокси для приложения, когда нет глобального приложения для импорта? Эта переменная ищет активный контекст приложения в текущем потоке, и если она находит его, то получает приложение из него. Если контекст отсутствует, значит невозможно узнать, какое приложение активно, поэтому `current_app` вызывает исключение. Ниже Вы можете увидеть, как это работает в консоли Python. Это должна быть именно консоль, запущенная с помощью `python` , потому что команда `flask shell` , для удобства, автоматически активирует контекст приложения.

    >>> from flask import current_app
    >>> current_app.config['SQLALCHEMY_DATABASE_URI']
    Traceback (most recent call last):
        ...
    RuntimeError: Working outside of application context.

    >>> from app import create_app
    >>> app = create_app()
    >>> app.app_context().push()
    >>> current_app.config['SQLALCHEMY_DATABASE_URI']
    'sqlite:////home/miguel/microblog/app.db'

Вот в чем секрет! Перед вызовом функций просмотра Flask вызывает контекст приложения, который возвращает `current_app` и `g` в жизнь. Когда запрос завершен, контекст удаляется вместе с этими переменными. Для вызова `db.create_all()` для работы с модулем тестирования метода `setUp()` я выдвинул контекст приложения для только что созданного экземпляра приложения, и таким образом `db.create_all()` может использовать `current_app.config` , чтобы узнать, где это база данных. Затем в методе `tearDown()` я вывожу контекст, чтобы сбросить все в чистое состояние.

Вы также должны знать, что контекст приложения является одним из двух контекстов, которые использует Flask. Существует также *request context* , что более конкретно, поскольку это относится к запросу. Когда контекст запроса активируется непосредственно перед обработкой запроса, становятся доступными переменные `request` и `session` Flask, а также `current_user` Flask-Login.

### Переменные окружения

Как вы возможно заметили, существует ряд вариантов конфигурации, которые зависят от наличия переменных, установленных в вашей среде, до того, как вы запустите сервер. Они включают в себя секретный ключ, информацию о сервере электронной почты, URL-адрес базы данных и ключ API Microsoft Translator. Вы, вероятно, согласитесь со мной в том, что это неудобно, потому что каждый раз, когда вы открываете новый сеанс терминала, эти переменные должны быть установлены снова.

Общим шаблоном для приложений, зависящих от множества переменных среды, является их сохранение в файле `.env` в корневом каталоге приложения. Приложение импортирует переменные в этот файл при его запуске, и таким образом нет необходимости вручную устанавливать все эти переменные вручную.

Есть пакет Python, который поддерживает *.env* файлы, называемые `python-dotenv` . Итак, давайте установим этот пакет:

    (venv) $ pip install python-dotenv

Поскольку модуль *config.py* --- это место, где я читаю все переменные среды, то следует импортировать файл *.env* до создания класса `Config` , чтобы переменные задавались при построении класса:

> *config.py* : Импорт файла .env в переменные окружения.

    import os
    from dotenv import load_dotenv

    basedir = os.path.abspath(os.path.dirname(__file__))
    load_dotenv(os.path.join(basedir, '.env'))

    class Config(object):
        # ...

Итак, теперь вы можете создать файл *.env* со всеми переменными среды, которые необходимы вашему приложению. Важно, чтобы вы не добавляли ваш *.env* -файл в систему управления версиями. Не стоит иметь файл, содержащий пароли и другую конфиденциальную информацию, включенный в репозиторий исходного кода.

Этот *.env* -файл можно использовать для всех переменных временной конфигурации, но его нельзя использовать для переменных среды `FLASK_APP` и `FLASK_DEBUG` , так как они необходимы уже в процессе начальной загрузки приложения, до того, как экземпляр приложения и его объект конфигурации появится.

В следующем примере показан файл *.env* , который определяет секретный ключ, настраивает электронную почту для выхода на локально выполняемый почтовый сервер на 25-м порту и без проверки подлинности, устанавливает ключ API Microsoft Translator и устанавливает конфигурацию базы данных для использования значений по умолчанию:

    SECRET_KEY=a-really-long-and-unique-key-that-nobody-knows
    MAIL_SERVER=localhost
    MAIL_PORT=25
    MS_TRANSLATOR_KEY=<your-translator-key-here>

### Файл Requirements

На данный момент я установил достаточное количество пакетов в виртуальной среде Python. Если вам когда-нибудь понадобится повторно создать среду на другом компьютере, у вас будут проблемы с запоминанием пакетов, которые вы должны были установить, поэтому общепринятой практикой является создание файла *requirements.txt* в корневой папке проекта с перечислением всех зависимостей и их версий. Создать этот список на самом деле легко:

    (venv) $ pip freeze > requirements.txt

Команда `pip freeze` создаст дамп всех пакетов, установленных в виртуальной среде, в формате, соответствующем файлу *requirements.txt* . Теперь, если вам нужно создать ту же виртуальную среду на другой машине, вместо установки пакетов по одному, вы можете запустить:

    (venv) $ pip install -r requirements.txt
:::

Глава 16: Полнотекстовый поиск
------------------------------

::: {#post-content-body .post__text .post__text-html io-article-url="https://habr.com/ru/post/351900/"}
### Введение в полнотекстовые поисковые системы

Поддержка полнотекстового поиска не стандартизирована, как реляционные базы данных. Существует несколько полнотекстовых движков с открытым исходным кодом: [Elasticsearch](https://www.elastic.co/products/elasticsearch) , [Apache Solr](http://lucene.apache.org/solr/) , [Whoosh](http://whoosh.readthedocs.io/) , [Xapian](https://xapian.org/) , [Sphinx](http://sphinxsearch.com/) и т.д. Как будто этого недостаточно! Есть несколько баз данных, которые также предоставляют возможности поиска, сравнимые с выделенными поисковыми системами, такими как те, которые я перечислил выше. [SQLite](https://www.sqlite.org/) , [MySQL](https://www.mysql.com/) и [PostgreSQL](https://www.postgresql.org/) предлагают некоторую поддержку для поиска текста, а также базы данных NoSQL, такие как [MongoDB](https://www.mongodb.com/) и [CouchDB](http://couchdb.apache.org/) .

Если вам интересно, какие из них могут работать в приложении Flask, ответ --- все они! Это одна из сильных сторон Flask, он делает свою работу и не упрямится. Так что это лучший выбор?

По моему мнению, из списка специализированных поисковых систем Elasticsearch --- особенно выделяется. И как самый популярный, и значимый стоит первым в качестве символа «E» в стеке ELK для индексирования логов, совместно с Logstash и Kibana. Использование возможностей поиска в одной из реляционных баз данных может быть хорошим выбором, но с учетом того факта, что SQLAlchemy не поддерживает эту функциональность, мне пришлось бы обрабатывать поиск с помощью необработанных SQL-инструкций или найти пакет с доступом к текстовым запросам, а также возможность совместного использования с SQLAlchemy.

Основываясь на выше сказанном, я выбираю Elasticsearch, но собираюсь реализовать все функции индексирования текста и поиска таким образом, чтобы очень легко переключиться на другой движок. Это позволит заменить мою реализацию альтернативной версией на основе другого механизма, просто переписав несколько функций в одном модуле.

Существует несколько способов установки Elasticsearch, включая установку в один клик или zip-файл с бинарниками, которые необходимо установить самостоятельно, и даже образ Docker. В [документации](https://www.elastic.co/guide/en/elasticsearch/reference/current/install-elasticsearch.html) есть страница установки с подробной информацией обо всех этих опциях. Если вы используете Linux, у вас, вероятно, будет доступный пакет для вашего дистрибутива. Если Вы используете Mac и у вас установлен Homebrew, то вы можете просто запустить `brew install elasticsearch` .

После установки Elasticsearch на компьютер можно проверить, работает ли он, введя `http://localhost:9200` в адресной строке браузера, которая должна возвращать некоторую основную информацию о сервисе в формате JSON.

Поскольку управляться Elasticsearch будет из Python, я буду использовать клиентскую библиотеку Python:

    (venv) $ pip install elasticsearch

Теперь не помешает обновить файл *requirements.txt* :

    (venv) $ pip freeze > requirements.txt

### Elasticsearch Tutorial

Для начала я покажу вам основы работы с Elasticsearch из оболочки Python. Это поможет вам ознакомиться с этим сервисом и понять его реализацию, о которой я расскажу позже.

Чтобы создать подключение к Elasticsearch, создайте экземпляр класса `Elasticsearch` , передав URL-адрес подключения в качестве аргумента:

    >>> from elasticsearch import Elasticsearch
    >>> es = Elasticsearch('http://localhost:9200')

Данные в Elasticsearch при записи *индексируются* . В отличие от реляционной базы данных, это всего лишь объект [JSON](http://www.json.org/) . Следующий пример записывает объект в поле типа `text` , под индексом `my_index` :

    >>> es.index(index='my_index', doc_type='my_index', id=1, body={'text': 'this is a test'})

При желании index может хранить документы разных типов, и в этом случае аргумент `doc_type` может быть установлен в разные значения в соответствии с этими различными форматами. Я собираюсь хранить все документы в том же формате, поэтому я устанавливаю тип документа равным имени индекса.

Для каждого сохраненного документа Elasticsearch получает уникальный идентификатор и объект JSON с данными.

Давайте сохраним второй документ по этому же индексу:

    >>> es.index(index='my_index', doc_type='my_index', id=2, body={'text': 'a second test'})

И теперь, когда в этом индексе есть два документа, я могу выполнить поиск в свободной форме. В этом примере я буду искать `this test` :

    >>> es.search(index='my_index', doc_type='my_index',
    ... body={'query': {'match': {'text': 'this test'}}})

Ответ `es.search()` представляет собой словарь Python с результатами поиска:

    {
        'took': 1,
        'timed_out': False,
        '_shards': {'total': 5, 'successful': 5, 'skipped': 0, 'failed': 0},
        'hits': {
            'total': 2, 
            'max_score': 0.5753642, 
            'hits': [
                {
                    '_index': 'my_index',
                    '_type': 'my_index',
                    '_id': '1',
                    '_score': 0.5753642,
                    '_source': {'text': 'this is a test'}
                },
                {
                    '_index': 'my_index',
                    '_type': 'my_index',
                    '_id': '2',
                    '_score': 0.25316024,
                    '_source': {'text': 'a second test'}
                }
            ]
        }
    }

Здесь видно, что поиск вернул два документа, каждый со своей оценкой. Документ с большей оценкой содержит два слова, которые я искал, а другой документ содержит только одно. Но, как вы видите, даже лучший результат не имеет большой балл, потому что слова не совсем соответствуют тексту.

Теперь посмотрим результат для поиска слова `second` :

    >>> es.search(index='my_index', doc_type='my_index',
    ... body={'query': {'match': {'text': 'second'}}})
    {
        'took': 1,
        'timed_out': False,
        '_shards': {'total': 5, 'successful': 5, 'skipped': 0, 'failed': 0},
        'hits': {
            'total': 1,
            'max_score': 0.25316024,
            'hits': [
                {
                    '_index': 'my_index',
                    '_type': 'my_index',
                    '_id': '2',
                    '_score': 0.25316024,
                    '_source': {'text': 'a second test'}
                }
            ]
        }
    }

Полученная оценка довольно низкая, потому что мой поиск не соответствует тексту в этом документе, но поскольку только один из двух документов содержит слово \"second\", другой документ вообще не отображается.

Объект запроса Elasticsearch имеет много параметров и все они хорошо [документированы](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-body.html) . Среди них такие, как разбиение на страницы и сортировка, так же, как и в случае реляционных баз данных.

Не стесняйтесь добавить больше записей в этот индекс и попробовать различные варианты поиска. Когда вы закончите экспериментировать, можно удалить индекс с помощью следующей команды:

    >>> es.indices.delete('my_index')

### Конфигурация Elasticsearch

Интеграция Elasticsearch в приложение является отличным примером крутости Flask. Этот сервис и пакет Python, который не имеет ничего общего с Flask, но я все же постараюсь получить приличный уровень интеграции. Начну с конфигурации, которую буду писать в словаре `app.config` для Flask:

> *config.py* : Elasticsearch Конфигурация.

    class Config(object):
        # ...
        ELASTICSEARCH_URL = os.environ.get('ELASTICSEARCH_URL')

Как и во многих других записях конфигурации, URL-адрес подключения для Elasticsearch будет получен из переменной среды. Если переменная не определена, получим значение `None` , и это будет сигнал для отключения Elasticsearch. Сделано это в основном для удобства, что бы не вынуждать всегда иметь службу Elasticsearch при работе с приложением, и в частности при выполнении модульных тестов. Поэтому, чтобы убедиться, что сервис используется, мне нужно определить переменную среды `ELASTICSEARCH_URL` , либо непосредственно в терминале, либо добавив ее *.env* файл следующим образом:

    ELASTICSEARCH_URL=http://localhost:9200

Elasticsearch создает проблему, потому что не декорирован расширением Flask. Я не могу создать экземпляр Elasticsearch в глобальной области, как в приведенных выше примерах, потому что для его инициализации мне нужен доступ к `app.config` , который становится доступным только после вызова функции `create_app()` . Поэтому я решил добавить атрибут `elasticsearch` в экземпляр `app` в функции фабрики приложений:

> *app/ **init** .py* : Elasticsearch instance.

    # ...
    from elasticsearch import Elasticsearch

    # ...

    def create_app(config_class=Config):
        app = Flask(__name__)
        app.config.from_object(config_class)

        # ...
        app.elasticsearch = Elasticsearch([app.config['ELASTICSEARCH_URL']]) \
            if app.config['ELASTICSEARCH_URL'] else None

        # ...

Добавление нового атрибута в экземпляр `app` может показаться немного странным, но объекты Python не слишком строги в своей структуре, новые атрибуты могут быть добавлены к ним в любое время. Альтернативой, которую вы также можете рассмотреть, является создание подкласса `Flask` (возможно, назовем его `Microblog` ) с атрибутом elasticsearch, определенным в его функции `__init__()` .

Обратите внимание, как я использую [условное выражение](https://docs.python.org/3/reference/expressions.html#conditional-expressions) , чтобы присвоить `None` экземпляру Elasticsearch, если URL-адрес службы Elasticsearch не был определен в среде.

### Абстракция Full-Text Search

Как я сказал во введении к главе, я хочу упростить возможный переход от Elasticsearch к другим поисковым системам. И я не хочу кодировать эту функцию специально для поиска сообщений в блоге, а предпочитаю разрабатывать решение, которое в будущем я могу легко распространить на другие модели, если мне это понадобится. По всем этим причинам, я решил создать абстракцию для функции поиска. Идея состоит в том, чтобы разработать функцию в общих терминах, поэтому я не буду предполагать, что модель `Post` является единственной, которая должна быть проиндексирована, и я также не буду предполагать, что Elasticsearch является предпочтительным индекс-движком. Но если я не могу делать никаких предположений ни о чем, как я могу сделать эту работу?

Первое, что мне нужно, это как-то найти общий способ указать, какая модель и какое поле или поля в ней должны быть индексированы. Я хочу сказать, что любая модель, которая нуждается в индексации должна определить атрибут класса `__searchable__` , содержащий поля, которые должны быть включены в индекс. Для модели Post это будет выглядеть так:

> *app/models.py* : Add a \_\_searchable\_\_ attribute to the Post model.

    class Post(db.Model):
        __searchable__ = ['body']
        # ...

Здесь говорится, что эта модель должна иметь индексирование поля `body` . Поясню для ясности! Этот атрибут `__searchable__` , который я добавил, является просто переменной, у него нет никакого поведения, связанного с ним. Это просто поможет мне написать мои функции индексирования в общем виде.

Я собираюсь написать весь код, который взаимодействует с индексом Elasticsearch в модуле *app/search.py* . Идея состоит в том, чтобы сохранить весь код Elasticsearch в этом модуле. Остальная часть приложения будет использовать функции в этом новом модуле для доступа к индексу и не будет иметь прямого доступа к Elasticsearch. Это важно, потому что если однажды я решу, что мне больше не нравится Elasticsearch и соберусь переключиться на другой движок, все, что мне нужно сделать, это перезаписать функции в этом одном модуле, и приложение будет продолжать работать по-прежнему.

Для этого приложения я решил, что мне нужно три вспомогательные функции, связанные с индексированием текста: мне нужно:

-   добавить записи в полнотекстовый индекс,
-   удалить записи из индекса (при условии, что в один прекрасный день я поддержу удаление сообщений в блоге),
-   выполнить поисковый запрос.

Вот модуль *app/search.py* , который реализует эти три функции для Elasticsearch, используя функциональность, которую я показал вам выше с консоли Python:

> app/search.py: Search functions.

    from flask import current_app

    def add_to_index(index, model):
        if not current_app.elasticsearch:
            return
        payload = {}
        for field in model.__searchable__:
            payload[field] = getattr(model, field)
        current_app.elasticsearch.index(index=index, doc_type=index, id=model.id,
                                        body=payload)

    def remove_from_index(index, model):
        if not current_app.elasticsearch:
            return
        current_app.elasticsearch.delete(index=index, doc_type=index, id=model.id)

    def query_index(index, query, page, per_page):
        if not current_app.elasticsearch:
            return [], 0
        search = current_app.elasticsearch.search(
            index=index, doc_type=index,
            body={'query': {'multi_match': {'query': query, 'fields': ['*']}},
                  'from': (page - 1) * per_page, 'size': per_page})
        ids = [int(hit['_id']) for hit in search['hits']['hits']]
        return ids, search['hits']['total']

Все эти функции начинаются с проверки определен ли `app.elasticsearch` . В случае `None` выходим из функции без каких-либо действий. Это значит, что в случае когда сервер Elasticsearch не настроен, приложение продолжит работать без возможности поиска и без каких-либо ошибок. Насколько это удобно станет понятно во время разработки или при выполнении модульных тестов.

Функции принимают в качестве аргумента имя index. Во всех вызовах, которые я передаю Elasticsearch, я использую это имя в качестве имени индекса, а также в качестве типа документа, как я уже делал это в примерах консоли Python.

Функции, добавляющие и удаляющие записи из индекса, принимают модель SQLAlchemy в качестве второго аргумента. Функция `add_to_index()` использует переменную класса `__searchable__` , добавленную в модель для построения документа, вставленного в индекс. Если вы помните, документы Elasticsearch также нуждались в уникальном идентификаторе. Для этого я использую поле `id` модели SQLAlchemy, которая также является уникальной. Использование одного и того же значения `id` для SQLAlchemy и Elasticsearch очень полезно при выполнении поиска, поскольку оно позволяет мне связывать записи в двух базах данных. Еще один прикол, заключается в том, что если вы попытаетесь добавить запись с существующим идентификатором, то Elasticsearch заменит старую запись новой, поэтому `add_to_index()` может использоваться как для новых объектов, так и для измененных.

Я не показывал вам функцию `es.delete ()` , которую я раньше использовал в `remove_from_index()` . Эта функция удаляет документ, хранящийся под данным идентификатором. Вот хороший пример удобства использования одного и того же идентификатора для связывания записей в обеих базах данных.

Функция `query_index()` принимает имя индекса и текст для поиска, а также элементы управления разбиением на страницы, так что результаты поиска могут быть разбиты на страницы как результаты Flask-SQLAlchemy. Вы уже видели пример использования функции `es.search()` из консоли Python. Вызов, который я выдаю, довольно похож, но вместо использования типа запроса `match` , я я решил использовать `multi_match` , который может выполнять поиск по нескольким полям. Имя поля `*` , дает установку Elasticsearch просматривать все поля для поиска индекса. Это полезно, чтобы сделать эту функцию универсальной, так как разные модели могут иметь разные имена полей в индексе.

Аргумент `body` у `es.search()` дополняет сам запрос аргументом разбиения на страницы. Аргументы `from` и `size` определяют, какое подмножество всего набора результатов необходимо вернуть. Elasticsearch не предоставляет полноценный объект `Pagination` , подобный объекту Flask-SQLAlchemy, поэтому мне придется самому написать процедуру разбиения на страницы, чтобы вычислить значение `from` .

Оператор `return` в функции `query_index()` несколько посложнее. Он возвращает два значения: первое --- список идентификационных элементов для результатов поиска, а второй --- общее количество результатов. Оба они получены из словаря Python, возвращаемого функцией `es.search()` . Если вам не знакомо выражение, которое я использую для получения списка идентификаторов, то поясню: её зовут `list comprehension` (генератор списков), и это фантастическая функция языка Python, которая позволяет вам преобразовывать списки из одного формата в другой. В этом случае я использую генератор списка, чтобы извлечь значения `id` из гораздо большего списка результатов, предоставленных Elasticsearch.

Это слишком запутанно? Возможно, демонстрация этих функций в консоли Python может помочь вам понять их получше. В следующем сеансе я вручную добавляю все сообщения из базы данных в индекс Elasticsearch. В моей тестовой базе данных у меня было несколько сообщений, в которых были цифры \"one\", \"two\", \"three\", \"four\" и «пять», поэтому я использовал их в поисковых запросах. Возможно, вам придется адаптировать свой запрос для соответствия содержимому вашей базы данных:

    >>> from app.search import add_to_index, remove_from_index, query_index
    >>> for post in Post.query.all():
    ...     add_to_index('posts', post)
    >>> query_index('posts', 'one two three four five', 1, 100)
    ([15, 13, 12, 4, 11, 8, 14], 7)
    >>> query_index('posts', 'one two three four five', 1, 3)
    ([15, 13, 12], 7)
    >>> query_index('posts', 'one two three four five', 2, 3)
    ([4, 11, 8], 7)
    >>> query_index('posts', 'one two three four five', 3, 3)
    ([14], 7)

Запрос, который я отправил, возвращает семь результатов. Поначалу я запросил 1 страницу со 100 пунктами на страницу и получил все семь возможных. Затем следующие три примера показывают, как я могу разбивать страницы способом очень похожим, на то, как я это сделал для Flask-SQLAlchemy, за исключением того, что результаты приходят в виде списка идентификаторов вместо объектов SQLAlchemy.

Если вы хотите сохранить все в чистоте, удалите индекс `posts` после того, как наэкспериментируетесь с ним:

    >>> app.elasticsearch.indices.delete('posts')

### Интеграция поиска с SQLAlchemy

Решение, которое я показал вам в предыдущем разделе, приемлемое, но у него все еще есть несколько нерешенных проблем. Первая и наиболее очевидная заключается в том, что результаты приходят в виде списка числовых идентификаторов. Это очень неудобно, поскольку мне нужны модели SQLAlchemy, чтобы я мог передавать их в шаблоны для визуализации, и мне нужен способ заменить этот список чисел соответствующими моделями из базы данных. Вторая проблема заключается в том, что это решение требует, чтобы приложение явной выдавало вызовы индексирования. Сообщения добавляются или удаляются, что не страшно, но не идеально, поскольку ошибка, которая вызывает пропущенные индексации вызова при внесении изменений на стороне SQLAlchemy не собираются быть легко обнаружены. Две базы данных будут рассинхронизироваться все больше и больше каждый раз при возникновении ошибки и вы, вероятно это не заметите какое то время. Лучшим решением было бы автоматическое включение этих вызовов при внесении изменений в базу данных SQLAlchemy.

Проблема замены идентификаторов объектами может быть решена путем создания запроса SQLAlchemy, который прочитает эти объекты из базы данных. Это звучит просто, но реализовать эффективное выполнение одного запроса на самом деле не так то просто.

Для решения второй проблемы (автоматического отслеживания изменений индексирования) я решил выполнять обновления индекса Elasticsearch из *events* (событий) SQLAlchemy. SQLAlchemy предоставляет большой список событий, о которых приложения могут получать уведомления. Например, для каждого commit-а ( *фиксации изменений* ) сеанса, я мог бы иметь функцию в приложении, вызываемом SQLAlchemy, в которой мог применять те же обновления, которые были сделаны в сеансе SQLAlchemy к индексу Elasticsearch.

Для реализации решений этих двух задач я собираюсь написать класс *mixin* . Помните занятия миксином? В [главе 5](https://habrahabr.ru/post/346346/) я добавил класс `UserMixin` из Flask-Login в пользовательскую модель, чтобы доверить ему некоторые функции, которые требовались Flask-Login. Для поддержки поиска я собираюсь определить свой собственный класс `SearchableMixin` , который при подключении к модели даст ему возможность автоматически управлять полнотекстовым индексом, связанным с моделью SQLAlchemy. Класс mixin будет выступать в качестве \"связующего\" слоя между мирами SQLAlchemy и Elasticsearch, предоставляя решения двух проблем, о которых я говорил выше.

Позвольте мне показать вам реализацию, а затем я рассмотрю некоторые интересные детали. Обратите внимание на использование нескольких передовых методов, так что вам нужно будет внимательно изучить этот код, чтобы полностью понять его.

> *app/models.py* : SearchableMixin class.

    from app.search import add_to_index, remove_from_index, query_index

    class SearchableMixin(object):
        @classmethod
        def search(cls, expression, page, per_page):
            ids, total = query_index(cls.__tablename__, expression, page, per_page)
            if total == 0:
                return cls.query.filter_by(id=0), 0
            when = []
            for i in range(len(ids)):
                when.append((ids[i], i))
            return cls.query.filter(cls.id.in_(ids)).order_by(
                db.case(when, value=cls.id)), total

        @classmethod
        def before_commit(cls, session):
            session._changes = {
                'add': list(session.new),
                'update': list(session.dirty),
                'delete': list(session.deleted)
            }

        @classmethod
        def after_commit(cls, session):
            for obj in session._changes['add']:
                if isinstance(obj, SearchableMixin):
                    add_to_index(obj.__tablename__, obj)
            for obj in session._changes['update']:
                if isinstance(obj, SearchableMixin):
                    add_to_index(obj.__tablename__, obj)
            for obj in session._changes['delete']:
                if isinstance(obj, SearchableMixin):
                    remove_from_index(obj.__tablename__, obj)
            session._changes = None

        @classmethod
        def reindex(cls):
            for obj in cls.query:
                add_to_index(cls.__tablename__, obj)

    db.event.listen(db.session, 'before_commit', SearchableMixin.before_commit)
    db.event.listen(db.session, 'after_commit', SearchableMixin.after_commit)

В этом классе mixin есть четыре функции --- все методы класса (См. декоратор *classmethod* ). Это специальный метод, который связан с классом, а не с конкретным экземпляром. Обратите внимание, как я переименовал аргумент `self` , используемый в обычных методах экземпляра, для `cls` , чтобы было ясно, что этот метод получает в качестве первого аргумента класс, а не экземпляр. Например, при подключении к модели `Post` , метод `search()` выше будет вызываться как `Post.search()` , не имея фактического экземпляра класса Post.

Метод класса `search()` обертывает функцию `query_index()` из *app/search.py* заменяя список идентификаторов объектов на фактические объекты. Очевидно, что первое, что делает эта функция, это вызывает `query_index()` , передавая `cls.__ tablename__` как имя индекса. При таком соглашении, все индексы будут именоваться с именем Flask-SQLAlchemy, присвоенным реляционной таблице. Функция возвращает список ID результатов и их общее количество. Запрос SQLAlchemy, который получает список объектов по их ID, основан на операторе `CASE` из языка SQL, который должен использоваться в целях гарантии, что результаты из базы данных приходят в том же порядке, что и идентификаторы. Это важно, поскольку запрос Elasticsearch возвращает результаты, отсортированные от более к менее релевантным. Если вы хотите узнать больше о том, как работает этот запрос, вы можете обратиться к ответу на этот вопрос [StackOverflow](https://stackoverflow.com/a/6332081/904393) . Функция `search()` возвращает запрос, который заменяет список идентификаторов, а также передает общее количество результатов поиска в качестве второго возвращаемого значения.

Методы `before_commit()` и `after_commit()` будут реагировать на два события из SQLAlchemy, которые запускаются до и после фиксации соответственно. Обработчик before полезен, потому что сеанс еще не был зафиксирован, поэтому я могу глянув на него выяснить, какие объекты будут добавлены, изменены и удалены, доступны как `session.new` `session.dirty` и `session.deleted` соответственно. Эти объекты больше не будут доступны после фиксации сеанса, поэтому мне нужно сохранить их до фиксации. Я использую `session._changes` словарь для записи этих объектов в месте, которое переживет все фиксации сеанса, потому что, как только сеанс пофиксится я буду использовать их для обновления индекса Elasticsearch.

Вызов обработчика `after_commit()` означает, что сеанс успешно завершен, поэтому сейчас самое время внести изменения на стороне Elasticsearch. Объект сеанса имеет переменную `_changes` , которую я добавил в `before_commit()` , поэтому теперь я могу перебирать добавленные, измененные и удаленные объекты и выполнять соответствующие вызовы для функций индексирования в *app/search.py* .

Метод класса `reindex()` --- это простой вспомогательный метод, который можно использовать для обновления индекса со всеми данными из реляционной стороны. Вы видели, как я делал что-то подобное из сеанса оболочки Python выше, чтобы выполнить начальную загрузку всех сообщений в тестовый индекс. Используя этот метод, я могу опубликовать `Post.reindex(),` чтобы добавить все записи в базу данных в индекс поиска ( *search index* ).

Обратите внимание, что вызовы `db.event.listen()` не входят в класс, а следуют после него. Они устанавливают обработчики событий, которые вызывают before и after для каждой фиксации. Теперь модель `Post` автоматически поддерживает индекс полнотекстового поиска для сообщений.

Чтобы включить класс `SearchableMixin` в модель `Post` , я должен добавить его в качестве подкласса, и мне также необходимо подключить befor и after события фиксации:

> *app/models.py* : Добавление SearchableMixin class в Post model.

    class Post(SearchableMixin, db.Model):
        # ...

Я могу использовать метод `reindex()` для инициализации индекса из всех сообщений, находящихся в настоящее время в базе данных:

    >>> Post.reindex()

И я могу искать сообщения, работающие с моделями SQLAlchemy, запустив `Post.search()` . В следующем примере я запрашиваю первую страницу из пяти элементов для моего запроса:

    >>> query, total = Post.search('one two three four five', 1, 5)
    >>> total
    7
    >>> query.all()
    [<Post five>, <Post two>, <Post one>, <Post one more>, <Post one>]

### Форма поиска

Проделана достаточно напряженная работа и возможно вам потребуется время, чтобы полностью ее понять. Но теперь у меня есть законченная система для работы с поиском на родном языке любого пользователя для сообщений в блоге. Теперь мне нужно интегрировать все эти функции в приложение.

Достаточно стандартный подход для веб-поиска заключается в том, чтобы строка поиска была передана, как аргумент `q` в строке запроса URL-адреса. Например, если вы хотите найти `Python` в Google, и вы хотите сэкономить пару секунд, Вы можете просто ввести следующий URL-адрес в адресной строке браузера, чтобы перейти непосредственно к результатам:

    https://www.google.com/search?q=python

Разрешить поиску быть полностью инкапсулированным в URL-адрес удобно, потому что результаты могут быть разделены с другими людьми, которые просто нажав на ссылку получат доступ к результатам поиска.

Это вносит изменения в способ, который я демонстрировал вам при обрабатке веб-формы в прошлом. Я использовал запросы `POST` для отправки данных формы для всех форм, которые приложение имело до сих пор, но для реализации поиска, как указано выше, отправка формы должна будет идти как запрос `GET` , который является методом запроса, который используется при вводе URL-адреса в браузере или нажатии ссылки. Еще одно интересное отличие заключается в том, что поисковая форма будет находиться в навигационной панели, поэтому она должна присутствовать на всех страницах приложения.

Вот класс формы поиска, только с текстовым полем `q` :

> *app/main/forms.py* : Search form.

    from flask import request

    class SearchForm(FlaskForm):
        q = StringField(_l('Search'), validators=[DataRequired()])

        def __init__(self, *args, **kwargs):
            if 'formdata' not in kwargs:
                kwargs['formdata'] = request.args
            if 'csrf_enabled' not in kwargs:
                kwargs['csrf_enabled'] = False
            super(SearchForm, self).__init__(*args, **kwargs)

Поле `q` не требует никаких объяснений, поскольку оно аналогично другим текстовым полям, которые я использовал в прошлом. Для этой формы я решил не использовать кнопку отправки. Для формы, которая имеет текстовое поле, браузер отправит форму, когда вы нажмете Enter с фокусом на поле, поэтому кнопка не нужна. Я также добавил функцию конструктора `__init__` , которая предоставляет значения для аргументов `formdata` и `csrf_enabled` , если они не предоставляются вызывающим. Аргумент `formdata` определяет, откуда Flask-WTF получает формы. По умолчанию используется `request.form` , где Flask помещает значения форм, которые передаются через запрос `POST` . Формы, представленные через запрос `GET` , получают значения полей в строке запроса, поэтому мне нужно указать Flask-WTF на `request.args` , где Flask записывает аргументы строки запроса. И, как вы помните, формы добавили CSRF-защиту по умолчанию, с добавлением токена CSRF, который добавляется в форму через конструкцию `form.hidden_tag()` в шаблонах. Для работы с интерактивными поисковыми ссылками CSRF-защиту необходимо отключить, поэтому я устанавливаю `csrf_enabled` в `False` , так что Flask-WTF знает, что ему необходимо обходить проверку CSRF для этой формы.

Поскольку мне нужно, чтобы эта форма была видна на всех страницах, мне нужно создать экземпляр класса `SearchForm` независимо от страницы, которую просматривает пользователь. Единственное требование заключается в том, что пользователь вошел в систему, потому что для анонимных пользователей я пока не показываю никакого контента. Вместо того, чтобы создавать объект формы в каждом маршруте ( *route* ), а затем передавать форму всем шаблонам ( *templates* ), я покажу вам очень полезный трюк, который устраняет дублирование кода, когда вам нужно реализовать функцию во всем приложении. Я уже использовал обработчик `before_request` раньше, еще в [главе 6](https://habrahabr.ru/post/346348/) , чтобы записать время последнего посещения для каждого пользователя. То, что я собираюсь сделать, это создать свою форму поиска в той же функции, но с изюминкой:

> *app/main/routes.py* : Создание формы поиска в before\_request handler.

    from flask import g
    from app.main.forms import SearchForm

    @bp.before_app_request
    def before_request():
        if current_user.is_authenticated:
            current_user.last_seen = datetime.utcnow()
            db.session.commit()
            g.search_form = SearchForm()
        g.locale = str(get_locale())

В приведенном коде я создаю экземпляр класса формы поиска, когда у меня есть аутентифицированный пользователь. И, конечно, мне необходимо, чтобы этот объект формы сохранялся до тех пор, пока он не будет отображен в конце запроса, поэтому мне нужно где-то его сохранить. Это где-то будет контейнером `g` , предоставленным Flask. Переменная `g` , предоставленная Flask, является местом, где приложение может хранить данные, которые должны сохраняться в течение всего срока службы запроса. Я храню форму в `g.search_form` , поэтому, когда обработчик запроса before заканчивается и Flask вызывает функцию представления, которая обрабатывает запрошенный URL, объект `g` будет таким же, и все равно будет иметь форму, прикрепленную к нему. Важно отметить, что эта переменная `g` специфична для каждого запроса и каждого клиента, поэтому, даже если ваш веб-сервер обрабатывает несколько запросов одновременно для разных клиентов, вы все равно можете полагаться на `g` для работы в качестве частного хранилища для каждого запроса, независимо от того, что происходит в других запросах, которые обрабатываются одновременно.

Следующий шаг --- отобразить форму на странице. Я сказал выше, что мне нужна эта форма на всех страницах, поэтому имеет смысл сделать ее частью навигационной панели. На самом деле это просто, потому что шаблоны также имеют доступ к данным, хранящимся в переменной `g` , поэтому мне не нужно беспокоиться о добавлении формы в качестве явного аргумента шаблона во всех вызовах `render_template()` в приложении. Вот как я могу отобразить форму в базовом шаблоне:

> *app/templates/base.html* : Отображение формы поиска в панели навигации.

            ...
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav">
                    ... home and explore links ...
                </ul>
                {% if g.search_form %}
                <form class="navbar-form navbar-left" method="get"
                        action="{{ url_for('main.search') }}">
                    <div class="form-group">
                        {{ g.search_form.q(size=20, class='form-control',
                            placeholder=g.search_form.q.label.text) }}
                    </div>
                </form>
                {% endif %}
                ...

Форма отображается только в том случае, если определен `g.search_form` . Эта проверка необходима, потому что некоторые страницы, такие как страницы ошибок, могут не определить ее. Эта форма немного отличается от той, что я делал ранее. Я устанавливаю свой атрибут `method` равный `get` , потому что я хочу, чтобы данные формы были отправлены в строку запроса с запросом `GET` . Кроме того, другие созданные мной формы имели атрибут `action` empty, потому что они были отправлены на ту же страницу, которая отображала форму. Эта форма является специальной, потому что она появляется на всех страницах, поэтому я должен четко указать, место её отправки, что является новым маршрутом, специально предназначенным для обработки запросов.

### Функция поиска в режиме просмотра

Последний бит функциональности в завершение функции поиска-это функция представления, которая получает представление формы поиска. Эта view --- функция будет присоединена к маршруту */search* , чтобы вы могли отправить запрос на поиск с помощью *<http://localhost:5000/search?q=search-words>* , как и Google.

> *app/main/routes.py* : Search view function.

    @bp.route('/search')
    @login_required
    def search():
        if not g.search_form.validate():
            return redirect(url_for('main.explore'))
        page = request.args.get('page', 1, type=int)
        posts, total = Post.search(g.search_form.q.data, page,
                                   current_app.config['POSTS_PER_PAGE'])
        next_url = url_for('main.search', q=g.search_form.q.data, page=page + 1) \
            if total > page * current_app.config['POSTS_PER_PAGE'] else None
        prev_url = url_for('main.search', q=g.search_form.q.data, page=page - 1) \
            if page > 1 else None
        return render_template('search.html', title=_('Search'), posts=posts,
                               next_url=next_url, prev_url=prev_url)

Вы видели, что в других формах я использовал метод `form.validate_on_submit()` , чтобы проверить, является ли представление формы действительным. К сожалению, этот метод работает только для форм, представленных через запрос `POST` , поэтому для этой формы мне нужно использовать `form.validate()` , который просто проверяет значения полей, не проверяя, как данные были отправлены. Если проверка не удалась, это связано с тем, что пользователь отправил пустую форму поиска, поэтому в этом случае я просто перенаправляюсь на страницу исследования, в которой отображаются все сообщения в блоге.

Метод `Post.search()` из моего класса `SearchableMixin` используется для получения списка результатов поиска. Разбиение на страницы обрабатывается очень похожим образом на индексирование и просмотр страниц, но создание следующей и предыдущей ссылок немного сложнее без помощи объекта `Pagination` из Flask-SQLAlchemy. Здесь полезно использовать общее количество результатов, переданных как второе возвращаемое значение из `Post.search()` .

После того, как страница результатов поиска и ссылки на страницы будут вычислены, все, что осталось-это отрисовать шаблон со всеми этими данными. Я мог бы найти способ повторно использовать *index.html* шаблон для отображения результатов поиска, но учитывая, что есть несколько отличий, я решил создать специальный *search.html* шаблон, который предназначен для отображения результатов поиска, воспользовавшись *\_post.html* sub-шаблон для отображения результатов поиска:

> *app/templates/search.html* : Шаблон результатов поиска.

    {% extends "base.html" %}

    {% block app_content %}
        <h1>{{ _('Search Results') }}</h1>
        {% for post in posts %}
            {% include '_post.html' %}
        {% endfor %}
        <nav aria-label="...">
            <ul class="pager">
                <li class="previous{% if not prev_url %} disabled{% endif %}">
                    <a href="{{ prev_url or '#' }}">
                        <span aria-hidden="true">&larr;</span>
                        {{ _('Previous results') }}
                    </a>
                </li>
                <li class="next{% if not next_url %} disabled{% endif %}">
                    <a href="{{ next_url or '#' }}">
                        {{ _('Next results') }}
                        <span aria-hidden="true">&rarr;</span>
                    </a>
                </li>
            </ul>
        </nav>
    {% endblock %}

Логика отрисовки предыдущей и следующей ссылок выглядит слегка запутанной. Возможно помоможет разобраться документация Bootstrap для [компонента разбиения на страницы](https://getbootstrap.com/docs/3.3/components/#pagination) .

![](https://habrastorage.org/webt/oc/2r/ky/oc2rkyqvlza5wtkc0d92ynluf3g.png)

Как вы считаете? Это была сложная и напряженная глава, где я представил довольно продвинутые методы. Некоторые из концепций в этой главе могут занять время для погружения. Самый важный вывод из этой главы заключается в том, что если вы хотите использовать поисковую систему отличающуюся от Elasticsearch, все, что вам нужно сделать, это повторно реализовать три функции в *app/search.py* . Следующее важное преимущество этих усилий состоит в том, что в будущем, если вам нужно добавить поддержку поиска для другой модели базы данных, вы можете просто сделать это, добавив к ней класс `SearchableMixin` , атрибут `__searchable__` со списком полей для индекса и соединения обработчика событий SQLAlchemy. Я думаю, что это стоило потраченных усилий, потому что отныне будет легко иметь дело с полнотекстовыми индексами.
:::

Глава 17: Развертывание в Linux
-------------------------------

::: {#post-content-body .post__text .post__text-html io-article-url="https://habr.com/ru/post/352266/"}
### Традиционный хостинг

Когда я говорю о «традиционном хостинге», я имею в виду, что приложение устанавливается вручную или через скриптовый установщик на штатный сервер. Процесс включает установку приложения, его зависимостей и production scale web server плюс настройку системы безопасности.

Первый вопрос, который нужно задать при развертывании собственного проекта --- где найти сервер. В наши дни существует множество недорогих услуг хостинга. Например, за 5\$ в месяц [Digital Ocean](https://www.digitalocean.com/) , [Linode](https://www.linode.com/) или [Amazon Lightsail](https://amazonlightsail.com/) сдадут вам в аренду виртуальный Linux-сервер (VPS) для проведения экспериментов по развертыванию. (Linode и Digital Ocean предоставляют своим серверам начального уровня 1 ГБ оперативной памяти, в то время как Amazon предоставляет только 512 МБ). Если вы предпочитаете попрактиковаться, не тратя денег, то [Vagrant](https://www.vagrantup.com/) и [VirtualBox](https://www.virtualbox.org/) -это два инструмента, которые в сочетании позволяют создать виртуальный сервер, подобный платному, на вашем собственном компьютере.

Что касается выбора операционной системы, то с технической точки зрения, это приложение может быть развернуто в любой из основных операционных систем, список, который включает в себя большое количество дистрибутивов Linux и BSD с открытым исходным кодом, а также коммерческую ОС X и Microsoft Windows (хотя OS X --- гибридный вариант open-source/commercial, поскольку он основан на Darwin, производной BSD с открытым исходным кодом).

Поскольку ОС X и Windows являются настольными операционными системами, которые не оптимизированы для работы в качестве серверов, я собираюсь сразу отказаться от таких кандидатов. Выбор между операционной системой Linux или BSD во многом основывается на предпочтениях, поэтому я собираюсь выбрать самый популярный из двух, которой является Linux. Что касается дистрибутивов Linux, я думаю будет справедливо совершить выбор по популярности и продолжить с Ubuntu.

### Сервер Ubuntu

Если вы заинтересовлись в этом развертывании вместе со мной, то вам, очевидно, понадобится сервер для работы. Я порекомендую вам два варианта приобретения сервера, один платный и один бесплатный. Если вы готовы потратить немного денег, вы можете получить учетную запись в Digital Ocean, Linode или Amazon Lightsail и создать виртуальный сервер Ubuntu 16.04. Вам будет достаточно использовать самый маленький серверный вариант, который на сегодняшний день, когда я пишу эту фразу, стоит 5 долларов США в месяц для всех трех поставщиков из приведенного выше перечня. Оплата почасовая, поэтому, если вы создадите сервер, поиграйте с ним в течение нескольких часов, а затем удалите его, вы заплатите только центами.

Бесплатная альтернатива основана на виртуальной машине, которую вы можете запускать на своем собственном компьютере. Чтобы использовать эту опцию, установите [Vagrant](https://www.vagrantup.com/) и [VirtualBox](https://www.virtualbox.org/) на свой компьютер, а затем создайте файл с именем *Vagrantfile* для описания спецификаций вашей виртуальной машины со следующим содержимым:

*Vagrantfile* : Vagrant configuration.

    Vagrant.configure("2") do |config|
      config.vm.box = "ubuntu/xenial64"
      config.vm.network "private_network", ip: "192.168.33.10"
      config.vm.provider "virtualbox" do |vb|
        vb.memory = "1024"
      end
    end

Этот файл настраивает сервер Ubuntu 16.04 с 1 ГБ ОЗУ, с которого вы сможете получить доступ с хост-компьютера по IP-адресу 192.168.33.10. Чтобы создать сервер, выполните следующую команду:

    $ vagrant up

В [документации по командной строке](https://www.vagrantup.com/docs/cli/) Vagrant, вы узнаете о других вариантах управления виртуальным сервером.

### Использование SSH-клиента

Ваш сервер консольный, поэтому у вас не будет рабочего стола, как на вашем собственном компьютере. Вы должны будете подключиться к своему серверу через SSH-клиент и работать с ним через командную строку. Если вы используете Linux или Mac OS X, скорее всего, [OpenSSH](http://www.openssh.org/) уже установлен. Если вы используете Microsoft Windows, [Cygwin](https://www.cygwin.com/) , [Git](https://git-scm.com/) и [Windows Subsystem for Linux](https://msdn.microsoft.com/en-us/commandline/wsl/about) , то они то же предоставляют возможность использования OpenSSH, так что вы можете установить любой из этих вариантов.

Если вы используете виртуальный сервер стороннего поставщика, то при создании сервера вам был предоставлен IP-адрес. Вы можете открыть терминальный сеанс с вашим новым сервером с помощью следующей команды:

    $ ssh root@<server-ip-address>

Вам будет предложено ввести пароль. В зависимости от службы, пароль может быть автоматически сгенерирован и показан Вам после создания сервера, или возможно вы сами, дали возможность выбрать свой собственный пароль.

Если вы используете Vagrant VM, вы можете открыть сеанс терминала с помощью команды:

    $ vagrant ssh

Если вы используете Windows и Vagrant VM, обратите внимание, что вам нужно будет запустить указанную выше команду из оболочки, которая может вызывать команду `ssh` из OpenSSH.

### Логин без пароля (password-less)

Вы можете пропустить этот раздел если используете Vagrant VM, поскольку ваша виртуальная машина настроена правильно, чтобы использовать учетную запись, отличную от root, с именем `ubuntu` без автоматического пароля от Vagrant.

Если вы используете виртуальный сервер, рекомендуется создать обычную учетную запись пользователя для выполнения своей работы по развертыванию и настроить эту учетную запись для входа в систему без использования пароля (password-less), что поначалу может показаться неудачным решением, но вы, увидите, что это не только более удобно, но и более безопасно.

Я собираюсь создать учетную запись пользователя с именем `ubuntu` (вы можете использовать другое имя, если хотите). Чтобы создать эту учетную запись, войдите в корневую учетную запись своего сервера с помощью инструкций `ssh` ​​из предыдущего раздела, а затем введите следующие команды, чтобы создать пользователя, дать ему `sudo` полномочия и, наконец, переключиться на него:

    $ adduser --gecos "" ubuntu
    $ usermod -aG sudo ubuntu
    $ su ubuntu

Теперь я собираюсь настроить эту новую учетную запись `ubuntu` на использование аутентификации [public key](http://en.wikipedia.org/wiki/Public-key_cryptography) , чтобы вы могли войти в систему без ввода пароля.

Оставьте сеанс терминала, который вы открыли на своем сервере, и запустите второй терминал на своем локальном компьютере. Если вы используете Windows, это должен быть терминал, с которого у вас есть доступ к команде `ssh` , поэтому, вероятно, это будет `bash` или подобное приглашение, а не родной Windows-терминал. В этом сеансе терминала проверьте содержимое *\~/.ssh directory* :

    $ ls ~/.ssh
    id_rsa  id_rsa.pub

Если в списке каталогов есть файлы с именем *id\_rsa* и *id\_rsa.pub* , как указано выше, значит у вас уже есть ключ. Если у вас нет этих двух файлов или вообще нет каталога *\~/.ssh* , вам нужно создать свою пару ключей SSH, выполнив следующую команду, также входящую в набор инструментов OpenSSH:

    $ ssh-keygen

Это приложение предложит вам ввести несколько значений, для которых я рекомендую вам принять значения по умолчанию, нажав Enter на всех приглашениях. Если вы знаете, что вы делаете, и хотите сделать иначе, то, как говориться, флаг вам в руки.

После выполнения этой команды у вас должны быть два файла, перечисленные выше. Файл *id\_rsa.pub* -это ваш *public key-открытый ключ* , файл, который вы предоставляете третьим лицам для идентификации. Файл *id\_rsa* -это ваш *private key-приватный ключ* , которым ни с кем делится не надо.

Теперь необходимо настроить открытый ключ в качестве *authorized host* на сервере. Распечатайте свой открытый ключ на экране терминала, который вы открыли на своем компьютере:

    $ cat ~/.ssh/id_rsa.pub
    ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCjw....F8Xv4f/0+7WT miguel@miguelspc

Это будет очень длинная последовательность символов, возможно, охватывающая несколько строк. Необходимо скопировать эти данные в буфер обмена, а затем переключиться обратно в терминал на удаленном сервере, где будут выдаваться эти команды для хранения открытого ключа:

    $ echo <paste-your-key-here> >> ~/.ssh/authorized_keys
    $ chmod 600 ~/.ssh/authorized_keys

Теперь password-less должен работать. Идея состоит в том, что `ssh` на вашем компьютере идентифицирует себя на сервере, выполняя криптографическую операцию, требующую секретного ключа. Затем сервер проверяет, что операция действительна с использованием открытого ключа.

Теперь вы можете выйти из своего сеанса `ubuntu` , а затем из своего `root` сеанса, а затем попытаться войти прямо в учетную запись `ubuntu` с помощью:

    $ ssh ubuntu@<server-ip-address>

На этот раз вам не нужно вводить пароль!

### Защита сервера

Чтобы свести к минимуму риск взлома сервера, можно предпринять несколько шагов, направленных на закрытие ряда потенциальных дверей, через которые злоумышленник может получить доступ.

Первое изменение, которое необходимо сделать, это отключить root логины через SSH. Теперь у вас есть password-less доступ к учетной записи `ubuntu` , и вы можете запускать команды администратора с этой учетной записи через `sudo` (от имени), так что действительно нет необходимости предоставлять учетную запись root. Чтобы отключить root логины, необходимо отредактировать файл */etc/ssh/sshd\_config* на вашем сервере. Возможно `vi` и `nano` (текстовые редакторы) уже установлены на вашем сервере и вы можете использовать их для редактирования файлов (если вы не знакомы с любым из них, попробуйте `nano` первым). Вам понадобится префикс вашего редактора с sudo, потому что конфигурация SSH не доступна для обычных пользователей (например, `sudo vi /etc/ssh/sshd_config` ). Необходимо изменить одну строку в этом файле:

> */etc/ssh/sshd\_config* : Disable root logins.

    PermitRootLogin no

После завершения редактирования конфигурации SSH необходимо перезапустить службу, чтобы изменения вступили в силу:

    $ sudo service ssh restart

Третье изменение, которое надо сделать --- установить брандмауэр. Это программное обеспечение, которое блокирует доступ к серверу на порты, которые не разрешены явно:

    $ sudo apt-get install -y ufw
    $ sudo ufw allow ssh
    $ sudo ufw allow http
    $ sudo ufw allow 443/tcp
    $ sudo ufw --force enable
    $ sudo ufw status

Эти команды устанавливают UFW, простенький брандмауэр и настраивают его на разрешение только внешнего трафика на портах 22 (SSH), 80 (http) и 443 (HTTPS). Любые другие порты будут закрыты.

### Установка Базовых Зависимостей

Если вы следовали моим советам и установили сервер на Ubuntu 16.04, то у вас уже есть система с полной поддержкой Python 3.5, который я собираюсь использовать для развертывания.

Итак, считаем, что базовый интерпретатор Python предварительно установлен на вашем сервере, но есть некоторые дополнительные пакеты, которые, скорее всего, отсутствуют, а также есть несколько других пакетов за пределами Python, которые будут полезны при создании надежного, готового работе развертыванию. Для сервера базы данных я собираюсь переключиться с SQLite на MySQL. postfix --- это агент передачи почты, который я буду использовать для отправки электронной почты. Инструмент supervisor будет следить за процессом сервера Flask и автоматически перезапускать его, если он когда-либо упадет, или если сервер перезагрузится. Сервер nginx будет принимать все запросы, поступающие из вне, и перенаправлять их в приложение. Наконец, я собираюсь использовать git в качестве инструмента для загрузки приложения непосредственно из своего репозитория git.

    $ sudo apt-get -y update
    $ sudo apt-get -y install python3 python3-venv python3-dev
    $ sudo apt-get -y install mysql-server postfix supervisor nginx git

Эти установки запускаются в основном без присмотра, но в какой-то момент, на третьем оператор установки, вам будет предложено выбрать пароль root для службы MySQL, и ещё будет задано несколько вопросов относительно установки пакета postfix, в ответах на которые вы можете принять значения по умолчанию.

Обратите внимание, что для этого развертывания я предпочитаю не устанавливать Elasticsearch. Для этой услуги требуется большой объем оперативной памяти, поэтому она жизнеспособна, если у вас большой сервер с объемом памяти более 2 ГБ. Чтобы избежать проблем с нехваткой памяти на сервере, я оставлю функциональность поиска. Если у вас достаточно большой сервер, вы можете загрузить официальный пакет .deb с сайта Elasticsearch и следовать их инструкциям по установке, чтобы добавить его на свой сервер. Ещё важный момент! Пакет Elasticsearch, доступный в репозитории пакета Ubuntu 16.04, слишком стар и не работает, вам нужна версия 6.x или новее.

Следует также отметить, что установки postfix по умолчанию, вероятно, недостаточно для отправки электронной почты в рабочей среде. Чтобы избежать спама и вредоносных писем, многим серверам требуется, чтобы сервер отправителя идентифицировал себя с помощью расширений безопасности, что означает, по крайней мере, вы должны иметь доменное имя, связанное с вашим сервером. Если вы хотите узнать, как полностью настроить почтовый сервер, чтобы он прошел стандартные тесты безопасности, см. Следующие руководства по Digital Ocean:

-   [Postfix Configuration](http://do.co/2FhdIes)
-   [Adding an SPF Record](http://do.co/2Ff8ksk)
-   [DKIM Installation and Configuration](http://do.co/2HW2oTD)

### Установка приложения

Теперь я собираюсь использовать `git` для загрузки исходного кода Microblog из моего репозитория GitHub. Я бы поорекомендовал вам почитать [git for beginners](http://ryanflorence.com/git-for-beginners/) , если Вы не знакомы с системой управления версиями git.

> **Прим.переводчика:** три хороших руководств для изучающих Git на русском языке:
>
> -   [Git the simple guide](http://rogerdudler.github.io/git-guide/index.ru.html) --- простое руководство по работе с git. Но для кого-то этого материала может не хватить, поскольку там описано все очень кратко и только основные моменты.
> -   [Pro Git](https://git-scm.com/book/ru/v1) --- исчерпывающая книга по Git, которую можно купить на Амазоне или читать онлайн / скачать бесплатно.
> -   [Git How To](https://githowto.com/ru) --- это интерактивный тур, который познакомит вас с основами Git. Тур создан с пониманием того, что лучшим способом научиться чему-нибудь --- сделать это своими руками.

Чтобы загрузить приложение на сервер, убедитесь, что вы находитесь в домашнем каталоге пользователя `ubuntu` , а затем запустите:

    $ git clone https://github.com/miguelgrinberg/microblog
    $ cd microblog
    $ git checkout v0.17

Эта последовательность команд устанавливает код на вашем сервере и синхронизирует его с этой главой. Если вы ведете свою версию этого учебного кода в своем репозитории git, вы можете изменить URL-адрес репозитория на свой, и в этом случае вы можете пропустить команду git checkout.

Теперь мне нужно создать виртуальную среду и заполнить ее всеми зависимостями пакета, которые я для удобства сохранил в файле requirements.txt в [главе 15](https://habrahabr.ru/post/351218/) :

    $ python3 -m venv venv
    $ source venv/bin/activate
    (venv) $ pip install -r requirements.txt

В дополнение к общим требуемым пакетам в *requirements.txt* , я собираюсь использовать еще два, которые относятся только к этой среде, поэтому они не включены в файл requirements. Пакет `gunicorn` -это веб-сервер для приложений на Python. Пакет `pymysql` содержит драйвер MySQL, позволяющий SQLAlchemy работать с базами данных MySQL:

    (venv) $ pip install gunicorn pymysql

Мне нужно создать файл *.env* со всеми необходимыми переменными среды:

> */home/ubuntu/microblog/.env* : Конфигурация среды.

    SECRET_KEY=52cb883e323b48d78a0a36e8e951ba4a
    MAIL_SERVER=localhost
    MAIL_PORT=25
    DATABASE_URL=mysql+pymysql://microblog:<db-password>@localhost:3306/microblog
    MS_TRANSLATOR_KEY=<your-translator-key-here>

Этот файл *.env* слегка похож на пример, который я показал в [главе 15](https://habrahabr.ru/post/351218/) , но я использовал случайную строку для SECRET\_KEY. Для генерации случайной строки, я использовал следующую команду:

    python3 -c "import uuid; print(uuid.uuid4().hex)

Для переменной `DATABASE_URL` я определил URL MySQL. Я покажу вам, как настроить базу данных в следующем разделе.

Мне нужно установить переменную среды `FLASK_APP` в точку входа приложения, чтобы команда `flask` работала, но эта переменная должна быть определена до анализа файла *.env* , поэтому её необходимо установить вручную. Чтобы избежать необходимости проделывать это каждый раз, я собираюсь добавить её в нижнюю часть *\~/.profile* для учетной записи `ubuntu` , так что она будет устанавливаться автоматически каждый раз при моем входе:

    $ echo "export FLASK_APP=microblog.py" >> ~/.profile

Если вы выйдете из системы и вернетесь, значение FLASK\_APP для вас будет уже установлено. Вы можете подтвердить, что значение определено с помощью `flask --help` . Если вспомогательное сообщение показывает команду `translate` , добавленную приложением, то значит приложение было найдено.

И теперь, когда команда `flask` функциональна, я могу скомпилировать языковые переводы:

    (venv) $ flask translate compile

### Настройка MySQL

База данных sqlite, которую я использовал во время разработки, отлично подходит для простых приложений, но при развертывании полномасштабного веб-сервера, который потенциально может обрабатывать несколько запросов одновременно, лучше использовать более надежную СУБД. По этой причине я собираюсь создать базу данных MySQL, которую я буду называть `microblog` .

Для управления сервером баз данных используется команда `mysql` , которая должна быть уже установлена на вашем сервере:

    $ mysql -u root -p
    Enter password:
    Welcome to the MySQL monitor.  Commands end with ; or \g.
    Your MySQL connection id is 6
    Server version: 5.7.19-0ubuntu0.16.04.1 (Ubuntu)

    Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.

    Oracle is a registered trademark of Oracle Corporation and/or its
    affiliates. Other names may be trademarks of their respective
    owners.

    Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

    mysql>

Обратите внимание, что вам нужно будет ввести root-пароль MySQL, который вы выбрали при установке MySQL, чтобы получить доступ к командной строке MySQL.

Это команды, которые создают новую базу данных под названием `microblog` и пользователя с тем же именем с полным доступом к ней:

    mysql> create database microblog character set utf8 collate utf8_bin;
    mysql> create user 'microblog'@'localhost' identified by '<db-password>';
    mysql> grant all privileges on microblog.* to 'microblog'@'localhost';
    mysql> flush privileges;
    mysql> quit;

Вам нужно будет заменить `<db-password>` паролем по вашему выбору. Это будет пароль для пользователя базы данных `microblog` , так что будет правильно, чтобы он отличался от пароля для пользователя root. Пароль для пользователя `microblog` должен совпадать с паролем, включенным в переменную `DATABASE_URL` файл *.env* .

Если конфигурация базы данных правильная, можно запускать миграции базы данных, создающие все таблицы:

    (venv) $ flask db upgrade

Прежде чем продолжить, убедитесь, что приведенная выше команда выполнена без ошибок.

### Настройка Gunicorn и Supervisor

Когда вы запускаете сервер командой `flask run` , вы используете веб-сервер, который поставляется с Flask. Этот сервер полезен во время разработки, но он не является хорошим выбором для использования на рабочем сервере, потому что он не был построен с учетом производительности и надежности. Вместо сервера разработки Flask для этого развертывания я решил использовать [gunicorn](http://gunicorn.org/) , который также является чистым веб-сервером Python, но в отличие от Flask, это надежный production сервер, который используется многими людьми, в то же время он очень прост в использовании.

Для запуска Микроблога под gunicorn вы можете использовать следующую команду:

    (venv) $ gunicorn -b localhost:8000 -w 4 microblog:app

Опция `-b` сообщает gunicorn, что установлен порт 8000 внутреннего сетевого интерфейса для прослушки запросов. Обычно рекомендуется запускать веб-приложения Python без внешнего доступа, а затем иметь очень быстрый веб-сервер, оптимизированный для обслуживания статических файлов, принимающих все запросы от клиентов. Этот быстрый веб-сервер будет обслуживать статические файлы напрямую и перенаправлять любые запросы, предназначенные для приложения, на внутренний сервер. Я покажу вам, как настроить nginx в качестве публичного сервера в следующем разделе.

Параметр `-w` определяет, сколько *рабочих процессов* будет работать с gunicorn. Наличие четырех процессов позволяет приложению обрабатывать до четырех клиентов одновременно, что для веб-приложения обычно достаточно для обработки приличного количества клиентов, так как не все из них постоянно запрашивают контент. В зависимости от объема ОЗУ, имеющегося на сервере, может потребоваться настроить количество процессов, чтобы не исчерпать память.

Аргумент `microblog:app` сообщает gunicorn, как загрузить экземпляр приложения. Имя перед двоеточием-это модуль, содержащий приложение, А имя после двоеточия-это имя этого приложения.

Хотя gunicorn очень прост в настройке, запуск из командной строки на самом деле не является хорошим решением для рабочего сервера. Я хочу, чтобы он работал в фоновом режиме и находился под постоянным контролем, потому что если по какой-либо причине сервер падает и выходит, хотелось бы убедиться, что новый сервер автоматически запустится, чтобы занять его место. Кроме того, при перезагрузке компьютера, сервер должен запускаться автоматически, без необходимости входить в систему и запускать все самостоятельно. Я собираюсь использовать пакет [supervisor](http://supervisord.org/) , который я установил выше для этих целей.

Утилита supervisor использует файлы конфигурации, которые сообщают ей, какие программы отслеживать и как перезапускать их при необходимости. Файлы конфигурации должны храниться в */etc/supervisor/conf.d.* Вот файл конфигурации для Микроблога, который я собираюсь назвать *microblog.conf* :

> */etc/supervisor/conf.d/microblog.conf* : Supervisor configuration.

    [program:microblog]
    command=/home/ubuntu/microblog/venv/bin/gunicorn -b localhost:8000 -w 4 microblog:app
    directory=/home/ubuntu/microblog
    user=ubuntu
    autostart=true
    autorestart=true
    stopasgroup=true
    killasgroup=true

Настройки `command` , `directory` и `user` сообщают супервизору, как запустить приложение. `autostart` и `autorestart` настройки автоматической перезагрузки из-за запуска компьютера или сбоя. Опции `stopasgroup` и `killasgroup` гарантируют, что когда супервизору необходимо остановить приложение, чтобы перезапустить его, он также достигнет все дочерние процессы процесса gunicorn верхнего уровня.

После записи этого файла конфигурации необходимо перезагрузить службу супервизора для его импорта:

    $ sudo supervisorctl reload

И точно так же, веб-сервер gunicorn должен быть запущен и проверен!

### Настройка Nginx

Сервер приложений microblog на базе gunicorn теперь работает на частном порту 8000. То, что мне нужно сделать сейчас, чтобы предоставить приложение внешнему миру, --- это включить мой общедоступный веб-сервер на портах 80 и 443, два порта, которые я открыл на брандмауэре для обработки веб-трафика приложения.

Я хочу, чтобы это было безопасное развертывание, поэтому я собираюсь настроить порт 80 для пересылки всего трафика на порт 443, который будет зашифрован. Итак, я собираюсь начать с создания SSL-сертификата. Сейчас я собираюсь создать *self-signed SSL certificate* , который подходит для тестирования всего, но не подходит для реального развертывания, потому что веб-браузеры будут предупреждать пользователей, что сертификат не был выдан доверенным центром сертификации. Команда для создания сертификата SSL для микроблога:

    $ mkdir certs
    $ openssl req -new -newkey rsa:4096 -days 365 -nodes -x509 \
      -keyout certs/key.pem -out certs/cert.pem

Команда запросит у вас некоторую информацию о вашем приложении и о себе. Это информация, которая будет включена в сертификат SSL, и что веб-браузеры будут показывать пользователям, если они захотят увидеть его. Результатом выполнения приведенной выше команды будет два файла с именем `key.pem` и `cert.pem` , который я разместил в подкаталоге *certs* корневого каталога Микроблога.

Чтобы веб-сайт обслуживался nginx, необходимо написать для него файл конфигурации. В большинстве установок nginx этот файл должен находиться в каталоге */etc/nginx/sites-enabled directory.* Nginx устанавливает тестовый сайт в этом месте, который мне не нужен, поэтому я собираюсь начать с его удаления:

    $ sudo rm /etc/nginx/sites-enabled/default

Ниже вы можете увидеть конфигурационный файл nginx для Microblog, который входит в */etc/nginx/sites-enabled/microblog:*

> /etc/nginx/sites-enabled/microblog: Nginx configuration.

    server {
        # прослушивание порта 80 (http)
        listen 80;
        server_name _;
        location / {
            # перенаправлять любые запросы на один и тот же URL-адрес, как на https
            return 301 https://$host$request_uri;
        }
    }
    server {
        # прослушивание порта 443 (https)
        listen 443 ssl;
        server_name _;

        # расположение self-signed SSL-сертификата
        ssl_certificate /home/ubuntu/microblog/certs/cert.pem;
        ssl_certificate_key /home/ubuntu/microblog/certs/key.pem;

        # запись доступа и журналы ошибок в /var/log
        access_log /var/log/microblog_access.log;
        error_log /var/log/microblog_error.log;

        location / {
            # переадресация запросов приложений на сервер gunicorn
            proxy_pass http://localhost:8000;
            proxy_redirect off;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }

        location /static {
            # обрабатывать статические файлы напрямую, без пересылки в приложение
            alias /home/ubuntu/microblog/static;
            expires 30d;
        }
    }

Конфигурация nginx далека от тривиальной, но я добавил несколько комментариев, чтобы, по крайней мере, вы знали, что делает каждая секция. Если вы хотите получить информацию о конкретной директиве, обратитесь к [официальной документации nginx](https://nginx.org/ru/docs/) .

После добавления этого файла вам нужно передать nginx инструкцию по перезагрузке конфигурации, для его активации:

    $ sudo service nginx reload

Теперь приложение должно быть развернуто. В веб-браузере можно ввести IP-адрес сервера (или 192.168.33.10, если вы используете виртуальную машину Vagrant), который будет подключаться к приложению. Поскольку вы используете самозаверяющий сертификат, вы получите предупреждение от веб-браузера, которое вам придется отклонить.

После завершения развертывания с приведенными выше инструкциями для собственных проектов настоятельно рекомендуется заменить самозаверяющий сертификат реальным, чтобы браузер не предупреждал пользователей о вашем сайте. Для этого вам сначала нужно купить доменное имя и настроить его на IP-адрес вашего сервера. После того, как у вас появится домен, вы можете запросить бесплатный [Let\'s Encrypt](https://letsencrypt.org/) сертификат SSL. Я написал подробную статью в своем блоге о том, как [запустить Приложение Flask через HTTPS](https://blog.miguelgrinberg.com/post/running-your-flask-application-over-https) .

### Развертывание обновлений приложений

В заключении этой главы относительно развертывания на основе Linux я хочу обсудить вопрос, как обрабатывать обновления приложений. Исходный код приложения устанавливается на сервере через `git` , поэтому всякий раз, когда вы хотите обновить приложение до последней версии, вы можете просто запустить `git pull` , чтобы загрузить новые коммиты, которые были сделаны с момента предыдущего развертывания.

Но, конечно, загрузка новой версии кода не будет вызывать обновление. Серверные процессы, выполняющиеся в данный момент, продолжат работать со старым кодом, который уже был прочитан и сохранен в памяти. Чтобы инициировать обновление, необходимо остановить текущий сервер и запустить новый, чтобы заставить весь код быть прочитанным снова.

Выполнение обновления в целом сложнее, чем просто перезапуск сервера. Возможно, потребуется применить миграцию базы данных или скомпилировать новые языковые переводы, поэтому в действительности процесс обновления включает последовательность команд:

    (venv) $ git pull                              # Скачать новую версию
    (venv) $ sudo supervisorctl stop microblog     # Остановка текущего сервера
    (venv) $ flask db upgrade                      # Обновление базы данных
    (venv) $ flask translate compile               # Обновление переводов
    (venv) $ sudo supervisorctl start microblog    # Запуск нового сервера

### Raspberry Pi Хостинг

[Raspberry Pi](http://www.raspberrypi.org/) -это недорогой революционный маленький компьютер Linux, который имеет очень низкое энергопотребление, поэтому это идеальное устройство для размещения домашнего веб-сервера, который может быть ОНЛАЙН 24/7, не связывая ваш настольный компьютер или ноутбук. Есть несколько дистрибутивов Linux, которые работают на Raspberry Pi. Мой выбор [Raspbian](http://www.raspbian.org/) , который является официальным дистрибутивом от Raspberry Pi Foundation.

Чтобы подготовить Raspberry Pi, я собираюсь установить свежий выпуск Raspbian. Я буду использовать версию raspbian Stretch Lite в сентябре 2017 года, но к тому времени, когда вы прочтете это, скорее всего, появятся новые версии, поэтому проверьте официальную [страницу загрузки](https://www.raspberrypi.org/downloads/raspbian/) , чтобы получить самый последний релиз.

Образ Raspbian должен быть установлен на SD-карту, которую вы затем подключаете к Raspberry Pi, чтобы он мог загружаться с ним. Инструкции по копированию образа Raspbian на SD-карту из Windows, Mac OS X и Linux доступны на сайте [Raspberry Pi](https://www.raspberrypi.org/documentation/installation/installing-images/) .

При первой загрузке Raspberry Pi делайте это при подключении к клавиатуры и монитора, так что бы вы могли сделать настройку. По крайней мере, вы должны включить SSH, чтобы можно было войти в систему со своего компьютера для более удобного выполнения задач развертывания.

Как и Ubuntu, Raspbian является производной Debian, поэтому приведенные выше инструкции для Ubuntu Linux по большей части работают так же, как и для Raspberry Pi. Однако вы можете пропустить некоторые шаги, если планируете запускать небольшое приложение в домашней сети без внешнего доступа. Например, вам может не понадобиться брандмауэр или логины без пароля. И вы можете использовать SQLite вместо MySQL на таком маленьком компьютере. Вы можете отказаться от использования nginx и просто заставить сервер gunicorn слушать запросы клиентов напрямую. Вам, вероятно, понадобится только один процесс gunicorn. Служба супервизора полезна для обеспечения того, чтобы приложение всегда было в порядке, поэтому я советовал бы использовать его и на Raspberry Pi.
:::

Глава 18: Развертывание на Heroku
---------------------------------

::: {#post-content-body .post__text .post__text-html io-article-url="https://habr.com/ru/post/352830/"}
### Хостинг на Heroku

Heroku, одна из первых облачных платформ, которая появилась в июне 2007 года и изначально поддерживала только язык программирования Ruby, но на данный момент список поддерживаемых языков также включает в себя Java, Node.js, Scala, Clojure, Go, PHP и конечно Python.

Развертывание веб-приложения в Heroku выполняется с помощью средства управления версиями `git` , поэтому приложение должно находиться в репозитории git. Heroku ищет файл под названием *Procfile* в корневом каталоге приложения для получения инструкций о том, как запустить приложение. Для проектов Python, Heroku потребуется файл *requirements.txt* файл со списком всех зависимостей модулей, которые необходимо установить. После того, как приложение будет загружено на серверы Heroku через git, вы, по сути всё сделали, и нужно просто подождать несколько секунд, пока приложение появится в сети. Это действительно так просто.

Heroku предлагает вам выбрать уровень обслуживания исходя из необходимой вычислительной мощности и времени требуемой вашему приложению, так как ваша база пользователей растет вам нужно будет купить больше единиц вычислительных, которые Heroku называет \"dynos\".

Готовы попробовать Heroku? Давайте начнем!

### Создание учетной записи Heroku

Прежде чем вы сможете завершить развертывание в Heroku, вам нужно получить учетную запись. Поэтому посетите сайт [heroku.com](https://id.heroku.com/signup) и создайте бесплатную учетную запись. После того, как зарегестрируетесь и войдёте в Heroku, вы получите доступ к панели мониторинга, где будут перечислены все ваши приложения.

### Установка Heroku CLI

Heroku предоставляет командную строку для взаимодействия с службой под названием [Heroku CLI](https://devcenter.heroku.com/articles/heroku-cli) , доступной для Windows, Mac OS X и Linux. Документация содержит инструкции по установке для всех поддерживаемых платформ. Установите его в своей системе, если вы планируете развертывать приложение для тестирования службы.

Первое, что вы должны сделать после установки CLI, это войти в ваш Heroku аккаунт:

    $ heroku login

Heroku CLI попросит вас ввести свой адрес электронной почты и пароль учетной записи. Ваш аутентифицированный статус будет сохранен в последующих командах.

### Настройка Git

Инструмент `git` является основой для развертывания приложений в Heroku, поэтому вы должны установить его в своей системе, если у вас его еще нет. Если у вас нет пакета, доступного для вашей операционной системы, вы можете посетить [сайт git](https://git-scm.com/) для загрузки установщика.

Есть множество причин использовать `git` для ваших проектов. Если вы планируете развертывание в Heroku, то у вас появилась еще одна, потому что для развертывания в Heroku ваше приложение должно быть в репозитории `git` . Если вы собираетесь выполнить тестовое развертывание для Микроблога, вы можете клонировать приложение из GitHub:

    $ git clone https://github.com/miguelgrinberg/microblog
    $ cd microblog
    $ git checkout v0.18

Команда `git checkout` выбирает конкретную точку фиксации приложения в его истории, соответствующей этой главе.

Если вы предпочитаете работать с собственным кодом, а не с моим, вы можете преобразовать свой собственный проект в репозиторий `git` , запустив `git init .` в каталоге верхнего уровня (обратите внимание на точку после `init` , которая является инструкцией для git, что вы хотите создать репозиторий в текущем каталоге).

### Создание приложения Heroku

Чтобы зарегистрировать новое приложение в Heroku, используйте команду `apps:create` из корневого каталога, передавая имя приложения в качестве единственного аргумента:

    $ heroku apps:create flask-microblog
    Creating flask-microblog... done
    http://flask-microblog.herokuapp.com/ | https://git.heroku.com/flask-microblog.git

Heroku требует, чтобы приложения имели уникальное имя. Имя `flask-microblog` , которое я использовал выше, не будет вам доступно, потому что я уже использую его, поэтому вам нужно будет выбрать другое для вашего развертывания.

На выходе этой команды мы получим URL, который Heroku назначил приложению, а также его репозиторий git. Ваш локальный репозиторий git уже будет иметь настройку связи с внешним( *remote* ), называемым `heroku` . Вы можете убедиться, что он существует с помощью команды `git remote` :

    $ git remote -v
    heroku  https://git.heroku.com/flask-microblog.git (fetch)
    heroku  https://git.heroku.com/flask-microblog.git (push)

В зависимости от того, как вы создали свой репозиторий git, вывод вышеуказанной команды также может включать в себя еще один удаленный источник с именем `origin` .

### Эфемерная файловая система

Платформа Heroku отличается от других платформ развертывания тем, что в ней реализована *ephemeral* файловая система, работающая на виртуальной платформе. Что это значит? Это означает, что в любое время Heroku может сбросить виртуальный сервер, что приведет к возврату вашего сервера в чистое состояние. Нельзя предположить, что любые данные, которые вы сохраняете в файловой системе, будут сохраняться, и на самом деле, Heroku очень часто перерабатывает серверы.

Работа в этих условиях создает некоторые проблемы для моего приложения, которое использует несколько файлов:

-   Компонент SQLite database engine по умолчанию записывает данные в файл на диске
-   Журналы для приложения записываются в файловую систему
-   Скомпилированные хранилища языковых переводов также хранятся в локальных файлах

В следующих разделах будут рассмотрены эти три направления.

### Работа с базой данных Heroku Postgres

Чтобы решить первую проблему, я перейду на другой механизм базы данных. В [главе 17](https://habrahabr.ru/post/352266/) вы видели, как я использую базу данных MySQL, чтобы повысить надежность развертывания Ubuntu. У Heroku есть собственное предложение базы данных, основанное на Postgres, поэтому я собираюсь переключиться на него, чтобы избежать проблемы хранения SQLite на основе файлов.

Базы данных для приложений Heroku снабжаются одним и тем же CLI Heroku. В этом случае я собираюсь создать базу данных на бесплатном(free) уровне:

    $ heroku addons:add heroku-postgresql:hobby-dev
    Creating heroku-postgresql:hobby-dev on flask-microblog... free
    Database has been created and is available
     ! This database is empty. If upgrading, you can transfer
     ! data from another database with pg:copy
    Created postgresql-parallel-56076 as DATABASE_URL
    Use heroku addons:docs heroku-postgresql to view documentation

URL-адрес вновь созданной базы данных хранится в переменной среды `DATABASE_UR` L, которая будет доступна при запуске приложения. Это очень удобно, так как приложение уже ищет URL базы данных в этой переменной.

### Ведение журнала в stdout

Heroku ожидает, что приложения будут совершать ввод/вывод непосредственно в `stdout` . Все, что приложение печатает в стандартном выводе сохраняется и возвращается при использовании команды `heroku logs` . Поэтому я собираюсь добавить переменную конфигурации, которая указывает, нужно ли мне вести записи в `stdout` или в файл, как я это делал ранее. Вот изменение в конфигурации:

> *config.py* : Опция ведения журнала в stdout.

    class Config(object):
        # ...
        LOG_TO_STDOUT = os.environ.get('LOG_TO_STDOUT')

Затем в функции фабрики приложений я могу проверить эту конфигурацию, чтобы понять, как настроить средство ведения журнала приложения:

> *`app/__init__.py`* : Журнал в stdout или в файл.

    def create_app(config_class=Config):
        # ...
        if not app.debug and not app.testing:
            # ...

            if app.config['LOG_TO_STDOUT']:
                stream_handler = logging.StreamHandler()
                stream_handler.setLevel(logging.INFO)
                app.logger.addHandler(stream_handler)
            else:
                if not os.path.exists('logs'):
                    os.mkdir('logs')
                file_handler = RotatingFileHandler('logs/microblog.log',
                                                   maxBytes=10240, backupCount=10)
                file_handler.setFormatter(logging.Formatter(
                    '%(asctime)s %(levelname)s: %(message)s '
                    '[in %(pathname)s:%(lineno)d]'))
                file_handler.setLevel(logging.INFO)
                app.logger.addHandler(file_handler)

            app.logger.setLevel(logging.INFO)
            app.logger.info('Microblog startup')

        return app

Поэтому теперь мне нужно определить переменную среды `LOG_TO_STDOUT` , если приложение работает в Heroku, но не в других конфигурациях. CLI Heroku делает это легко, поскольку предоставляет возможность устанавливать переменные среды, которые будут использоваться во время выполнения:

    $ heroku config:set LOG_TO_STDOUT=1
    Setting LOG_TO_STDOUT and restarting flask-microblog... done, v4
    LOG_TO_STDOUT: 1

### Скомпилированные переводы

Третьим аспектом микроблога, основанного на локальных файлах, является скомпилированный языковой перевод файлов. Самый простой вариант, чтобы гарантировать, что эти файлы никогда не исчезнут из эфемерной файловой системы, --- это добавить скомпилированные языковые файлы в репозиторий Git, чтобы они стали частью начального состояния приложения после его развертывания в Heroku.

Более элегантный вариант, на мой взгляд, заключается в том, чтобы включить команду `flask translate compile` в команду start up, предоставленную Heroku, так что каждый раз, когда сервер перезапустится эти файлы скомпилируются снова. Я собираюсь пойти этим путём, так как я знаю, что моя процедура запуска будет требовать более одной команды в любом случае, так как мне ещё нужно запустить миграцию базы данных. Поэтому сейчас я отложу эту проблему в сторону и вернусь к ней позже, когда напишу *Procfile* .

### Хостинг Elasticsearch

Elasticsearch является одним из многих сервисов, которые могут быть добавлены к проекту Heroku, но в отличие от Postgres, это не услуга, предоставляемая Heroku, а третья сторона, которая сотрудничают с Heroku, чтобы обеспечить дополнения. На сегодняшний день(когда я пишу эти строки) есть три разных провайдеров комплексной службы elasticsearch.

Прежде чем настраивать Elasticsearch, имейте в виду, что Heroku требует, чтобы ваша учетная запись имела привязанную кредитную карту до установки любого стороннего дополнения, даже если вы остаетесь в пределах их бесплатных уровней. Если вы предпочитаете не предоставлять данные своей кредитки Heroku, пропустите этот раздел. Вы сможете развернуть приложение, но функция поиска не будет работать.

Из вариантов Elasticsearch, которые доступны в качестве дополнений, я решил попробовать [SearchBox](https://elements.heroku.com/addons/searchbox) , который поставляется с бесплатным стартовым планом. Чтобы добавить SearchBox в свою учетную запись, вы должны выполнить следующую команду во время входа в Heroku:

    $ heroku addons:create searchbox:starter

Эта команда развернет службу Elasticsearch и разместит URL-адрес подключения для службы в переменной среды `SEARCHBOX_URL` , связанной с приложением. Еще раз напомню, что эта команда не будет выполнена, если Вы не добавите свою кредитную карту в свой аккаунт Heroku.

Если вы вспомните из [главы 16](https://habrahabr.ru/post/351900/) , мое приложение ищет URL-адрес подключения Elasticsearch в переменной `ELASTICSEARCH_URL` , поэтому мне нужно добавить эту переменную и установить ее в URL-адрес подключения, назначенный SearchBox:

    $ heroku config:get SEARCHBOX_URL
    <your-elasticsearch-url>
    $ heroku config:set ELASTICSEARCH_URL=<your-elasticsearch-url>

Здесь я сначала попросил Heroku напечатать значение `SEARCHBOX_URL` , а затем я добавил новую переменную среды с именем `ELASTICSEARCH_URL` , установленным в то же значение.

### Обновление Requirements

Heroku ожидает, что зависимости будут в файле *requirements.txt* , точно так же, как я определил в [главе 15](https://habrahabr.ru/post/351218/) . Но для запуска приложения на Heroku мне нужно добавить две новые зависимости к этому файлу.

Heroku не предоставляет собственный веб-сервер. Вместо этого он ожидает, что приложение запустит свой собственный веб-сервер по номеру порта, указанному в переменной среды `$PORT` . Поскольку Веб-сервер разработки flask недостаточно надежен для использования в работе, я собираюсь снова использовать [gunicorn](http://gunicorn.org/) , сервер, рекомендованный Heroku для приложений Python.

Приложение также будет подключаться к базе данных Postgres, и для этого SQLAlchemy требует установки пакета `psycopg2` .

И `gunicorn` и `psycopg2` нужно быть добавленным в файл *requirements.txt* .

### Профайл

Heroku должен знать, как выполнить приложение, и для этого он использует файл с именем *Procfile* в корневом каталоге приложения. Формат этого файла прост, каждая строка содержит имя процесса, двоеточие, а затем команду, которая запускает процесс. Наиболее распространенным типом приложения, который работает на Heroku, является веб-приложение, и для этого типа приложений имя процесса должно быть `web` . Ниже вы можете увидеть Procfile для Microblog:

> Procfile: Heroku Procfile.

    web: flask db upgrade; flask translate compile; gunicorn microblog:app

Здесь я определил команду для запуска веб-приложения как последовательность трёх команд. Сначала я запускаю обновление миграции базы данных, затем компилирую переводы языков и, наконец, запускаю сервер.

Поскольку первые две подкоманды основаны на команде `flask` , мне нужно добавить переменную среды `FLASK_APP` :

    $ heroku config:set FLASK_APP=microblog.py
    Setting FLASK_APP and restarting flask-microblog... done, v4
    FLASK_APP: microblog.py

Команда `gunicorn` проще, чем то, что я использовал для развертывания Ubuntu, потому что этот сервер имеет очень хорошую интеграцию со средой Heroku. Например, переменная среды `$PORT` учитывается по умолчанию, и вместо того, чтобы использовать параметр `-w` для задания числа процессов, heroku рекомендует добавить переменную `WEB_CONCURRENCY` , которую `gunicorn` использует, когда `-w` не предоставляется, что дает вам гибкость для управления числом процессов без необходимости изменять Procfile.

### Развертывание приложения

Все подготовительные шаги завершены, поэтому пришло время запуска развертывания. Для загрузки приложения на серверы Heroku для развертывания используется команда `git push` . Это похоже на отправку изменений в локальном репозитории git на GitHub или другой удаленный сервер git.

И теперь я достиг самой интересной части, где я отправляю приложение на свой хостинг-аккаунт Heroku. Это на самом деле довольно просто, я просто должен использовать `git` , чтобы подтолкнуть приложение к главной ветви репозитория Heroku git. Существует несколько вариантов того, как это сделать, в зависимости от того, как вы создали свой репозиторий git. Если вы используете мой код `v0.18` , то вам нужно создать ветвь на основе этого тега, и отправить её к удаленной ветви master, следующим образом:

    $ git checkout -b deploy
    $ git push heroku deploy:master

Если вы всё же работаете с собственным репозиторием, то ваш код уже, скорее всего, находится в главной ветви, поэтому вам сначала нужно убедиться, что ваши изменения пофиксены:

    $ git commit -a -m "heroku deployment changes"

После чего можно запустить развертывание следующим образом:

    $ git push heroku master

Независимо от того, как вы отправляете ветку, вы должны увидеть следующий вывод из Heroku:

    $ git push heroku deploy:master
    Counting objects: 247, done.
    Delta compression using up to 8 threads.
    Compressing objects: 100% (238/238), done.
    Writing objects: 100% (247/247), 53.26 KiB | 3.80 MiB/s, done.
    Total 247 (delta 136), reused 3 (delta 0)
    remote: Compressing source files... done.
    remote: Building source:
    remote:
    remote: -----> Python app detected
    remote: -----> Installing python-3.6.2
    remote: -----> Installing pip
    remote: -----> Installing requirements with pip
    ...
    remote:
    remote: -----> Discovering process types
    remote:        Procfile declares types -> web
    remote:
    remote: -----> Compressing...
    remote:        Done: 57M
    remote: -----> Launching...
    remote:        Released v5
    remote:        https://flask-microblog.herokuapp.com/ deployed to Heroku
    remote:
    remote: Verifying deploy... done.
    To https://git.heroku.com/flask-microblog.git
     * [new branch]      deploy -> master

Метка `heroku` , которую мы использовали в команде `git push` , --- это удаленный репозиторий, который был автоматически добавлен HEROKU CLI при создании приложения. Аргумент `deploy:master` означает, что я перемещаю код из локального репозитория, на который ссылается ветвь `deploy` , в главную ветвь `master` репозитория Heroku. Когда вы работаете с вашими собственными проектами, вы, вероятно, будете проталкивать изменения с помощью команды `git push heroku master` , которая протолкнет(запушит) вашу локальную ветку `master` . Из-за того, как этот проект структурирован, я отправляю ветку, которая не является `master` , но ветка назначения на стороне Heroku всегда должна быть `master` , поскольку это единственная ветвь, которую Heroku принимает для развертывания.

И вот теперь приложение должно быть развернуто по URL-адресу, указанному в выходных данных команды, создавшей приложение. В моем случае URL был *<https://flask-microblog.herokuapp.com>* , так что это то, что мне нужно ввести, чтобы получить доступ к приложению.

Если вы хотите видеть записи журнала для работающего приложения, используйте команду `heroku logs` . Это может быть полезно, если по какой-либо причине приложение не запускается. Если были какие-либо ошибки, они будут в журналах.

### Развертывание обновлений приложений

Чтобы развернуть новую версию приложения, вам просто нужно выполнить команду `git push` с новым кодом. Это повторит процесс развертывания, отключит старое развертывание и заменит его новым кодом. Команды в Procfile будут запускаться снова как часть нового развертывания, поэтому любые новые миграции или переводы базы данных будут обновляться во время процесса.
:::

Глава 19: Развертывание на Docker контейнерах
---------------------------------------------

::: {#post-content-body .post__text .post__text-html io-article-url="https://habr.com/ru/post/353234/"}
### Установка Docker CE

Хотя Docker не единственная контейнерная Платформа, она на сегодняшний день является самой популярной, так что это будет мой выбор. Существует два выпуска Docker, выпуск Free community edition (CE) и выпуск Enterprise edition (EE) на основе подписки. Для целей этого учебника Docker CE вполне адекватен.

Чтобы работать с Docker CE, вам сначала нужно установить его в свою систему. Есть инсталляторы для Windows, Mac OS X и нескольких дистрибутивов Linux, доступных на [веб-сайте Docker](https://www.docker.com/community-edition) . Если вы работаете в системе Microsoft Windows, важно отметить, что Docker CE требует Hyper-V. Установщик включит это для вас, если это необходимо, но имейте в виду, что включение Hyper-V предотвращает работу других технологий виртуализации, таких как VirtualBox.

После установки Docker CE в системе проверить успешность установки можно, введя следующую команду в окне терминала или командной строке:

    $ docker version
    Client:
     Version:      17.09.0-ce
     API version:  1.32
     Go version:   go1.8.3
     Git commit:   afdb6d4
     Built:        Tue Sep 26 22:40:09 2017
     OS/Arch:      darwin/amd64

    Server:
     Version:      17.09.0-ce
     API version:  1.32 (minimum version 1.12)
     Go version:   go1.8.3
     Git commit:   afdb6d4
     Built:        Tue Sep 26 22:45:38 2017
     OS/Arch:      linux/amd64
     Experimental: true

### Построение образа контейнера

Первым шагом в создании контейнера для микроблога является создание для него *образа* . Образ контейнера --- это шаблон, который используется для создания контейнера. Он содержит полное представление файловой системы контейнера, а также различные настройки, относящиеся к сети, запуск вариантов и т.д.

Самый простой способ создать образ контейнера для приложения-запустить контейнер для базовой операционной системы, которую вы хотите использовать (Ubuntu, Fedora и т. д.).), подключитесь к запущенному в нем процессу оболочки bash, а затем вручную установите приложение, возможно, следуя рекомендациям, которые я представил в [главе 17](https://habrahabr.ru/post/352266/) для традиционного развертывания. После установки всего можно сделать снимок контейнера, который станет образом. Этот тип рабочего процесса поддерживается командой `docker` , но я не собираюсь обсуждать его, потому что не удобно вручную устанавливать приложение каждый раз, когда вам нужно создать новый образ.

Лучшим подходом является создание образа контейнера с помощью сценария. Команда, создающая образы контейнеров со сценариями, --- это `docker build` . Эта команда считывает и выполняет инструкции сборки из файла *Dockerfile* , который мне ещё предстоит создать. Dockerfile-это фактически сценарий установки, который выполняет шаги установки для развертывания приложения, а также некоторые параметры контейнера.

Вот базовый *Dockerfile* для Микроблога:

> Dockerfile: Dockerfile for Microblog.

    FROM python:3.6-alpine

    RUN adduser -D microblog

    WORKDIR /home/microblog

    COPY requirements.txt requirements.txt
    RUN python -m venv venv
    RUN venv/bin/pip install -r requirements.txt
    RUN venv/bin/pip install gunicorn

    COPY app app
    COPY migrations migrations
    COPY microblog.py config.py boot.sh ./
    RUN chmod +x boot.sh

    ENV FLASK_APP microblog.py

    RUN chown -R microblog:microblog ./
    USER microblog

    EXPOSE 5000
    ENTRYPOINT ["./boot.sh"]

Каждая строка в Dockerfile является командой. Команда `FROM` указывает базовый образ контейнера, на основе которого будет построен новый образ. Идея состоит в том, что вы начинаете с существующего образа, добавляете или изменяете некоторые особенности, и в конечном итоге получаете производный образ. На образ ссылаются именем и тегом, разделенными двоеточием. Тег используется в качестве механизма управления версиями, позволяя образу контейнера предоставлять несколько вариантов. Имя выбранного образа- `python` , который является официальным образом Docker для Python. Теги для этого образа позволяют указать версию интерпретатора и базовую операционную систему. Тег `3.6-alpine` выбирает интерпретатор Python 3.6, установленный в Alpine Linux. Дистрибутив Alpine Linux часто используется вместо более популярных, таких как Ubuntu из-за его небольшого размера. Вы можете увидеть, какие теги доступны для образа Python в [Python image repository](https://hub.docker.com/r/library/python/tags/) .

Команда `RUN` выполняет произвольную команду в контексте контейнера. Это похоже на ввод команды в командной строке оболочки. Команда `adduser-D microblog` создает нового пользователя с именем `microblog` . Большинство образов контейнеров имеют `root` в качестве пользователя по умолчанию, однако не рекомендуется запускать приложение от имени root, поэтому я создаю собственного пользователя.

Команда `WORKDIR` задает каталог по умолчанию, в котором будет установлено приложение. Когда я создал пользователя `microblog` выше, был создан домашний каталог, поэтому теперь я делаю этот каталог по умолчанию. Новый каталог по умолчанию будет применяться ко всем оставшимся командам в Dockerfile, а также позже при выполнении контейнера.

Команда `COPY` передает файлы с компьютера в файловую систему контейнера. Эта команда принимает два или более аргументов, исходный и конечный файлы или каталоги. Исходный файл(ы) должен быть относительно каталога, в котором находится Dockerfile. Назначение может быть абсолютным путем или путем относительно каталога, заданного в предыдущей команде `WORKDIR` . В этой первой команде копирования я копирую файл *requirements.txt* в домашний каталог пользователя `microblog` в файловой системе контейнера.

Теперь у меня есть файл *requirements.txt* в контейнере и я могу создать виртуальную среду, используя команду `RUN` . Сначала я создаю его, а затем устанавливаю все требования. Поскольку файл требований содержит только общие зависимости, я затем явно устанавливаю *gunicorn* , который я собираюсь использовать в качестве веб-сервера. В качестве альтернативы, я мог бы добавить *gunicorn* к моим файлам в *requirements.txt* .

Три команды `COPY` , которые следуют за установкой приложения в контейнер, копируя пакет *app* , каталог *migrations* с миграциями базы данных и скрипты *microblog.py* и *config.py* из каталога верхнего уровня. Кроме того, я копирую новый файл *boot.sh* , о котором я расскажу ниже.

Команда `RUN chmod` гарантирует, что этот неизвестный доселе файл *boot.sh* установлен правильно, как исполняемый файл. Если вы находитесь в файловой системе на основе Unix, и ваш исходный файл уже имеет признак исполняемого файла, то в скопированном файле также будет установлен исполняемый бит. Я добавил явную установку, потому что в Windows сложнее присвоить исполняемые биты. Если вы работаете в Mac OS X или Linux, вероятно это все не нужно, но не помешает в любом случае.

Команда `ENV` задает переменную среды внутри контейнера. Мне нужно установить `FLASK_APP` , который необходим для использования команды `flask` .

Следующая команда `RUN chown` задает владельца всех каталогов и файлов, которые были сохранены в */home/microblog* , как нового пользователя `microblog` . Несмотря на то, что я создал этого пользователя в корне Dockerfile, Пользователь по умолчанию для всех команд остался `root` , поэтому все эти файлы должны быть переключены на пользователя `microblog` , чтобы этот пользователь мог работать с ними при запуске контейнера.

Команда `USER` в следующей строке делает этого нового пользователя `microblog` по умолчанию для любых последующих инструкций, а также при запуске контейнера.

Команда `EXPOSE` настраивает порт для своего сервера. Это необходимо, чтобы Docker мог нужным образом настроить Сеть в контейнере. Я выбрал стандартный порт 5000, но это может быть любой порт.

Наконец, команда `ENTRYPOINT` определяет умолчание, для команды которая должна выполняться при запуске контейнера. Это команда, которая запустит веб-сервер приложений. Чтобы все было хорошо организовано, я решил создать для этого отдельный скрипт, и это *boot.sh* файл, который я скопировал в контейнер ранее. Вот содержимое этого скрипта:

> boot.sh: Docker container start-up script.

    #!/bin/sh
    source venv/bin/activate
    flask db upgrade
    flask translate compile
    exec gunicorn -b :5000 --access-logfile - --error-logfile - microblog:app

Это довольно стандартный сценарий запуска, который довольно похож на то, как были запущены развертывания в [главе 17](https://habrahabr.ru/post/352266/) и [главе 18](https://habrahabr.ru/topic/edit/352830/) . Я активирую виртуальную среду, Обновляю базу данных через платформу миграции, компилирую переводы языков и, наконец, запускаю сервер с *gunicorn* .

Обратите внимание на `exec` , который предшествует команде gunicorn. В сценарии оболочки `exec` запускает процесс, выполняющий сценарий, который должен быть заменен заданной командой, вместо того, чтобы запускать его как новый процесс. Это важно, потому что Docker связывает жизнь контейнера с первым процессом, который выполняется на нем. В случаях, подобных этому, когда процесс запуска не является основным процессом контейнера, необходимо убедиться, что основной процесс занимает место этого первого процесса, чтобы убедиться, что контейнер не завершается рано Docker.

Интересным аспектом Docker является то, что все выводимые данные контейнера, которые пишутся в `stdout` или `stderr` , будут захвачены и сохранены как журналы контейнера. По этой причине ключи `--access-logfile` и `--error-logfile` имеют в конце символ `-` , который направляет журнал в стандартный вывод и хранит в виде журнала Docker.

С помощью созданного Dockerfile теперь можно создать образ контейнера:

    $ docker build -t microblog:latest .

Аргумент `-t` , передаваемый команде `docker build` , задает имя и тег для нового образа контейнера. `.` указывает базовый каталог, в котором должен быть создан контейнер. Это каталог, в котором находится файл Docker. Процесс сборки будет оценивать все команды в файле Docker и создавать образ, который будет храниться на вашей собственной машине.

Вы можете получить список образов, которые вы локально используете с помощью команды `docker images` :

    $ docker images
    REPOSITORY    TAG          IMAGE ID        CREATED              SIZE
    microblog     latest       54a47d0c27cf    About a minute ago   216MB
    python        3.6-alpine   a6beab4fa70b    3 months ago         88.7MB

Этот список включает ваш новый образ, а также базовый, на котором он был построен. При внесении изменений в приложение можно обновить образ контейнера, выполнив команду build еще раз.

### Запуск контейнера

С уже созданным образом теперь можно запустить версию контейнера приложения. Это делается с помощью команды `docker run` , которая обычно принимает большое количество аргументов. Для начала я покажу вам простой пример:

    $ docker run --name microblog -d -p 8000:5000 --rm microblog:latest
    021da2e1e0d390320248abf97dfbbe7b27c70fefed113d5a41bb67a68522e91c

Параметр `--name` предоставляет имя для нового контейнера. Параметр `-d` указывает Docker запускать контейнер в фоновом режиме. Без ключа `-d` контейнер выполняется как приложение переднего плана, блокируя командную строку. Параметр `-p` сопоставляет порты контейнера с портами хоста. Первый порт-это порт на хост-компьютере, а порт справа-это порт внутри контейнера. Приведенный выше пример предоставляет порт 5000 в контейнере на порту 8000 в узле, таким образом, вы будете обращаться к приложению на 8000, даже при том, что внутренне контейнер использует 5000. Параметр `--rm` удаляет контейнер после его завершения. Хотя это не требуется, контейнеры, которые заканчиваются или прерываются, обычно больше не нужны, поэтому их можно автоматически удалить. Последним аргументом является имя образа контейнера и тег, используемый для контейнера. После выполнения приведенной выше команды, вы можете получить доступ к приложению на *<http://localhost:8000>* .

Результатом `docker run` является идентификатор (ID), назначенный новому контейнеру. Это длинная шестнадцатеричная строка, которую вы можете использовать, когда вам нужно ссылаться на контейнер в последующих командах. Фактически, только первые несколько символов необходимы, чтобы сделать идентификатор уникальным.

Если вы хотите увидеть, какие контейнеры запущены, вы можете использовать команду `docker ps` :

    $ docker ps
    CONTAINER ID  IMAGE             COMMAND      PORTS                   NAMES
    021da2e1e0d3  microblog:latest  "./boot.sh"  0.0.0.0:8000->5000/tcp  microblog

Как видите, даже команда `docker ps` сокращает идентификаторы контейнеров. Если теперь необходимо остановить контейнер, используйте `docker stop` :

    $ docker stop 021da2e1e0d3
    021da2e1e0d3

Напомню вам что, в конфигурации приложения есть несколько параметров, которые получены из переменных среды. Например, параметры секретного ключа Flask, URL базы данных и сервера электронной почты импортируются из переменных среды. В примере `docker run` выше я не беспокоился о них, поэтому все эти параметры конфигурации будут использовать значения по умолчанию.

В более реалистичном примере эти переменные среды будут устанавливаться внутри контейнера. Вы видели в предыдущем разделе, что установку переменных среды в *Dockerfile* выполняет команда `ENV` , и это удобная опция для переменных, которые будут статическими. Тем не менее, для переменных, зависящих от установки, не представляется возможным использовать их как часть процесса сборки, потому что хотелось бы иметь образ контейнера, который легко переносить. Если вы хотите передать свое приложение другому пользователю в качестве образа контейнера, вы хотите, чтобы этот человек мог использовать его как есть, а не перестраивать его с помощью других переменных.

Таким образом, переменные среды build-time могут быть полезны, но также необходимо иметь переменные среды run-time, которые можно задать с помощью команды `docker run` , и для этих переменных используется ключ `-e` . Следующий пример задает secret-key и электронную почту для аккаунта Gmail:

    $ docker run --name microblog -d -p 8000:5000 --rm -e SECRET_KEY=my-secret-key \
        -e MAIL_SERVER=smtp.googlemail.com -e MAIL_PORT=587 -e MAIL_USE_TLS=true \
        -e MAIL_USERNAME=<your-gmail-username> -e MAIL_PASSWORD=<your-gmail-password> \
        microblog:latest

Такая длина для `docker run` в командной строке не редкость из-за наличия множества определений переменных среды.

### Использование сторонних «Контейнерных» сервисов

Контейнерная версия Microblog выглядит неплохо, но я пока еще не очень много думал о хранении. Проблема в том, что я не задал переменную среды `DATABASE_URL` , и приложение использует базу данных SQLite по умолчанию, которая поддерживается файлом на диске. Как вы думаете, что произойдет с этим SQLite-файлом, когда вы остановите и удалите контейнер? Файл исчезнет!

Файловая система в контейнере является эфемерной, то есть она исчезает вместе с остановкой контейнера. Вы можете записывать данные в файловую систему, и данные будут доступны, если контейнер должен ее прочитать, но если по какой-либо причине вам нужно переработать контейнер и заменить его новым, любые данные, сохраненные приложением на диск будет потеряны навсегда.

Хорошей стратегией проектирования для приложения-контейнера является создание контейнеров приложения не зависящих от состояния ( *stateless* ). Если у вас есть контейнер, который имеет код приложения и не имеет данных, вы можете выбросить его и заменить новым без каких-либо проблем, контейнер становится действительно одноразовым, что является большим достижением с точки зрения упрощения развертывания обновлений.

Но, конечно, это означает, что данные должны быть помещены где-то за пределами контейнера приложения. Именно здесь вступает в игру фантастическая экосистема Docker. Реестр контейнеров Docker содержит большое разнообразие образов контейнеров. Я уже рассказал вам об образе контейнера Python, который я использую в качестве базового образа для своего контейнера Микроблога. Кроме того, Docker поддерживает образы для многих других языков, баз данных и других служб в реестре Docker, и если этого недостаточно, реестр также позволяет компаниям публиковать образы контейнеров для своих продуктов, а также обычным пользователям, таким как вы или я, публиковать свои собственные образы. Это означает, что усилия по установке сторонних служб сводятся к поиску соответствующего образа в реестре и запуску его с помощью команды `docker run` с соответствующими аргументами.

Итак, теперь я создам два дополнительных контейнера: один для базы данных MySQL и еще один для службы Elasticsearch, а затем я выполню длиннющую командную строку, которая запустит контейнер Microblog с кучей параметров, которые разрешат мне доступ к этим двум новым контейнерам.

### Добавление контейнера MySQL

Как и многие другие продукты и услуги, MySQL имеет общедоступные образы контейнеров, доступные в реестре Docker. Как и мой собственный контейнер Микроблог, MySQL полагается на переменные среды, которые должны быть переданы в `docker run` . Это настройки типа пароля, имени базы данных и т.д. Не смотря на то, что есть много образов MySQL в реестре, я решил использовать тот, который официально поддерживается командой MySQL. Вы можете найти подробную информацию об образе контейнера MySQL на его странице реестра: *<https://hub.docker.com/r/mysql/mysql-server/>* .

Если вы помните трудоемкий процесс настройки MySQL в [главе 17](https://habrahabr.ru/post/352266/) , то вы оцените Docker, увидев, как легко развернуть MySQL. Вот команда `docker run` , которая запускает сервер MySQL:

    $ docker run --name mysql -d -e MYSQL_RANDOM_ROOT_PASSWORD=yes \
        -e MYSQL_DATABASE=microblog -e MYSQL_USER=microblog \
        -e MYSQL_PASSWORD=<database-password> \
        mysql/mysql-server:5.7

Вот и все! На любой машине, на которой установлен Docker, вы можете выполнить приведенную выше команду и получить полностью установленный сервер MySQL со случайно сгенерированным паролем root, совершенно новую базу данных под названием `microblog` и пользователя с тем же именем и настройками полного доступа к базе данных. Обратите внимание, что вам нужно будет ввести правильный пароль в качестве значения для переменной среды `MYSQL_PASSWORD` .

Теперь на стороне приложения, как и для традиционного развертывания на Ubuntu, мне нужно добавить клиентский пакет MySQL. Я снова буду использовать `pymysql` , который я могу добавить в *Dockerfile* :

> Dockerfile: Add pymysql to Dockerfile.

    # ...
    RUN venv/bin/pip install gunicorn pymysql
    # ...

При каждом изменении приложения или файла Dockerfile образ контейнера необходимо перестроить:

    $ docker build -t microblog:latest .

Теперь я могу снова запустить Microblog, но на этот раз со ссылкой на контейнер базы данных, чтобы обе могли общаться через сеть:

    $ docker run --name microblog -d -p 8000:5000 --rm -e SECRET_KEY=my-secret-key \
        -e MAIL_SERVER=smtp.googlemail.com -e MAIL_PORT=587 -e MAIL_USE_TLS=true \
        -e MAIL_USERNAME=<your-gmail-username> -e MAIL_PASSWORD=<your-gmail-password> \
        --link mysql:dbserver \
        -e DATABASE_URL=mysql+pymysql://microblog:<database-password>@dbserver/microblog \
        microblog:latest

Параметр `--link` указывает Docker сделать еще один контейнер доступным. Аргумент содержит два имени, разделенных двоеточием. Первая часть-это имя или идентификатор контейнера для связи, в данном случае `mysql` , который я создал выше. Вторая часть определяет имя хоста, которое может использоваться в этом контейнере для ссылок (link-ов). Здесь я использую `dbserver` в качестве универсального имени, которое представляет сервер баз данных.

Когда связь между двумя контейнерами установлена, я могу установить переменную окружения `DATABASE_URL` , для направления SQLAlchemy на использование базы данных MySQL в другом контейнере. URL-адрес базы данных будет использовать `dbserver` -в качестве имени хоста базы данных, `microblog` -как имена базы данных и пользователя, и `пароль` -который вы выбрали при запуске MySQL.

Я заметил одну особенность, когда экспериментировал с контейнером MySQL, которая заключается в том, что запуск этого контейнера занимает несколько секунд до готовности принять соединения с базой данных. Если вы запустите подряд контейнер MySQL и контейнер приложения сразу после попытки скрипта *boot.sh* запустить `flask db migrate` может произойти сбой из-за того, что база данных не готова принимать подключения. Чтобы сделать мое решение более надежным, я решил добавить цикл повтора в *boot.sh* :

> *boot.sh* : Повтор попыток подключения к базе данных.

    #!/bin/sh
    source venv/bin/activate
    while true; do
        flask db upgrade
        if [[ "$?" == "0" ]]; then
            break
        fi
        echo Upgrade command failed, retrying in 5 secs...
        sleep 5
    done
    flask translate compile
    exec gunicorn -b :5000 --access-logfile - --error-logfile - microblog:app

Этот цикл проверки кода выхода команды `flask db upgrade` , и если он не равен нулю, значит, что что-то пошло не так, поэтому он делает паузу пять секунд, а затем повторяет попытку.

### Добавление контейнера Elasticsearch

В документации [Elasticsearch для Docker](https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html) представлен вариант запуска службы единым узлом для разработки и развертывания, готовый к работе с двумя узлами (two-node). Сейчас я собираюсь запустить docker с опцией single-node и использовать образ \"oss\", который имеет только движок с открытым исходным кодом. Контейнер запускается следующей командой:

    $ docker run --name elasticsearch -d -p 9200:9200 -p 9300:9300 --rm \
        -e "discovery.type=single-node" \
        docker.elastic.co/elasticsearch/elasticsearch-oss:6.1.1

Эта команда `docker run` имеет много общего с теми, которые я использовал для Microblog и MySQL, но есть несколько интересных различий. Во-первых, здесь два варианта `-p` , а это означает, что этот контейнер будет прослушивать два порта вместо одного. Оба порта 9200 и 9300 сопоставляются с теми же портами на хост-компьютере.

Следующее различие заключается в синтаксисе ссылки на образ контейнера. Для образов, которые я создавал локально, синтаксис был `<name>:<tag>` . Контейнер MySQL использует несколько более полный синтаксис с форматом `<account>/<name>:<tag>` , который подходит для ссылки на образы контейнеров в реестре Docker. Образ Elasticsearch, который я использую, соответствует шаблону `<registry>/<account><name>:<tag>` , который включает ещё и адрес реестра в качестве первого компонента. Этот синтаксис используется для образов, не размещенных в реестре Docker. В этом случае Elasticsearch запускает собственную службу реестра контейнеров в *docker.elastic.co* вместо использования основного реестра, поддерживаемого Docker.

Теперь, когда у меня работает служба Elasticsearch, я могу изменить команду запуска для моего контейнера Microblog, чтобы создать ссылку на неё и установить URL службы Elasticsearch:

    $ docker run --name microblog -d -p 8000:5000 --rm -e SECRET_KEY=my-secret-key \
        -e MAIL_SERVER=smtp.googlemail.com -e MAIL_PORT=587 -e MAIL_USE_TLS=true \
        -e MAIL_USERNAME=<your-gmail-username> -e MAIL_PASSWORD=<your-gmail-password> \
        --link mysql:dbserver \
        -e DATABASE_URL=mysql+pymysql://microblog:<database-password>@dbserver/microblog \
        --link elasticsearch:elasticsearch \
        -e ELASTICSEARCH_URL=http://elasticsearch:9200 \
        microblog:latest

Перед выполнением этой команды не забудьте остановить предыдущий контейнер Микроблога, если он все еще запущен. И, пожалуйста, будьте внимательны при настройке правильных паролей для базы данных и службы Elasticsearch в соответствующих местах команды.

Теперь у вас должна появиться возможность посетить *<http://localhost:8000>* и использовать функцию поиска. При возникновении ошибок их можно устранить, просмотрев журналы контейнеров. Скорее всего, вы захотите увидеть журналы для контейнера микроблога, где будут отображаться любые трассировки стека Python:

    $ docker logs microblog

### Реестр контейнеров Docker

Итак, теперь у меня есть полное приложение, работающее на Docker, используя три контейнера, два из которых общедоступные сторонние образы. Если вы хотите сделать свои собственные образы контейнеров доступными для других пользователей, то вы должны отправить их в реестр Docker, откуда любой может их заполучить.

Чтобы получить доступ к реестру Docker, перейдите по ссылке *<https://hub.docker.com>* и создайте учетную запись для себя. Убедитесь, что вы выбираете имя пользователя, которое вам нравится, потому что это будет использоваться во всех образах, которые вы публикуете.

Для доступа к учетной записи из командной строки необходимо войти в систему с помощью команды `docker login` :

    $ docker login

Если вы следовали моим инструкциям, теперь у вас есть образ под названием `microblog:latest` , хранящийся локально на вашем компьютере. Чтобы быть в состоянии добавить этот образ к реестру Docker, он должен быть переименован, чтобы использовать учетную запись, как образ от MySQL. Это делается с помощью команды `docker tag` :

    $ docker tag microblog:latest <your-docker-registry-account>/microblog:latest

Если вы снова заглянете в реестр образов с помощью `docker images` , вы не найдете там две нужные записи для Микроблога, исходную с именем `microblog:latest` и новую, которая также включает имя Вашей учетной записи. Это два псевдонима для одного и того же образа.

Чтобы опубликовать образ в реестре Docker, используйте команду `docker push` :

    $ docker push <your-docker-registry-account>/microblog:latest

Теперь ваш образ является общедоступным, и вам следует добавить документацию, как его установить и запустить из реестра Docker так же, как это делают MySQL и другие.

### Развертывание контейнерных приложений

Одна из лучших особенностей работы приложения в контейнерах Docker заключается в том, что после локального тестирования контейнеров их можно перенести на любую платформу, предлагающую поддержку Docker. Например, вы можете использовать те же серверы, которые я рекомендовал в [главе 17](https://habrahabr.ru/post/352266/) из Digital Ocean, Linode или Amazon Lightsail. Даже самое дешевое предложение от этих поставщиков достаточно для запуска Docker с несколькими контейнерами.

[Amazon Container Service (ECS)](https://aws.amazon.com/ecs/) позволяет создать кластер узлов контейнеров, на которых будут работать контейнеры, в полностью интегрированной среде AWS с поддержкой масштабирования и балансировки нагрузки, а также использовать частный реестр контейнеров для образов контейнеров.

Наконец, платформа для комбинирования контейнеров, такая как [Kubernetes](https://kubernetes.io/) , обеспечивает еще больший уровень автоматизации и удобства, позволяя вам описывать развертывания нескольких контейнеров в простых текстовых файлах в формате YAML с балансировкой нагрузки, масштабированием, управлением безопасности и последовательными обновлениями с возможностью отката в исходное состояние.
:::

Глава 20: Магия JavaScript
--------------------------

::: {#post-content-body .post__text .post__text-html io-article-url="https://habr.com/ru/post/353804/"}
### Поддержка на стороне сервера

Прежде чем мы углубимся в клиентскую часть, давайте немного поработаем с сервером, для понимания того, что необходимо для поддержки этих пользовательских всплывающих окон. Содержимое всплывающего окна пользователя будет возвращено новым маршрутом, который будет упрощенной версией уже существующего маршрута профиля пользователя. Вот функция, представления:

> *app/main/routes.py* : Функция всплывающего окна пользователя.

    @bp.route('/user/<username>/popup')
    @login_required
    def user_popup(username):
        user = User.query.filter_by(username=username).first_or_404()
        return render_template('user_popup.html', user=user)

Этот маршрут будет прикреплен к URL-адресу */user/ `<username>` /popup* и просто загрузит запрошенного пользователя, а затем отобразит шаблон с его данными, который является укороченной версией страницы профиля пользователя:

> *app/templates/user\_popup.html* : Шаблон всплывающего окна пользователя.

    <table class="table">
        <tr>
            <td width="64" style="border: 0px;"><img src="{{ user.avatar(64) }}"></td>
            <td style="border: 0px;">
                <p>
                    <a href="{{ url_for('main.user', username=user.username) }}">
                        {{ user.username }}
                    </a>
                </p>
                <small>
                    {% if user.about_me %}<p>{{ user.about_me }}</p>{% endif %}
                    {% if user.last_seen %}
                    <p>{{ _('Last seen on') }}: 
                       {{ moment(user.last_seen).format('lll') }}</p>
                    {% endif %}
                    <p>{{ _('%(count)d followers', count=user.followers.count()) }},
                       {{ _('%(count)d following', count=user.followed.count()) }}</p>
                    {% if user != current_user %}
                        {% if not current_user.is_following(user) %}
                        <a href="{{ url_for('main.follow', username=user.username) }}">
                            {{ _('Follow') }}
                        </a>
                        {% else %}
                        <a href="{{ url_for('main.unfollow', username=user.username) }}">
                            {{ _('Unfollow') }}
                        </a>
                        {% endif %}
                    {% endif %}
                </small>
            </td>
        </tr>
    </table>

Код JavaScript, который я напишу в следующих разделах, будет ссылаться на этот маршрут, когда пользователь наведёт указатель мыши на имя пользователя. В ответ сервер вернет содержимое HTML для всплывающего окна, которое затем отобразит клиентскую часть. Когда пользователь переместит мышь, всплывающее окно будет удалено. Звучит просто, не так ли?

Если вы хотите увидеть, как будет выглядеть всплывающее окно, вы можете запустить приложение, перейти на страницу профиля любого пользователя, а затем добавить */popup* к URL-адресу в адресной строке, чтобы просмотреть полноэкранную версию всплывающего содержимого.

### Введение в Bootstrap Popover Component

В [главе 11](https://habrahabr.ru/post/349060/) я познакомил вас с Bootstrap framework как удобным способом создания красиво отформатированных веб-страниц. До сих пор я использовал только минимальную часть этого фреймворка. Bootstrap поставляется в комплекте со многими общими элементами пользовательского интерфейса, все из которых имеют демонстрации и примеры в документации Bootstrap на *<https://getbootstrap.com>* . Одним из таких компонентов является [Popover](https://getbootstrap.com/docs/3.3/javascript/#popovers) , который описан в документации как \"небольшой накладной контент, для размещения дополнительной информации\". Именно то, что мне нужно!

Большинство компонентов bootstrap определяются с помощью разметки HTML, которая ссылается на определения CSS Bootstrap, которые добавляют стиль форматирования. Некоторые из самых продвинутых также требуют JavaScript. Стандартный способ, которым приложение включает эти компоненты на веб-странице, --- это добавление HTML в нужном месте, а затем для компонентов, которые нуждаются в поддержке сценариев, вызов функции JavaScript, которая инициализирует или активирует ее. Компонент popover требует поддержки JavaScript.

Часть HTML для создания popover очень проста, вам просто нужно определить элемент, который будет вызывать появление popover. В моем случае это будет кликабельное имя пользователя, которое появляется в каждом сообщении блога. В sub-шаблоне *app/templates/\_post.html* имя пользователя уже определено:

            <a href="{{ url_for('main.user', username=post.author.username) }}">
                {{ post.author.username }}
            </a>

Теперь в соответствии с документацией popover мне нужно вызвать JavaScript-функцию popover() для каждой ссылки, подобной приведенной выше на странице, и это приведет к инициализации всплывающего окна. Вызов инициализации принимает несколько параметров, которые настраивают всплывающее окно, включая параметры, которые передают содержимое для отображения во всплывающем окне, какой метод использовать, чтобы вызвать всплывающее окно для появления или исчезновения (щелчок, зависание над элементом и т.д. ), если содержимое представляет собой простой текст или HTML, и еще несколько параметров, которые вы можете увидеть на странице документации. К сожалению, после прочтения этой информации у меня появилось больше вопросов, чем ответов, потому, похоже, что этот компонент не предназначен для работы так, как мне это нужно. Ниже приведен список проблем, которые мне потребуется решить для реализации этой функции:

-   На странице будет много ссылок на имя пользователя, по одной для каждого сообщения в блоге. Мне нужен способ найти все эти ссылки из JavaScript после отображения страницы, чтобы я мог инициализировать их как всплывающие окна.
-   Примеры popover в документации Bootstrap предоставляют содержимое popover в качестве атрибута `data-content` , добавленного в целевой элемент HTML, поэтому, когда событие hover запускается, все, что требуется Bootstrap, это отобразить всплывающее окно. Это жутко неудобно для меня, потому что я хочу создать Ajax-вызов на сервер, чтобы получить контент, и только когда ответ сервера получен, всплывающее окно должно появиться.
-   При использовании режима\" hover\" всплывающее окно будет оставаться видимым до тех пор, пока вы удерживаете указатель мыши в целевом элементе. Когда вы переместите мышь, всплывающее окно исчезнет. Это имеет не приятный побочный эффект: если пользователь хочет переместить указатель мыши в само всплывающее окно, всплывающее окно исчезнет. Мне нужно будет как то расширить поведение у всплывающего окна при наведении, чтобы пользователь мог перейти в него и, например, щелкнуть там ссылку.

На самом деле это не так уж редко встречается при работе с приложениями на базе браузера, которые быстро усложняются. Вы должны достаточно глубоко продумывать зависимости взаимодействия друг с другом элементов DOM и заставить их вести себя таким образом, чтобы у пользователя остались только приятные впечатления.

### Выполнение функции при загрузке страницы

Понятно, что мне нужно будет запустить код JavaScript сразу после загрузки каждой страницы. Функция, которую я собираюсь запустить, будет искать все ссылки на имена пользователей на странице и настроить те, у которых есть компонент popover из Bootstrap.

Библиотека JavaScript jQuery загружается как зависимость от Bootstrap, поэтому я собираюсь воспользоваться ею. При использовании jQuery вы можете зарегистрировать функцию, которая будет запускаться при загрузке страницы, обернув ее в `$(...)` . Пожалуй, это следует добавить в шаблон *app/templates/base.html* , чтобы выполнялось на каждой странице приложения:

> *app/templates/base.html* : Запуск функции после загрузки страницы.

    ...
    <script>
        // ...

        $(function() {
            // write start up code here
        });
    </script>

Как видите, я добавил функцию start up в элемент `<script>` , в котором я определил функцию `translate()` в [главе 14](https://habrahabr.ru/post/350626/) .

### Поиск DOM-элементов с помощью Селекторов

Моя первая задача --- создать функцию JavaScript, которая будет находить все ссылки на странице. Эта функция будет срабатывать, когда страница завершит загрузку, и когда она будет завершена, настроит поведение зависания и всплывания окна для всех из них. Сейчас я сосредоточусь на поиске ссылок.

Если вспомнить из [главе 14](https://habrahabr.ru/post/350626/) , HTML-элементы, которые были задействованы в живых переводах, имели уникальные идентификаторы. Например, у записи с ID=123 был добавлен атрибут `id="post123"` . Затем с помощью jQuery выражение `$('#post123')` было использовано в JavaScript для нахождения этого элемента в DOM. Функция `$()` чрезвычайно мощна и имеет довольно сложный язык запросов для поиска элементов DOM, основанный на [CSS Selectors](https://api.jquery.com/category/selectors/) .

Селектор, который я использовал для функции перевода, был разработан, чтобы найти один конкретный элемент, который имел уникальный идентификатор, установленный в качестве атрибута `id` . Другой вариант идентификации элементов --- с помощью атрибута `class` , который может быть назначен нескольким элементам на странице. Например, я мог бы пометить все пользовательские ссылки `class="user_popup"` , а затем получить список ссылок из JavaScript с помощью `$('.user_popup')` (в селекторах CSS префикс `#` ищет по ID, в то время как `.` поиск префиксов по классам). Возвращаемое значение в этом случае будет представлять собой коллекцию всех элементов, имеющих класс.

### Popovers и DOM

Поиграв с примерами popover в документации Bootstrap и проверяя DOM в отладчике браузера, я определил, что Bootstrap создает компонент popover в качестве дочернего элемента целевого элемента в DOM. Как я уже упоминал выше, это влияет на поведение события hover, которое выведет «мышь», как только пользователь переместит указатель мышки от ссылки `<a>` и в само всплывающее окно.

Трюк, который я могу использовать для расширения события hover, чтобы включить popover, заключается в том, чтобы сделать popover дочерним элементом целевого элемента и тогда наведение hover наследуется. Просматривая опции popover в документации я обнаружил, что это можно сделать, передав родительский элемент в опции `container` .

Создание дочернего элемента popover из hover будет хорошо работать для кнопок или общих элементов `<div>` или `<span>` , но в моем случае целью для popover будет элемент `<a>` , который отображает ссылку на имя пользователя. Проблема с созданием дочернего элемента popover `<a>` состоит в том, что popover затем получит поведение ссылки родителя `<a>` . Конечный результат будет примерно таким:

        <a href="..." class="user_popup">
            username
            <div> ... popover elements here ... </div>
        </a>

Чтобы избежать появления popover внутри элемента `<a>` , будем использовать другой трюк. Я собираюсь обернуть элемент `<a>` внутри элемента `<span>` , а затем связать событие hover и popover с `<span>` . Результирующая структура будет такая:

        <span class="user_popup">
            <a href="...">
                username
            </a>
            <div> ... popover elements here ... </div>
        </span>

Элементы `<div>` и `<span>` невидимы, поэтому они являются отличными элементами, которые помогут вам организовать и структурировать DOM. Элемент `<div>` является *блочным элементом* , похожим на абзац в документе HTML, в то время как элемент `<span>` является *строковым элементом* , который сравним со словом. Для этого случая я решил использовать элемент `<span>` , так как элемент `<a>` , который я обертываю, также является строковым элементом.

Теперь надо реорганизовать мой подшаблон *app/templates/\_post.html* , чтобы включить элемент `<span>` :

    ...
                {% set user_link %}
                    <span class="user_popup">
                        <a href="url_for('main.user', username=post.author.username)">
                            {{ post.author.username }}
                        </a>
                    </span>
                {% endset %}
    ...

Если вам интересно, где находятся элементы popover HTML, то хорошей новостью является то, что мне не нужно беспокоиться об этом. Когда я получаю вызов функции инициализации `popover()` в элементах `<span>` , которые я только что создал, среда Bootstrap будет динамически вставлять компонент popup.

### События Hover (наведения)

Как я уже упоминал выше, поведение наведения, используемое компонентом popover из Bootstrap, недостаточно гибко для удовлетворения моих потребностей, но если вы посмотрите на документацию для опции `trigger` , «hover (зависание)» --- это всего лишь одно из возможных значений. Мой взгляд привлек режим «manual», в котором popover может отображаться или удаляться вручную выполнеием вызова JavaScript. Этот режим даст мне свободу в реализации логики зависания, поэтому я собираюсь использовать этот параметр и реализовать мои собственные обработчики событий hover, которые работают так, как они мне нужны.

Поэтому мой следующий шаг --- прикрепить событие «hover» ко всем ссылкам на странице. Используя jQuery, событие hover можно привязать к любому элементу HTML, вызвав `element.hover (handlerIn, handlerOut)` . Если эта функция вызывается в наборе элементов, jQuery удобно прикрепляет событие ко всем из них. Два аргумента --- это две функции, вызываемые, когда пользователь перемещает указатель мыши в и из целевого элемента соответственно.

> *app/templates/base.html* : Hover event.

    $(function() {
        $('.user_popup').hover(
            function(event) {
                // mouse in event handler
                var elem = event.currentTarget;
            },
            function(event) {
                // mouse out event handler
                var elem = event.currentTarget;
            }
        )
    });

Аргумент `event` является объектом event, который содержит полезную информацию. В этом случае я извлекаю элемент, который был целью события, используя `event.currentTarget` .

Браузер отправляет событие hover сразу после того, как мышь войдет область влияющего элемента. В случае всплывающего окна, хотелось бы, чтобы событие активировалось только после ожидания небольшого периода времени, когда мышь задерживается на элементе, так что, когда указатель мыши ненадолго проходит над элементом, но не останавливается на нем нет мгновенно всплывающих мигающих окон. Поскольку событие не приходит с поддержкой задержки, это еще одна вещь, которую я собираюсь реализовать сам. Наверное надо добавить секундный Таймер в обработчик событий \"mouse in\":

> *app/templates/base.html* : Задержка при наведении.

    $(function() {
        var timer = null;
        $('.user_popup').hover(
            function(event) {
                // обработчик события mouse in
                var elem = event.currentTarget;
                timer = setTimeout(function() {
                    timer = null;
                    // логика Popup должна быть здесь
                }, 1000);
            },
            function(event) {
                //обработчик события mouse out
                var elem = event.currentTarget;
                if (timer) {
                    clearTimeout(timer);
                    timer = null;
                }
            }
        )
    });

Функция `setTimeout()` доступна в среде браузера. Она принимает два аргумента: функцию и время в миллисекундах. Эффект `setTimeout()` заключается в том, что функция вызывается после заданной задержки. Поэтому я добавил функцию, которая пока пуста, которая будет вызвана через секунду после отправки события hover. Благодаря замыканиям на языке JavaScript эта функция может обращаться к переменным, определенным во внешней области видимости, таким как `elem` .

Я сохраняю объект timer в переменной `timer` , которую я определил вне вызова `hover()` , чтобы сделать объект timer доступным также для обработчика \"mouse out\". Причина, по которой мне это нужно, еще раз, чтобы оставить приятное впечатление пользователю. Если пользователь перемещает указатель мыши в одну из этих пользовательских ссылок и остается на ней, но скажем, за полсекунды до ее срабатывания перемещает указатель мыши, в этом случае я не хочу, чтобы Таймер досчитал свою задержку и вызывал функцию, которая будет отображать всплывающее окно. Поэтому мой обработчик событий mouse out проверяет, есть ли активный объект timer, и если есть, то отменяет его.

### Запрос AJAX

Запросы Ajax не являются новой темой, так как я уже говорил об этом в [главе 14](https://habrahabr.ru/post/350626/) , как часть живого языка перевода. При использовании jQuery, функция `$.ajax()` отправит асинхронный запрос на сервер.

Запрос, который я собираюсь отправить на сервер, будет иметь URL */user/ `<username>` /popup* , который я добавил в приложение в начале этой главы. Ответ от этого запроса будет содержать HTML, который мне нужно вставить во всплывающее окно.

Моя непосредственная проблема относительно этого запроса состоит в том, чтобы знать, каково значение `username` , которое мне нужно включить в URL. Функция mouse in event handler является универсальной, она будет работать для всех пользовательских ссылок, которые находятся на странице, поэтому функция должна определить имя пользователя из своего контекста.

Переменная `elem` содержит целевой элемент из события hover, который является элементом `<span>` , который обертывает элемент `<a>` . Чтобы извлечь имя пользователя, я могу перемещаться по DOM, начиная с `<span>` , переходя к первому дочернему элементу, который является элементом `<a>` , а затем извлекая из него текст, который является именем пользователя, которое мне нужно использовать в моем URL. С функциями обхода DOM jQuery это сделать не сложно:

    elem.first().text().trim()

Функция `first()` , примененная к узлу DOM, возвращает его первый дочерний элемент. Функция `text()` возвращает текстовое содержимое узла. Эта функция не выполняет обрезку текста, поэтому, например, если `<a>` находится в одной строке, текст в следующей строке и `</a>` в другой строке, функция `text()` вернет все пробелы, которые окружают текст. Чтобы устранить все пробелы и оставить только текст, я использую функцию JavaScript `trim()` .

И это вся информация, которая мне нужна, чтобы иметь возможность выдать запрос на сервер:

> *app/templates/base.html* : XHR запрос.

    $(function() {
        var timer = null;
        var xhr = null;
        $('.user_popup').hover(
            function(event) {
                // обработчик события mouse in
                var elem = $(event.currentTarget);
                timer = setTimeout(function() {
                    timer = null;
                    xhr = $.ajax(
                        '/user/' + elem.first().text().trim() + '/popup').done(
                            function(data) {
                                xhr = null
                                //  здесь создаём и отображаем всплывающее окно
                            }
                        );
                }, 1000);
            },
            function(event) {
                // обработчик события mouse out
                var elem = $(event.currentTarget);
                if (timer) {
                    clearTimeout(timer);
                    timer = null;
                }
                else if (xhr) {
                    xhr.abort();
                    xhr = null;
                }
                else {
                    //  здесь разрушаем всплывающее окно
                }
            }
        )
    });

Здесь я определил новую переменную во внешней области видимости, `xhr` . Эта переменная будет содержать асинхронный объект запроса, который я инициализирую из вызова `$.ajax()` . К сожалению, при построении URL непосредственно на стороне JavaScript я не могу использовать `url_for()` из Flask, поэтому в этом случае я должен явно объединить части URL.

Вызов `$.ajax()` возвращает promise (обязательство), который является специальным объектом JavaScript, представляющим асинхронную операцию. Я могу прикрепить обратный вызов завершения, добавив `.done (function)` , поэтому моя функция обратного вызова будет вызвана после завершения запроса. Функция обратного вызова получит ответ в качестве аргумента, который я назвал `data` и Вы можете увидеть его в коде выше. Это будет HTML-контент, который я собираюсь поместить в popover.

Но прежде чем мы доберемся до popover, есть еще одна деталь, связанная с предоставлением пользователю удобного интерфейса и хорошего настроения, о которой нужно позаботиться. Напомним, что я добавил логику в функцию обработчика событий \"mouse out\", чтобы отменить таймаут в одну секунду, если пользователь переместил указатель мыши из `<span>` . Та же идея должна быть применена к асинхронному запросу, поэтому я добавил второе условие, чтобы прервать мой объект запроса `xhr` , если он существует.

### Создание и Разрушение Popover

Настал значительный момент.

Могу создать popover компонент,

Используя лишь `data` -аргумент

Из функции callback Ajax мне возвращенный:

> *app/templates/base.html* : Отображение всплывающего окна.

                                function(data) {
                                    xhr = null;
                                    elem.popover({
                                        trigger: 'manual',
                                        html: true,
                                        animation: false,
                                        container: elem,
                                        content: data
                                    }).popover('show');
                                    flask_moment_render_all();
                                }

Фактическое создание всплывающего окна не так уж и сложно, функция `popover()` из Bootstrap выполнит всю работу, необходимую для его настройки. Параметры для popover приведены в качестве аргумента. Я настроил этот popover с \"ручным\" режимом триггера, HTML-контентом, без анимации затухания (так что он появляется и исчезает быстрее), и я установил родительский элемент как сам элемент `<span>` , так что поведение при наведении распространяется на popover по наследованию. Наконец, я передаю аргумент `data` в обратный вызов Ajax в качестве аргумента `content` .

Возврат вызова `popover()` недавно появившийся компонент popover, который по странной причине имел другой метод, также называемый `popover()` , который используется для его отображения. Поэтому мне пришлось добавить второй вызов `popover('show')` , чтобы всплывающее окно появилось на странице.

Содержимое всплывающего окна включает в себя дату \"last seen\" (последнего посещения), которая генерируется через плагин Flask-Moment, как описано в [главе 12](https://habrahabr.ru/post/349604/) . Как описано в [документации](https://github.com/miguelgrinberg/Flask-Moment#ajax-support) расширения для добавления новых элементов Flask-Moment через Ajax, функция `flask_moment_render_all()` должна быть вызвана для соответствующего отображения этих элементов.

Остается разобраться с удалением всплывающего окна при обработке события mouse out. У этого обработчика уже есть логика для прерывания операции popover, если она прерывается пользователем, перемещающим курсор мыши из целевого элемента. Если ни одно из этих условий не применимо, это означает, что всплывающее окно в настоящее время отображается, и Пользователь покидает целевую область, поэтому в этом случае вызов `popover('destroy')` к целевому элементу выполнит надлежащее в этом случае удаление и очистку.

> *app/templates/base.html* : Разрушение popover.

                function(event) {
                    // mouse out event handler
                    var elem = $(event.currentTarget);
                    if (timer) {
                        clearTimeout(timer);
                        timer = null;
                    }
                    else if (xhr) {
                        xhr.abort();
                        xhr = null;
                    }
                    else {
                        elem.popover('destroy');
                    }
                }
:::

Глава 21: Уведомления пользователей
-----------------------------------

::: {#post-content-body .post__text .post__text-html io-article-url="https://habr.com/ru/post/354322/"}
### Личные сообщения

Функция личных сообщений, которую я собираюсь реализовать, будет очень простой. Когда вы посещаете страницу профиля пользователя, там будет ссылка, для отправки этому пользователю личного сообщения. Ссылка переведет вас на новую страницу, в которой есть веб-форма приема сообщения. Для чтения сообщений, отправленных вам, панель навигации в верхней части страницы будет иметь новую ссылку \"Messages\" (\"Сообщения\"), которая приведет вас на страницу, похожую по структуре на страницы index или explore, но вместо показа сообщений в блоге она будет показывать сообщения других пользователей, отправленных вам.

В следующих разделах описаны шаги, которые я принял для реализации этой функции.

### Поддержка баз данных для личных сообщений

Первая задача заключается в расширении базы данных для поддержки личных сообщений. Вот новая модель сообщения:

> **app/models.py** : *Message model.*

    class Message(db.Model):
        id = db.Column(db.Integer, primary_key=True)
        sender_id = db.Column(db.Integer, db.ForeignKey('user.id'))
        recipient_id = db.Column(db.Integer, db.ForeignKey('user.id'))
        body = db.Column(db.String(140))
        timestamp = db.Column(db.DateTime, index=True, default=datetime.utcnow)

        def __repr__(self):
            return '<Message {}>'.format(self.body)

Этот класс модели аналогичен модели `Post` , с единственной разницей, что существует два внешних ключа пользователя, один для отправителя и один для получателя. Модель `User` может получить отношения для этих двух пользователей, а также новое поле, указывающее, что было в последний раз, когда пользователи читали свои личные сообщения:

> **app/models.py** : *Поддержка личных сообщений в пользовательской модели (User model)* .

    class User(UserMixin, db.Model):
        # ...
        messages_sent = db.relationship('Message',
                                        foreign_keys='Message.sender_id',
                                        backref='author', lazy='dynamic')
        messages_received = db.relationship('Message',
                                            foreign_keys='Message.recipient_id',
                                            backref='recipient', lazy='dynamic')
        last_message_read_time = db.Column(db.DateTime)

        # ...

        def new_messages(self):
            last_read_time = self.last_message_read_time or datetime(1900, 1, 1)
            return Message.query.filter_by(recipient=self).filter(
                Message.timestamp > last_read_time).count()

Эти две связи будут возвращать сообщения, отправленные и полученные для данного пользователя, а на стороне отношения `Message` будут добавлены ссылки на `author` и `recipient` . Причина, по которой я использовал *backref* (обратную ссылку) `author` вместо, возможно, более подходящего `sender` (отправитель), заключается в том, что с помощью `author` я могу визуализировать эти сообщения, используя ту же логику, которую я использую для сообщений в блоге. Поле `last_message_read_time` будет содержать *last time* , когда пользователь последний раз посещал страницу сообщений, и будет использоваться, чтобы определить, есть ли непрочитанные сообщения, которые будут иметь метку времени более новую, чем в этом поле. Вспомогательный метод `new_messages()` фактически использует это поле для возврата количества непрочитанных сообщений пользователя. К концу этой главы у меня будет это число отображаться в качестве значка на панели навигации в верхней части страницы.

Это завершает изменения базы данных, поэтому теперь пришло время создать новую миграцию и обновить базу данных с ней:

    (venv) $ flask db migrate -m "private messages"
    (venv) $ flask db upgrade

### Отправка личного сообщения

Далее я собираюсь работать над отправкой сообщений. Мне понадобится простая веб-форма, позволяющая набрать сообщение:

> **app/main/forms.py:** *Класс формы личного сообщения.*

    class MessageForm(FlaskForm):
        message = TextAreaField(_l('Message'), validators=[
            DataRequired(), Length(min=0, max=140)])
        submit = SubmitField(_l('Submit'))

И мне также нужен шаблон HTML, который отображает эту форму на веб-странице:

> **app/templates/send\_message.html:** *HTML шаблон Отправки личного сообщения.*

    {% extends "base.html" %}
    {% import 'bootstrap/wtf.html' as wtf %}

    {% block app_content %}
        <h1>{{ _('Send Message to %(recipient)s', recipient=recipient) }}</h1>
        <div class="row">
            <div class="col-md-4">
                {{ wtf.quick_form(form) }}
            </div>
        </div>
    {% endblock %}

Далее я собираюсь добавить *new /send\_message/ для обработки фактической отправки личного сообщения:*

> **app/main/routes.py:** *Маршрут отправки личного сообщения.*

    from app.main.forms import MessageForm
    from app.models import Message

    # ...

    @bp.route('/send_message/<recipient>', methods=['GET', 'POST'])
    @login_required
    def send_message(recipient):
        user = User.query.filter_by(username=recipient).first_or_404()
        form = MessageForm()
        if form.validate_on_submit():
            msg = Message(author=current_user, recipient=user,
                          body=form.message.data)
            db.session.add(msg)
            db.session.commit()
            flash(_('Your message has been sent.'))
            return redirect(url_for('main.user', username=recipient))
        return render_template('send_message.html', title=_('Send Message'),
                               form=form, recipient=recipient)

Я думаю, что логика в этой функции должна быть в основном понятной. Действие отправки личного сообщения просто выполняется путем добавления нового экземпляра `Message` в базу данных.

Последнее изменение, связывающее все вместе, --- это добавление ссылки на указанный выше маршрут на странице профиля пользователя:

> **app/templates/user.html:** Ссылка отправки личного сообщения на странице профиля пользователя.

                {% if user != current_user %}
                <p>
                    <a href="{{ url_for('main.send_message',
                                        recipient=user.username) }}">
                        {{ _('Send private message') }}
                    </a>
                </p>
                {% endif %}

### Просмотр Личных Сообщений

Вторая большая часть этой функции --- просмотр личных сообщений. Для этого я собираюсь добавить еще один маршрут в */messages* , который работает довольно похожим образом на индекс и исследует страницы, включая полную поддержку разбиения на страницы:

> **app/main/routes.py:** *Просмотр messages route.*

    @bp.route('/messages')
    @login_required
    def messages():
        current_user.last_message_read_time = datetime.utcnow()
        db.session.commit()
        page = request.args.get('page', 1, type=int)
        messages = current_user.messages_received.order_by(
            Message.timestamp.desc()).paginate(
                page, current_app.config['POSTS_PER_PAGE'], False)
        next_url = url_for('main.messages', page=messages.next_num) \
            if messages.has_next else None
        prev_url = url_for('main.messages', page=messages.prev_num) \
            if messages.has_prev else None
        return render_template('messages.html', messages=messages.items,
                               next_url=next_url, prev_url=prev_url)

Первое, что я делаю в этой функции просмотра, --- это обновление `User.last_message_read_time` поля с текущим временем. Маркирую все сообщения, которые были отправлены этому пользователю как прочитанные. Затем я запрашивая модель `Message` список сообщений, отсортированных по метке от новых к старым. Я решил использовать элемент `POSTS_PER_PAGE` конфигурации со страницы постов и сообщений, которые будут очень похожи, но, конечно, если страницы будут расхожими, возможно, имеет смысл добавить отдельную переменную для сообщений. Логика разбиения на страницы идентична тому, что я использовал для сообщений, поэтому все это должно быть вам знакомо.

Функция view выше заканчивается рендерингом файла шаблона */app/templates/messages.html* , который Вы можете увидеть ниже:

> **app/templates/messages.html:** HTML-шаблон просмотра сообщений.

    {% extends "base.html" %}

    {% block app_content %}
        <h1>{{ _('Messages') }}</h1>
        {% for post in messages %}
            {% include '_post.html' %}
        {% endfor %}
        <nav aria-label="...">
            <ul class="pager">
                <li class="previous{% if not prev_url %} disabled{% endif %}">
                    <a href="{{ prev_url or '#' }}">
                        <span aria-hidden="true">&larr;</span> {{ _('Newer messages') }}
                    </a>
                </li>
                <li class="next{% if not next_url %} disabled{% endif %}">
                    <a href="{{ next_url or '#' }}">
                        {{ _('Older messages') }} <span aria-hidden="true">&rarr;</span>
                    </a>
                </li>
            </ul>
        </nav>
    {% endblock %}

Здесь я прибегнул к еще одному маленькому трюку. Я заметил, что экземпляры `Post` и `Message` имеют почти одинаковую структуру, за исключением того, что `Message` получает дополнительную связь с `recipient` (что мне не нужно показывать на странице Сообщений, так как это всегда текущего пользователя). Поэтому я решил повторно использовать суб-шаблон *app/templates/\_post.html* также для отображения личных сообщений. По этой причине этот шаблон использует специфический цикл for-loop для `for post in messages` , так что все ссылки на `post` в суб-шаблоне также работают с сообщениями.

Чтобы предоставить пользователям доступ к новой функции просмотра, страница навигации получает новую ссылку \"Messages\":

> **app/templates/base.html:** *Messages link в панели навигации.*

                    {% if current_user.is_anonymous %}
                    ...
                    {% else %}
                    <li>
                        <a href="{{ url_for('main.messages') }}">
                            {{ _('Messages') }}
                        </a>
                    </li>
                    ...
                    {% endif %}

Эта функция в настоящее время завершена, но в рамках всех этих изменений появились некоторые новые тексты, которые были добавлены в нескольких местах, и они должны быть включены в языковые переводы. Первым шагом является обновление всех языковых каталогов:

    (venv) $ flask translate update

Тогда каждый из языков в *app/translations* должен иметь свои *messages.po* файл обновляется с новыми переводами. Вы можете найти испанские переводы в репозитории GitHub для этого проекта или в [ZIP-файле](https://github.com/miguelgrinberg/microblog/archive/version-0.21.zip) .

### Статический Значок Уведомления

Теперь функция личных сообщений реализована, но, конечно, нет ничего, что говорит пользователю, что есть личные сообщения, ожидающие прочтения. Простейшая реализация индикатора панели навигации может быть отображена как часть базового шаблона с помощью виджета Bootstrap badge:

> **app/templates/base.html:** Значок счетчика статических сообщений в навигационной панели.

                    ...
                    <li>
                        <a href="{{ url_for('main.messages') }}">
                            {{ _('Messages') }}
                            {% set new_messages = current_user.new_messages() %}
                            {% if new_messages %}
                            <span class="badge">{{ new_messages }}</span>
                            {% endif %}
                        </a>
                    </li>
                    ...

Здесь я вызываю метод `new_messages()` , который я добавил в модель `User` выше непосредственно из шаблона, и сохраняю это число в переменной шаблона `new_messages` . Затем, если эта переменная не равна нулю, я просто добавляю значок с номером рядом со ссылкой Messages. Вот как это выглядит на странице:

![](https://habrastorage.org/webt/kf/_h/gq/kf_hgqmhvwt190hhhyxypmqnnzi.png)

### Динамический Значок Уведомления

Решение, представленное в предыдущем разделе, является достойным и простым способом показать уведомление, но у него есть недостаток, заключающийся в том что значок появляется только при загрузке новой страницы. Если пользователь долго читает контент на одной странице, не нажимая на какие-либо ссылки, новые сообщения, которые приходят в течение этого времени, не будут отображаться, пока пользователь, наконец, не нажмет на ссылку и не загрузит новую страницу.

Чтобы сделать это приложение более полезным для моих пользователей, я хочу, чтобы значок обновлял количество непрочитанных сообщений самостоятельно, без необходимости нажимать на ссылки и загружать новые страницы. Одна из проблем с решением из предыдущего раздела заключается в том, что значок отображается на странице только тогда, когда количество сообщений в момент загрузки страницы было ненулевым. Что действительно более удобно, так это всегда включать значок в панель навигации и отмечать его как скрытый, когда количество сообщений равно нулю. Это позволит легко сделать значок видимым с помощью JavaScript:

> **app/templates/base.html:** *Значок непрочитанных сообщений, совместимый с JavaScript.*

                    <li>
                        <a href="{{ url_for('main.messages') }}">
                            {{ _('Messages') }}
                            {% set new_messages = current_user.new_messages() %}
                            <span id="message_count" class="badge"
                                  style="visibility: {% if new_messages %}visible
                                                     {% else %}hidden {% endif %};">
                                {{ new_messages }}
                            </span>
                        </a>
                    </li>

В этой версии значка он всегда включен. Но! Свойство CSS `visible` установлено в `visible` , когда `new_messages` ненулевое и скрыто, если равно нулю. Я также добавил атрибут `id` к элементу `<span>` , который представляет значок, чтобы упростить обращение к этому элементу с помощью селектора jQuery `$('#message_count')` .

Теперь я могу кодировать короткую функцию JavaScript, которая обновляет этот значок до нового номера:

> **app/templates/base.html:** Значок счетчика статических сообщений в навигационной панели.

    ...
    {% block scripts %}
        <script>
            // ...
            function set_message_count(n) {
                $('#message_count').text(n);
                $('#message_count').css('visibility', n ? 'visible' : 'hidden');
            }
        </script>
    {% endblock %}

Новая функция `set_message_count()` устанавливает количество сообщений в элементе badge, а также настраивает видимость так, чтобы значок был скрыт, когда счетчик равен 0, и виден в противном случае.

### Доставка уведомлений клиентам

Теперь остается добавить механизм, с помощью которого клиент получает периодические обновления относительно количества непрочитанных сообщений, которые имеет пользователь. Когда происходит одно из этих обновлений, клиент вызывает функцию `set_message_count()` , чтобы сделать обновление известным пользователям.

На самом деле есть два метода на сервере, чтобы доставить эти обновления клиенту, и, как вы, вероятно, догадываетесь, у обоих есть плюсы и минусы, поэтому какой из них выбрать в значительной степени зависит от проекта. При первом подходе клиент периодически запрашивает у сервера обновления, отправляя асинхронный запрос. Ответ на этот запрос представляет собой список обновлений, которые клиент может использовать для обновления различных элементов страницы, таких как значок счетчика непрочитанных сообщений. Второй подход требует особого типа соединения между клиентом и сервером, что позволяет серверу свободно передавать данные клиенту. Обратите внимание, что независимо от подхода, я хочу рассматривать уведомления как общие сущности, чтобы я мог расширить эту платформу для поддержки других типов событий, кроме значка непрочитанных сообщений.

Самое главное, что есть в первом решении, это то, что его легко реализовать. Все, что мне нужно сделать, это добавить еще один маршрут к приложению, say */notifications* , который вернет JSON список уведомлений. Затем клиентское приложение просматривает список уведомлений и применяет необходимые изменения к странице для каждого из них. Недостатком этого решения является то, что будет задержка между фактическим событием и уведомлением для него, потому что клиент будет запрашивать список уведомлений через регулярные промежутки времени. Например, если клиент запрашивает уведомления каждые 10 секунд, уведомление может быть получено с задержкой до 10 секунд.

Второе решение требует изменений на уровне протокола, поскольку HTTP не имеет никаких условий для отправки сервером данных на клиент без запроса клиента. На сегодняшний день наиболее распространенным способом реализации сообщений, инициированных сервером, является расширение сервера для поддержки соединений [WebSocket](https://en.wikipedia.org/wiki/WebSocket) в дополнение к HTTP. WebSocket --- это протокол, который в отличие от HTTP устанавливает постоянное соединение между сервером и клиентом. Сервер и клиент могут одновременно отправлять данные другой стороне, не обращая внимания на другую сторону. Преимущество этого механизма заключается в том, что всякий раз, когда возникает событие, представляющее интерес для клиента, сервер может отправлять уведомление без каких-либо задержек. Недостатком является то, что WebSocket требует более сложной настройки, чем HTTP, потому что серверу необходимо поддерживать постоянное соединение с каждым клиентом. Представьте себе, что сервер, который, например, имеет четыре рабочих процесса, обычно может обслуживать несколько сотен HTTP-клиентов, поскольку соединения в HTTP недолговечны и постоянно перерабатываются. Тот же сервер сможет обрабатывать только четыре клиента WebSocket, которые в подавляющем большинстве случаев будут недостаточными. Именно для этого ограничения приложения WebSocket обычно разрабатываются вокруг *асинхронных* серверов, поскольку эти серверы более эффективны при управлении большим числом рабочих и активных соединений.

Хорошей новостью является то, что независимо от метода, который вы используете, в клиенте у вас будет функция обратного вызова ( *callback* ), которая будет вызвана со списком обновлений. Поэтому я мог бы начать с первого варианта, которое гораздо проще реализовать, а затем, если я найду его недостаточным, перейду на сервер WebSocket, который можно настроить для вызова того же обратного вызова клиента. На мой взгляд, для данного вида применения первое решение на самом деле приемлемо. Реализация на основе WebSocket была бы полезна для приложения, которое требует, чтобы обновления доставлялись с почти нулевой задержкой.

Если вам интересно, Twitter также использует первый подход для уведомлений панели навигации. Facebook использует вариант, называемый [Long\_polling](https://en.wikipedia.org/wiki/Push_technology#Long_polling) , который устраняет некоторые ограничения прямого опроса, все еще используя HTTP-запросы. Stack Overflow и Trello --- это два Сайта, которые реализуют WebSocket для своих уведомлений. Вы можете узнать, какой тип фоновой активности происходит на любом сайте, просмотрев вкладку Network в отладчике браузера.

Итак, давайте продолжим и реализуем решение опроса. Во-первых, я собираюсь добавить новую модель, чтобы отслеживать уведомления для всех пользователей, а также отношения в пользовательской модели.

> **app/models.py:** *Модель уведомлений.*

    import json
    from time import time

    # ...

    class User(UserMixin, db.Model):
        # ...
        notifications = db.relationship('Notification', backref='user',
                                        lazy='dynamic')

        # ...

    class Notification(db.Model):
        id = db.Column(db.Integer, primary_key=True)
        name = db.Column(db.String(128), index=True)
        user_id = db.Column(db.Integer, db.ForeignKey('user.id'))
        timestamp = db.Column(db.Float, index=True, default=time)
        payload_json = db.Column(db.Text)

        def get_data(self):
            return json.loads(str(self.payload_json))

Уведомление будет иметь имя, связанного пользователя, метку времени Unix и полезную нагрузку. Метка времени получает свое значение по умолчанию от функции `time.time()` . Полезная нагрузка будет отличаться для каждого типа уведомления, поэтому я пишу ее как строку JSON, поскольку это позволит мне писать списки, словари или отдельные значения, такие как числа или строки. Для удобства я добавил метод `get_data()` , чтобы вызывающему не пришлось беспокоиться о десериализации JSON.

Эти изменения необходимо включить в новую миграцию базы данных:

    (venv) $ flask db migrate -m "notifications"
    (venv) $ flask db upgrade

Для удобства я собираюсь добавить новые модели `Message` и `Notification` в контекст оболочки, чтобы при запуске оболочки с помощью команды `flask shell` класс модели автоматически импортировался для меня:

> **microblog.py:** *Добавление модели сообщения в контекст оболочки.*

    # ...
    from app.models import User, Post, Notification, Message

    # ...

    @app.shell_context_processor
    def make_shell_context():
        return {'db': db, 'User': User, 'Post': Post, 'Message': Message
                'Notification': Notification}

Я также собираюсь добавить вспомогательный метод `add_notification()` в пользовательскую модель, чтобы упростить работу с этими объектами:

> **app/models.py:** Модель уведомления.

    class User(UserMixin, db.Model):
        # ...

        def add_notification(self, name, data):
            self.notifications.filter_by(name=name).delete()
            n = Notification(name=name, payload_json=json.dumps(data), user=self)
            db.session.add(n)
        return n

Этот метод не только добавляет уведомление для пользователя в базу данных, но также гарантирует, что если уведомление с тем же именем уже существует, оно будет удалено. Уведомление, с которым я собираюсь работать, будет называться `unread_message_count` . Если в базе данных уже есть уведомление с этим именем, например, с 3-мя значениями на момент, когда пользователь получает новое сообщение, а количество сообщений дойдет до 4, я хочу заменить старое уведомление.

В любом месте, где изменяется количество непрочитанных сообщений, мне нужно вызвать `add_notification()` , чтобы обновить мои уведомления для пользователя. Есть два места, где это изменяется. Во-первых, когда пользователь получает новое личное сообщение в функции `send_message()` :

> **app/main/routes.py:** Обновление уведомления пользователя.

    @bp.route('/send_message/<recipient>', methods=['GET', 'POST'])
    @login_required
    def send_message(recipient):
        # ...
        if form.validate_on_submit():
            # ...
            user.add_notification('unread_message_count', user.new_messages())
            db.session.commit()
            # ...
        # ...

Второе место, где мне нужно уведомить пользователя, --- это когда пользователь переходит на страницу сообщений, после чего счетчик непрочитанных сообщений возвращается к нулю:

> **app/main/routes.py:** *Просмотр messages route.*

    @bp.route('/messages')
    @login_required
    def messages():
        current_user.last_message_read_time = datetime.utcnow()
        current_user.add_notification('unread_message_count', 0)
        db.session.commit()
        # ...

Теперь, когда все уведомления для пользователей поддерживаются в базе данных, я могу добавить новый маршрут, который клиент может использовать для извлечения уведомлений для зарегистрированного пользователя:

> **app/main/routes.py:** *Функция просмотра уведомлений.*

    from app.models import Notification

    # ...

    @bp.route('/notifications')
    @login_required
    def notifications():
        since = request.args.get('since', 0.0, type=float)
        notifications = current_user.notifications.filter(
            Notification.timestamp > since).order_by(Notification.timestamp.asc())
        return jsonify([{
            'name': n.name,
            'data': n.get_data(),
            'timestamp': n.timestamp
        } for n in notifications])

Это довольно простая функция, которая возвращает полезную нагрузку в JSON со списком уведомлений для пользователя. Каждое уведомление предоставляется как словарь с тремя элементами, именем уведомления, дополнительными данными, относящимися к уведомлению (например, количеством сообщений), и меткой времени. Уведомления доставляются в том порядке, в котором они были созданы, от самого старого до самого нового.

Я не хочу, чтобы клиенты получали повторные уведомления, поэтому я даю им возможность запрашивать уведомления только с определенного времени. Опция `since` «поскольку» может быть включена в строку запроса URL-адреса с временной отметкой времени запуска в качестве числа с плавающей точкой. Только уведомления, которые произошли после этого времени, будут возвращены, если этот аргумент включен.

В заключении, чтобы завершить эту функцию требуется выполнить фактический опрос в клиенте. Лучшее место для этого --- в базовом шаблоне, так что все страницы автоматически наследуют поведение:

> **app/templates/base.html:** *Опрос для уведомлений.*

    ...
    {% block scripts %}
        <script>
            // ...
            {% if current_user.is_authenticated %}
            $(function() {
                var since = 0;
                setInterval(function() {
                    $.ajax('{{ url_for('main.notifications') }}?since=' + since).done(
                        function(notifications) {
                            for (var i = 0; i < notifications.length; i++) {
                                if (notifications[i].name == 'unread_message_count')
                                    set_message_count(notifications[i].data);
                                since = notifications[i].timestamp;
                            }
                        }
                    );
                }, 10000);
            });
            {% endif %}
        </script>

Эта функция заключена в шаблон conditional, потому что я хочу опрашивать новые сообщения только тогда, когда пользователь вошел в систему. Для пользователей, которые не вошли в систему, эта функция не будет включена.

Вы уже видели `$(function() { ...})` jQuery\'s в [главе 20](https://habr.com/post/353804/) . Это способ регистрации функции для выполнения после загрузки страницы. Для этой функции мне нужно настроить обычный Таймер, который получает уведомления для пользователя. Вы также видели функцию `setTimeout()` JavaScript, которая запускает функцию, заданную в качестве аргумента после определенного времени. Функция `setInterval()` использует те же аргументы, что и функция `setTimeout()` , но вместо запуска таймера только один раз она продолжает вызывать функцию обратного вызова через регулярные промежутки времени. В этом случае мой интервал установлен в 10 секунд (Задается в миллисекундах), поэтому я собираюсь увидеть обновление значка с разрешением примерно шесть раз в минуту.

Функция, связанная с интервальным таймером, выдает Ajax-запрос для нового маршрута уведомлений, а при завершении обратного вызова просто перебирает список уведомлений. При получении уведомления с именем `unread_message_count` значок количества Сообщений настраивается путем вызова функции, определенной выше, с количеством, указанным в уведомлении.

То, как я обрабатываю аргумент `since` , может выглядеть запутанным. Я начинаю с инициализации этого аргумента равным 0. Аргумент всегда включен в запроса URL-адреса, но я не могу сгенерировать строку запроса с использованием `url_for()` Flask, как это было раньше, потому что `url_for()` запускается на сервере один раз, и мне нужен аргумент `since` для динамического обновления. В первый раз запрос будет отправлен в */notifications?since=0* , но как только я получаю уведомление, я обновляю `since` до отметки времени. Это гарантирует, что я не получу дубликаты, так как я всегда прошу получать уведомления, которые произошли с момента последнего уведомления, которое я видел. Также важно отметить, что я объявлял переменную `since` за пределами функции интервалов, потому что я не хотел, чтобы это была локальная переменная, я хочу, чтобы одна и та же переменная использовалась во всех вызовах.

Самый простой способ попробовать это использовать два разных браузера. Войдите в микроблог в обоих браузерах, используя разных пользователей. Затем из одного из браузеров отправьте одно или несколько сообщений другому пользователю. Панель навигации другого браузера должна обновиться, чтобы показать количество сообщений, отправленных менее чем за 10 секунд. И при нажатии на ссылку \"Messages\" непрочитанных сообщений сбрасываться на ноль.
:::

Глава 22: Фоновые задачи
------------------------

::: {#post-content-body .post__text .post__text-html io-article-url="https://habr.com/ru/post/354752/"}
### Введение в очереди задач

Очереди задач ( *Task queues* ) предоставляют приложению удобное решение для запроса выполнения задачи рабочим процессом. Рабочие процессы выполняются независимо от приложения и даже могут располагаться в другой системе. Связь между приложением и обработчиком осуществляется через очередь сообщений ( *message queue* ). Приложение отправляет задание, а затем отслеживает его выполнение, взаимодействуя с очередью. На следующей схеме показана типичная реализация:

![](https://habrastorage.org/webt/fy/rp/fp/fyrpfpqwurw2rb5y_cawd2wvpuu.png)

Самая популярная очередь задач для Python --- [Celery](http://www.celeryproject.org/) . Это довольно сложный пакет, который имеет множество опций и поддерживает несколько очередей сообщений. Другой популярный вариант очереди задач Python --- [Redis Queue](http://python-rq.org/) или просто RQ, который поддерживает только очередь сообщений Redis, но гораздо проще настраивается по сравнению с Celery.

Как Celery, так и RQ вполне подходят для поддержки фоновых задач в приложении Flask, поэтому моему выбору для этого приложения будет способствовать простота RQ. Тем не менее, реализация такой же функциональности с Celery не сильно сложнее. Если вас интересует Celery больше, чем RQ, вы можете прочитать статью [Использование Celery с Flask](https://blog.miguelgrinberg.com/post/using-celery-with-flask) , которую я написал в своем блоге.

### Использование RQ

RQ --- стандартный пакет Python, который устанавливается через `pip` :

    (venv) $ pip install rq
    (venv) $ pip freeze > requirements.txt

Как я уже упоминал ранее, связь между приложением и обработчиком RQ будет осуществляться в очереди сообщений Redis, поэтому вам нужно запустить сервер Redis. Есть много вариантов установки и запуска сервера Redis в один клик для загрузки установщиков исходного кода и компиляции его непосредственно в вашей системе. Если Вы используете Windows, то Microsoft поддерживает установщики [здесь](https://github.com/MicrosoftArchive/redis/releases) . В Linux вы, вероятно, можете получить его как пакет через менеджер пакетов вашей операционной системы. Пользователи Mac OS X могут запустить `brew install redis` , а затем запустить службу вручную с помощью команды `redis-server` .

Вам не нужно будет взаимодействовать с Redis во всем, кроме проверки, что служба запущена и доступна для RQ.

### Создание Task (Задачи)

Я покажу вам, как выполнить простую задачу через RQ, чтобы вы ознакомились с ней. Task-это не более чем функция Python. Вот пример задачи, которую я собираюсь реализовать в новом модуле *app/tasks.py* :

> **app/tasks.py** : Пример фоновой задачи.

    import time

    def example(seconds):
        print('Starting task')
        for i in range(seconds):
            print(i)
            time.sleep(1)
        print('Task completed')

Эта задача принимает число секунд в качестве аргумента, а затем ожидает это время, печатая счетчик один раз в секунду.

### Запуск RQ Worker

Теперь, когда задача готова, обработчик может стартовать. Это делается с помощью команды `rq worker` :

    (venv) $ rq worker microblog-tasks
    18:55:06 RQ worker 'rq:worker:miguelsmac.90369' started, version 0.9.1
    18:55:06 Cleaning registries for queue: microblog-tasks
    18:55:06
    18:55:06 *** Listening on microblog-tasks...

Рабочий процесс теперь подключен к Redis и отслеживает все задания, которые могут быть ему назначены в очереди с именем `microblog-tasks` . В случаях, когда требуется, чтобы несколько обработчиков имели большую пропускную способность, все, что вам нужно сделать, это запустить больше экземпляров `rq worker` , все подключенные к одной очереди. Затем, когда задание появится в очереди, его выберет любой из доступных рабочих процессов. В рабочей среде ( *production environment* ), вероятно, потребуется иметь по крайней мере столько рабочих процессоров, сколько доступно в CPU.

### Выполнение Задач

Теперь откройте второе окно терминала и активируйте в нем виртуальную среду. Я собираюсь использовать сеанс оболочки, чтобы запустить задачу `example()` в worker:

    >>> from redis import Redis
    >>> import rq
    >>> queue = rq.Queue('microblog-tasks', connection=Redis.from_url('redis://'))
    >>> job = queue.enqueue('app.tasks.example', 23)
    >>> job.get_id()
    'c651de7f-21a8-4068-afd5-8b982a6f6d32'

Класс `Queue` из RQ представляет очередь задач со стороны приложения. Он принимает два аргумента, --- это имя очереди и объект соединения `Redis` , который в этом случае я инициализирую с URL-адресом по умолчанию. Если сервер Redis работает на другом хосте или порту, необходимо использовать другой URL-адрес.

Метод `enqueue()` используется для добавления задания в очередь. Первый аргумент-это имя задачи, которую вы хотите выполнить, заданное непосредственно как объект функции или как строка импорта. Я нахожу опцию string гораздо более удобной, так как это делает ненужным импорт функции на стороне приложения. Все оставшиеся аргументы, данные `enqueue()` , будут переданы функции, запущенной в worker.

Как только будет сделан вызов `enqueue()` , вы заметите некоторую активность в первом окне терминала, в котором запущен worker RQ. Вы увидите, что функция `example()` теперь работает и печатает счетчик один раз в секунду. В то же время, ваш другой терминал не заблокирован, и вы можете продолжить вычисление выражений в оболочке. В приведенном выше примере я назвал метод `job.get_id()` , чтобы получить уникальный идентификатор задачи. Еще одно интересное выражение, которое можно попробовать использовать с объектом `job` , --- проверить, закончилась ли работа функции на рабочем месте:

    >>> job.is_finished
    False

Если вы передали `23` как я сделал в моем примере выше, то функция будет работать около 23 секунд. После этого времени, `job.is_finished` станет `True` . Разве это не здорово?! Мне очень нравится простота RQ!

Как только функция завершает работу, обработчик ( *worker* ) возвращается к ожиданию новых заданий, так что вы можете повторить вызов `enqueue()` с другими аргументами, если вы хотите побольше поэкспериментировать. Данные, которые хранятся в очереди относительно задачи, останутся там на некоторое время (по умолчанию 500 секунд), но в конечном итоге будут удалены. Это важно, очередь задач не сохраняет историю выполненных заданий.

### Отчет о ходе выполнения задачи

Пример задачи, который я использовал выше, нереально прост. Как правило в процессе длительной задачи вы хотите, чтобы какая-то информация о ходе выполнения была доступна приложению, которое, в свою очередь, может показать ее пользователю. RQ поддерживает это с помощью атрибута объекта задания `meta` . Позвольте мне переписать задачу `example()` для записи отчетов о ходе выполнения:

> **app/tasks.py** : Пример фоновой задачи с отчетом о ходе выполнения.

    import time
    from rq import get_current_job

    def example(seconds):
        job = get_current_job()
        print('Starting task')
        for i in range(seconds):
            job.meta['progress'] = 100.0 * i / seconds
            job.save_meta()
            print(i)
            time.sleep(1)
        job.meta['progress'] = 100
        job.save_meta()
        print('Task completed')

Эта новая версия `example()` использует функцию RQ `get_current_job()` для получения экземпляра задания, аналогичного тому, который возвращается приложению при отправке задачи. Атрибут объекта задания `meta` -это словарь, в котором задача может записывать любые пользовательские данные, которые она хочет передать приложению. В этом примере для записи я использую элемент `progress` , представляющий процент выполнения задачи. Каждый раз, когда прогресс обновляется, я называю `job.save_meta()` для указания RQ записать данные в Redis, где приложение может их найти.

На стороне приложения (в настоящее время только оболочка Python) я могу запустить эту задачу, а затем отслеживать ход выполнения следующим образом:

    >>> job = queue.enqueue('app.tasks.example', 23)
    >>> job.meta
    {}
    >>> job.refresh()
    >>> job.meta
    {'progress': 13.043478260869565}
    >>> job.refresh()
    >>> job.meta
    {'progress': 69.56521739130434}
    >>> job.refresh()
    >>> job.meta
    {'progress': 100}
    >>> job.is_finished
    True

Как вы можете видеть выше, на этой стороне атрибут `meta` доступен для чтения. Для обновления содержимого из Redis необходимо вызвать метод `refresh()` .

### Представление задач в базе данных

Для приведенного выше примера было достаточно запустить задачу и посмотреть, как она выполняется. Для веб-приложения все становится немного сложнее, потому что как только одна из этих задач запускается как часть запроса, этот запрос завершается, и весь контекст для этой задачи будет потерян. Поскольку я хочу, чтобы приложение отслеживало, какие задачи выполняет каждый пользователь, мне нужно использовать таблицу базы данных для поддержания некоторого состояния. Ниже вы можете увидеть новую реализацию модели `Task` :

> **app/models.py** : Task model.

    # ...
    import redis
    import rq

    class User(UserMixin, db.Model):
        # ...
        tasks = db.relationship('Task', backref='user', lazy='dynamic')

    # ...

    class Task(db.Model):
        id = db.Column(db.String(36), primary_key=True)
        name = db.Column(db.String(128), index=True)
        description = db.Column(db.String(128))
        user_id = db.Column(db.Integer, db.ForeignKey('user.id'))
        complete = db.Column(db.Boolean, default=False)

        def get_rq_job(self):
            try:
                rq_job = rq.job.Job.fetch(self.id, connection=current_app.redis)
            except (redis.exceptions.RedisError, rq.exceptions.NoSuchJobError):
                return None
            return rq_job

        def get_progress(self):
            job = self.get_rq_job()
        return job.meta.get('progress', 0) if job is not None else 100

Интересным отличием этой модели от предыдущих является то, что поле первичного ключа `id` является строкой, а не целым числом. Это потому, что для этой модели я не собираюсь полагаться на собственную генерацию первичного ключа базой данных, а вместо этого буду использовать идентификаторы заданий, созданные RQ.

Модель будет хранить полное имя задачи (переданное в RQ), описание задачи, подходящее для отображения пользователям, связь с пользователем, запросившим задачу, и логическое значение, указывающее, завершена задача или нет. Цель поля `complete` -отделить завершенные задачи от задач, которые активно выполняются, так как выполняемые задачи требуют специальной обработки для отображения хода выполнения обновлений.

Метод `get_rq_job()` является вспомогательным методом, который загружает экземпляр RQ `Job` из заданного идентификатора задачи, который я могу получить из модели. Это делается с помощью `Job.fetch()` , который загружает экземпляр задания из данных, существующих в Redis. Метод `get_progress()` строится поверх метода `get_rq_job()` и возвращает процент выполнения задачи. Этот метод имеет несколько интересных предположений. Если идентификатор задания из модели не существует в очереди RQ, это означает, что задание уже завершено, а срок действия данных истек и было удалено из очереди, поэтому в этом случае возвращается 100 процентов. С другой стороны, если задание существует, но нет никакой информации, связанной с атрибутом `meta` , то можно с уверенностью предположить, что задание запланировано на выполнение, но еще не было возможности начать, поэтому в этой ситуации возвращается 0 как прогресс.

Чтобы применить изменения к схеме базы данных, необходимо создать новую миграцию, а затем обновить базу данных:

    (venv) $ flask db migrate -m "tasks"
    (venv) $ flask db upgrade

Новая модель также может быть добавлена в контекст оболочки, чтобы сделать ее доступной в сеансах оболочки без необходимости её импорта:

> **microblog.py** : Добавляем модель задачи в контекст оболочки.

    from app import create_app, db, cli
    from app.models import User, Post, Message, Notification, Task

    app = create_app()
    cli.register(app)

    @app.shell_context_processor
    def make_shell_context():
        return {'db': db, 'User': User, 'Post': Post, 'Message': Message,
                'Notification': Notification, 'Task': Task}

### Интеграция RQ с приложением Flask

В конфигурацию необходимо добавить URL-адрес подключения для службы Redis:

    class Config(object):
        # ...
        REDIS_URL = os.environ.get('REDIS_URL') or 'redis://'

Как всегда, URL-адрес подключения Redis будет получен из переменной окружения, и если переменная не определена, будет использоваться URL-адрес по умолчанию, который предполагает, что служба работает на том же узле и порту по умолчанию.

Функция фабрики применения будет отвечать за инициализацию Redis и RQ:

> **app/\_ *init\_* .py** : RQ интеграция.

    # ...
    from redis import Redis
    import rq

    # ...

    def create_app(config_class=Config):
        # ...
        app.redis = Redis.from_url(app.config['REDIS_URL'])
        app.task_queue = rq.Queue('microblog-tasks', connection=app.redis)

        # ...

`app.task_queue` будет очередью, в которой будут представлены задачи. Наличие очереди, прикрепленной к приложению, удобно, потому что в любом месте приложения я могу использовать `current_app.task_queue` для доступа к нему. Чтобы облегчить отправку или проверку какой-либо части приложения, я могу создать несколько вспомогательных методов в модели `User` :

> **app/models.py** : Вспомогательные методы задачи в пользовательской модели.

    # ...

    class User(UserMixin, db.Model):
        # ...

        def launch_task(self, name, description, *args, **kwargs):
            rq_job = current_app.task_queue.enqueue('app.tasks.' + name, self.id,
                                                    *args, **kwargs)
            task = Task(id=rq_job.get_id(), name=name, description=description,
                        user=self)
            db.session.add(task)
            return task

        def get_tasks_in_progress(self):
            return Task.query.filter_by(user=self, complete=False).all()

        def get_task_in_progress(self, name):
            return Task.query.filter_by(name=name, user=self,
                                        complete=False).first()

Метод `launch_task()` передаёт задачу в очередь RQ вместе с добавлением её в базу данных. Аргумент `name` является именем функции, как определено в *app/tasks.py* . При отправке в RQ функция добавляет к `app.tasks` . `name` что бы построить полное имя функции. Аргумент `description` -это внятное описание задачи, которое может быть представлено пользователям. Для функции, экспорта сообщения в блоге, я буду использовать имя `export_posts` и описания `Exporting posts...` . Остальные аргументы являются позиционными и ключевыми аргументами, которые будут переданы задаче. Функция начинается с вызова метода очереди `enqueue()` для отправки задания. Возвращаемый объект задания содержит id задачи, назначенный RQ, поэтому я могу использовать его для создания соответствующего объекта задачи в своей базе данных.

Обратите внимание, что `launch_task()` добавляет, но не фиксит новый объект `Task` в сеансе. В общем случае лучше всего работать с сеансом базы данных в функциях более высокого уровня, так как это позволяет объединить несколько обновлений, сделанных функциями более низкого уровня, в одну транзакцию. Это не строгое правило, и далее в этой главе вы увидите исключение, в котором фиксация выполняется в дочерней функции.

Метод `get_tasks_in_progress()` возвращает полный список функций, которые выдаются пользователю. Позже вы увидите, что я использую этот метод для включения информации о выполняемых задачах на страницах, которая отображаются пользователю.

Наконец, `get_task_in_progress()` является более простой версией предыдущей, которая возвращает конкретную задачу. Я запрещаю пользователям запускать две или более задачи одного типа одновременно, поэтому перед запуском задачи я могу использовать этот метод, чтобы узнать, выполняется ли предыдущая задача в настоящее время.

### Отправка сообщений электронной почты из RQ Task

Это может показаться отступлением от основной темы, но как я уже сказал выше, с завершением фоновой задача экспорта, пользователю будет отправлено электронное письмо с файлом JSON, который содержит все сообщения. Функциональность электронной почты, которую я представил в [главе 11](https://habrahabr.ru/post/349060/) , должна быть расширена двумя способами. Во-первых, мне нужно добавить поддержку вложений файлов, чтобы я мог прикрепить файл JSON. Во-вторых, функция `send_email()` отправляет письма асинхронно, используя фоновый поток. Когда я собираюсь отправить электронное письмо из фоновой задачи, которая уже асинхронна, наличие фоновой задачи второго уровня, основанной на потоке, имеет мало смысла, поэтому мне нужно поддерживать как синхронную, так и асинхронную отправку электронной почты.

К счастью, Flask-Mail поддерживает вложения, поэтому все, что мне нужно сделать, это расширить функцию `send_email()` , чтобы взять их(вложения) в дополнительный аргумент, а затем настроить их в объекте `Message` . И дополнительно отправить письмо как приоритетную задачу, мне просто нужно добавить логический аргумент `sync` :

> **app/email.py** : Отправка писем с вложениями.

    # ...

    def send_email(subject, sender, recipients, text_body, html_body,
                   attachments=None, sync=False):
        msg = Message(subject, sender=sender, recipients=recipients)
        msg.body = text_body
        msg.html = html_body
        if attachments:
            for attachment in attachments:
                msg.attach(*attachment)
        if sync:
            mail.send(msg)
        else:
            Thread(target=send_async_email,
                args=(current_app._get_current_object(), msg)).start()

Метод `attach()` класса `Message` принимает три аргумента, определяющих вложение: Имя файла, Тип носителя и фактические данные файла. Имя файла --- это просто имя, которое увидит получатель, связанное с вложением, оно не должно быть реальным файлом. Тип носителя определяет, какой это тип вложения, что помогает читателям электронной почты отображать его соответствующим образом. Например, если вы отправляете `jpg/png` в качестве типа носителя, читатель электронной почты будет знать, что вложение является изображением, и в этом случае он может показать его как таковое. Для файла данных записи блога я собираюсь использовать Формат JSON, который использует тип мультимедиа `application/json` . Третий и последний аргумент-это строка или последовательность байтов с содержанием вложения.

Чтобы сделать его простым, аргумент `attachments` для `send_email()` будет списком кортежей, и каждый кортеж будет иметь три элемента, которые соответствуют трем аргументам `attach()` . Поэтому для каждого элемента в этом списке, необходимо отправить кортеж в качестве аргумента `attach()` . В Python, если у вас есть список или кортеж с аргументами, которые вы хотите отправить в функцию, вы можете использовать `func(*args)` , чтобы этот список был расширен в фактический список аргументов, вместо того, чтобы использовать более утомительный синтаксис, такой как `func(args[0], args[1], args[2])` . Например, если у вас `args = [1, 'foo']` , вызов отправит два аргумента, как если бы вы вызвали `func (1, 'foo')` . Без `*` вызов имел бы единственный аргумент, который был бы списком.

Что касается синхронной отправки электронной почты, то мне нужно было просто вернуться к вызову `mail.send(msg)` непосредственно, когда `sync` *is* `True` .

### Task Helpers

Хотя задача `example()` , которую я использовал выше, была простой автономной функцией, функция, которая экспортирует сообщения в блоге, потребует некоторых функций, которые у меня есть в приложении, как доступ к базе данных и функции отправки электронной почты. Поскольку это будет выполняться в отдельном процессе, мне нужно инициализировать Flask-SQLAlchemy и Flask-Mail, которые, в свою очередь, нуждаются в экземпляре приложения Flask, из которого можно получить их конфигурацию. Поэтому я собираюсь добавить экземпляр приложения Flask и контекст приложения в верхней части модуля *app/tasks.py* :

> **app/tasks.py** : Создание приложения и контекста.

    from app import create_app

    app = create_app()
    app.app_context().push()

Приложение создается в этом модуле, так как это единственный модуль, который будет импортировать RQ worker. При использовании команды `flask` модуль *microblog.py* в корневом каталоге создает приложение, но RQ worker ничего об этом не знает, поэтому ему необходимо создать собственный экземпляр приложения, если это необходимо функциям задачи. Вы видели метод `app.app_context()` уже в нескольких местах, нажатие контекста делает приложение \"текущим\" экземпляром приложения, и это позволяет таким расширениям, как Flask-SQLAlchemy, использовать `current_app.config` для получения их конфигурации. Без контекста выражение `current_app` возвращает ошибку.

Затем я задумался о том, каким образом я буду сообщать о ходе выполнения этой функции. В дополнении к передаче информации о ходе работы через словарь `job.meta` , я хотел бы отправить уведомления клиенту, чтобы можно было динамически обновлять процент завершения без необходимости обновления страницы. Для этого я собираюсь использовать механизмы уведомления похожие на те, которые я создал в [главе 21](https://habrahabr.ru/post/354322/) . Обновления будут работать похожим образом на значок непрочитанных сообщений. Когда сервер отображает шаблон, он будет включать \"статическую\" информацию о ходе выполнения, полученную из `job.meta` , но затем, как только страница появится в браузере клиента, уведомления будут динамически обновлять процент с помощью уведомлений. Из-за уведомлений обновление хода выполнения запущенной задачи будет немного более сложным, чем то, как я это сделал в предыдущем примере, поэтому я собираюсь создать функцию-декоратор, посвященную обновлению хода выполнения:

> **app/tasks.py** : Установка хода выполнения задачи.

    from rq import get_current_job
    from app import db
    from app.models import Task

    # ...

    def _set_task_progress(progress):
        job = get_current_job()
        if job:
            job.meta['progress'] = progress
            job.save_meta()
            task = Task.query.get(job.get_id())
            task.user.add_notification('task_progress', {'task_id': job.get_id(),
                                                         'progress': progress})
            if progress >= 100:
                task.complete = True
            db.session.commit()

Задача экспорта может вызвать `_set_task_progress()` для записи процента выполнения. Функция сначала записывает процент в словарь `job.meta` и сохраняет его в Redis, затем загружает соответствующий объект task из базы данных и использует `task.user` для отправки уведомления пользователю, запросившему задачу, используя существующий метод `add_notification()` . Уведомление будет называться `task_progress` , и данные, связанные с ним, будут словарем с двумя элементами, идентификатором задачи и номером индикатора хода выполнения (progress number). Позже я добавлю код JavaScript, чтобы действовать на этот новый тип уведомления.

Функция проверяет, показывает ли индикатора хода выполнения, что функция завершена, и в этом случае также обновляет `complete` атрибут объекта задачи в базе данных. Вызов коммита базы данных гарантирует, что задача и объект уведомления, добавленные `add_notification()` , будут немедленно сохранены в базе данных. Мне нужно было быть очень осторожным в том, как я разработал родительскую задачу, чтобы не изменять какие-либо базы данных, так как этот коммит также записывал бы эти изменения.

### Реализация задачи экспорта

Теперь все части на месте и можно написать функцию экспорта. Структура верхнего уровня этой функции будет выглядеть следующим образом:

> **app/tasks.py** : Общая структура экспорта сообщений.

    def export_posts(user_id):
        try:
            # читать сообщения пользователей из базы данных
            # отправить письмо с данными пользователю
        except:
        # обработки непредвиденных ошибок

Зачем переносить всю задачу в блок try/except? Код приложения, который существует в обработчиках запросов, защищен от непредвиденных ошибок, потому что сам Flask перехватывает исключения, а затем обрабатывает их, наблюдая за любыми обработчиками ошибок и конфигурацией ведения журнала, которые я настроил для приложения. Эта функция, однако, будет выполняться в отдельном процессе, который управляется RQ, а не Flask, поэтому, если возникнут непредвиденные ошибки, задача будет прервана, RQ отобразит ошибку на консоли, а затем вернется к ожиданию новых заданий. Поэтому, если вы не смотрите вывод RQ worker или не записываете его в лог-файл, вы никогда не узнаете, что произошла ошибка.

Давайте расмотрим три раздела отмеченные комментариями выше, по порядку с самого простого, которым является обработка ошибок в самом конце:

> **app/tasks.py** : Обработка ошибок экспорта записей.

    import sys
    # ...

    def export_posts(user_id):
        try:
            # ...
        except:
            _set_task_progress(100)
            app.logger.error('Unhandled exception', exc_info=sys.exc_info())

Всякий раз, когда возникает непредвиденная ошибка, я буду помечать задачу как завершенную, установив прогресс на 100%, а затем используя объект logger из приложения Flask регистрировать ошибку вместе с трассировкой стека, которая предоставляется вызовом `sys.exc_info()` . Приятным известием является то, что при использовании flask Application logger любые механизмы ведения журнала, которые вы реализовали для приложения Flask будут соблюдаться и здесь. Например, в [главе 7](https://habrahabr.ru/post/346880/) я настроил отправку ошибок на адрес электронной почты администратора. Просто с помощью `app.logger` я также получаю такое поведение для этих ошибок.

Затем я закодирую фактический экспорт, который просто выдает запрос к базе данных и просматривает результаты в цикле, накапливая их в словаре:

> **app/tasks.py** : Чтение сообщений пользователей из базы данных.

    import time
    from app.models import User, Post

    # ...

    def export_posts(user_id):
        try:
            user = User.query.get(user_id)
            _set_task_progress(0)
            data = []
            i = 0
            total_posts = user.posts.count()
            for post in user.posts.order_by(Post.timestamp.asc()):
                data.append({'body': post.body,
                             'timestamp': post.timestamp.isoformat() + 'Z'})
                time.sleep(5)
                i += 1
                _set_task_progress(100 * i // total_posts)

            # отправить письмо с данными пользователю
        except:
        # ...

Для каждого поста функция будет включать словарь с двумя элементами, телом поста и временем написания поста. Время будет записано в стандарте ISO 8601. Объекты `datetime` Python, которые я использую, не хранят часовой пояс, поэтому после экспорта времени в формате ISO я добавляю \"Z\", что указывает на UTC.

Код немного усложняется из-за необходимости отслеживать прогресс. Я поддерживаю счетчик `i` , и мне нужно выполнить дополнительный запрос к базе данных, прежде чем я войду в цикл для `total_posts` , чтобы получить количество сообщений. С помощью `i` и `total_posts` каждая итерация цикла может обновлять ход выполнения задачи числом от 0 до 100.

Возможно, вы заметили, что я также добавил вызов `time.sleep(5)` в каждой итерации цикла. Основная причина, по которой я добавил sleep, заключается в том, чтобы сделать задачу экспорта более длительной и иметь возможность видеть рост прогресса, даже когда экспорт охватывает всего несколько сообщений в блоге.

Ниже вы можете увидеть последнюю часть функции, которая отправляет пользователю электронное письмо со всей информацией, собранной в `data` в качестве вложения:

> **app/tasks.py** : Сообщения электронной почты для пользователя.

    import json
    from flask import render_template
    from app.email import send_email

    # ...

    def export_posts(user_id):
        try:
            # ...

            send_email('[Microblog] Your blog posts',
                    sender=app.config['ADMINS'][0], recipients=[user.email],
                    text_body=render_template('email/export_posts.txt', user=user),
                    html_body=render_template('email/export_posts.html', user=user),
                    attachments=[('posts.json', 'application/json',
                                  json.dumps({'posts': data}, indent=4))],
                    sync=True)
        except:
            # ...

Это просто вызов функции `send_email()` . Вложение определяется как кортеж с тремя элементами, которые затем передаются методу `attach()` объекта Flask-Mail\'s `Message` . Третий элемент в кортеже-это содержимое вложения, которое создается с помощью функции Python `json.dumps()` .

Есть пара новых шаблонов, указанных здесь, которые обеспечивают содержание сообщения в текстовом и HTML виде. Вот текстовый шаблон:

> **app/templates/email/export\_posts.txt** : Export posts text email template.

    Dear {{ user.username }},

    Please find attached the archive of your posts that you requested.

    Sincerely,

    The Microblog Team

Вот HTML-версия письма:

> app/templates/email/export\_posts.html: Export posts HTML email template.

    <p>Dear {{ user.username }},</p>
    <p>Please find attached the archive of your posts that you requested.</p>
    <p>Sincerely,</p>
    <p>The Microblog Team</p>

### Экспорт функциональности в приложении

Все основные части для поддержки фоновых задач экспорта теперь на месте. Остается подключить эту функциональность к приложению, чтобы пользователи могли размещать запросы на отправку сообщений по электронной почте.

Ниже вы можете увидеть новую функцию просмотра `export_posts` :

> **app/main/routes.py** : Export posts route and view function.

    @bp.route('/export_posts')
    @login_required
    def export_posts():
        if current_user.get_task_in_progress('export_posts'):
            flash(_('An export task is currently in progress'))
        else:
            current_user.launch_task('export_posts', _('Exporting posts...'))
            db.session.commit()
        return redirect(url_for('main.user', username=current_user.username))

Функция сначала проверяет, есть ли у пользователя невыполненная задача экспорта, и в этом случае просто мигает сообщение. На самом деле нет смысла иметь две задачи экспорта для одного и того же пользователя одновременно, поэтому это предотвращается. Я могу проверить это условие, используя метод `get_task_in_progress()` , который я реализовал ранее.

Если пользователь еще не запустил экспорт, то для его запуска вызывается `launch_task()` . Первый аргумент-это имя функции, которое будет передано RQ worker с префиксом `app.tasks.` . Второй аргумент-это просто текстовое описание, которое будет показано пользователю. Оба значения записываются в объект `Task` в базе данных. Функция завершается перенаправлением на страницу профиля пользователя.

Теперь мне нужно предоставить ссылку на этот маршрут, к которому пользователь может получить доступ для запроса экспорта. Я думаю, что самое подходящее место для этого на странице профиля пользователя, где ссылка может быть показана только при просмотре своей страницы, прямо под \"Редактировать профиль\":

> **app/templates/user.html** : Ссылка Экспорт на странице профиля пользователя.

                ...
                <p>
                    <a href="{{ url_for('main.edit_profile') }}">
                        {{ _('Edit your profile') }}
                    </a>
                </p>
                {% if not current_user.get_task_in_progress('export_posts') %}
                <p>
                    <a href="{{ url_for('main.export_posts') }}">
                        {{ _('Export your posts') }}
                    </a>
                </p>
                ...
                {% endif %}

Эта ссылка привязана к условию, потому что я не хочу, чтобы она отображалась, когда пользователь уже выполняет экспорт.

На этом этапе фоновые задания должны быть функциональными, но без обратной связи с пользователем. Если вы хотите попробовать это, вы можете запустить приложение и RQ worker следующим образом:

-   Убедитесь, что Redis запущен
-   В первом окне терминала, запустите один или несколько экземпляров обработчиков RQ. Для этого необходимо использовать команду `rq worker microblog-tasks`
-   Во втором окне терминала запустите Приложение Flask, набрав `flask run` (не забудьте сначала установить `FLASK_APP` )

### Уведомления о ходе выполнения

В завершении этой функции, я хочу предоставить пользователю во время выполнении фоновой задачи процент её завершения. Просматривая параметры компонента Bootstrap, я решил использовать для этого предупреждение под панелью навигации. Предупреждения-это цветные горизонтальные полосы, отображающие информацию для пользователя. Синие окна оповещения-это то, что я использую для отображения мигающих сообщений. Теперь я собираюсь добавить зеленый, чтобы показать статус прогресса. Ниже Вы можете увидеть, как это будет выглядеть:

![](https://habrastorage.org/webt/sf/u5/44/sfu544ikvis0stvz41c8gpxhqqe.png)

> **app/templates/base.html** : Оповещение о ходе выполнения Экспорта в базовом шаблоне.

    ...
    {% block content %}
        <div class="container">
            {% if current_user.is_authenticated %}
            {% with tasks = current_user.get_tasks_in_progress() %}
            {% if tasks %}
                {% for task in tasks %}
                <div class="alert alert-success" role="alert">
                    {{ task.description }}
                    <span id="{{ task.id }}-progress">{{ task.get_progress() }}</span>%
                </div>
                {% endfor %}
            {% endif %}
            {% endwith %}
            {% endif %}
            ...
    {% endblock %}
    ...

Метод отображения оповещений задачи практически идентичен этим мигающим флешевым сообщениям. Внешнее условие пропускает всю связанную с предупреждением разметку если пользователь не вошел в систему. Для зарегистрированных пользователей я получаю текущий список задач, вызывая метод `get_tasks_in_progress()` , который я создал ранее. В текущей версии приложения я получу только один результат, так как я не разрешаю более одного активного экспорта за раз, но в будущем я могу захотеть поддерживать другие типы задач, которые могут сосуществовать, поэтому написание этого общим способом может сэкономить мне время позже.

Для каждой задачи я пишу элемент alert на страницу. Цвет оповещения контролируется вторым стилем CSS, который в данном случае является `alert-success` , в то время как в случае мигающих Сообщений был alert-info. [Документация Bootstrap](https://getbootstrap.com/docs/3.3/components/#alerts) содержит подробные сведения о структуре HTML для оповещений. Текст включает описание полей, хранящихся в модели задач, а затем завершение в процентах.

Процент обернут в элемент `<span>` , который имеет атрибут `id` . Причина этого заключается в том, что я собираюсь обновить процент JavaScript при получении уведомления. Идентификатор, который я использую для данной задачи, создается как идентификатор задачи с добавлением `-progress` в конце. Когда приходит уведомление, оно будет содержать идентификатор задачи, поэтому я могу легко найти правильный элемент `<span>` для обновления с помощью селектора для `#<task.id> - progress` .

Если вы попробуете приложение на этом этапе, вы увидите \"статические\" обновления хода выполнения, при каждом переходе на новую страницу. Вы заметите, что после запуска задачи экспорта вы можете свободно переходить на разные страницы приложения, и состояние запущенной задачи всегда будет вызываться.

Чтобы подготовить динамические обновления к элементам процента `<span>` , я напишу небольшую вспомогательную функцию на JavaScript:

> **app/templates/base.html** : Вспомогательная функция для динамического обновления индикатора хода выполнения задачи.

    ...
    {% block scripts %}
        ...
        <script>
            ...
            function set_task_progress(task_id, progress) {
                $('#' + task_id + '-progress').text(progress);
            }
        </script>
        ...
    {% endblock %}

Эта функция принимает `id` задачи и значение хода выполнения и использует jQuery для поиска элемента `<span>` для этой задачи и записи нового хода выполнения в качестве его содержимого. На самом деле нет необходимости проверять, существует ли элемент на странице, потому что jQuery ничего не будет делать, если элементы не расположены с данным селектором.

Уведомления уже поступают в браузер, так как функция `_set_task_progress()` в *app/tasks.py* вызывает `add_notification()` при каждом обновлении хода выполнения. Если вас смущает то, как эти уведомления могут достигать браузера без необходимости что-либо делать, это действительно потому, что в [главе 21](https://habrahabr.ru/post/354322/) я был достаточно предусмотрителен, чтобы реализовать функцию уведомлений в совершенно общем виде. Любые уведомления, добавляемые с помощью метода `add_notification()` , будут видны браузеру, когда он периодически запрашивает у сервера обновления уведомлений.

Но код JavaScript, который обрабатывает эти уведомления, распознает только те, которые имеют имя `unread_message_count` , и игнорирует остальные. Теперь мне нужно развернуть эту функцию, чтобы также обрабатывать уведомления `task_progress` , вызывая функцию `set_task_progress()` , которую я определил выше. Вот обновленная версия цикла, который обрабатывает уведомления из JavaScript:

> **app/templates/base.html** : Обработчик уведомлений.

                        for (var i = 0; i < notifications.length; i++) {
                            switch (notifications[i].name) {
                                case 'unread_message_count':
                                    set_message_count(notifications[i].data);
                                    break;
                                case 'task_progress':
                                    set_task_progress(
                                        notifications[i].data.task_id,
                                        notifications[i].data.progress);
                                    break;
                            }
                            since = notifications[i].timestamp;
                        }

Теперь, когда мне нужно обработать два разных уведомления, я решил заменить оператор `if` , который проверял имя уведомления `unread_message_count` , оператором `switch` , который содержит один раздел для каждого уведомления, которое мне теперь нужно поддерживать. Если вы не особо знакомы с семейством языков \"C\", возможно, вы не встречали операторы switch раньше. Они предоставляют удобный синтаксис, который заменяет длинную цепочку операторов `if/elseif` . Это удобно для поддержания большого числа уведомлений, я могу просто продолжать добавлять их в качестве дополнительных блоков.

Если вы помните, данные, которые задача RQ прикрепляет к уведомлению `task_progress` , являются словарем с двумя элементами `task_id` и `progress` , которые являются двумя аргументами предназначенными для вызова `set_task_progress()` .

Если вы запустите приложение сейчас, индикатор выполнения в зеленом окне оповещения будет обновляться каждые 10 секунд, так как уведомления доставляются клиенту.

Поскольку в этой главе я ввел новые строки пользовательского интерфейса, которые надо бы перевести, то файлы переводов необходимо обновить. Если вы поддерживаете файл, не относящийся к английскому языку, вам необходимо использовать Flask-Babel для обновления ваших файлов перевода, а затем добавить новые переводы:

    (venv) $ flask translate update

Если вы используете перевод на испанском языке, то я сделал перевод для вас, поэтому вы можете просто извлечь файлы *app/translations/es/LC\_MESSAGES/messages.po* из пакета загрузки для этой главы и добавить его в свой проект.

После того, как переводы выполнены, вам необходимо скомпилировать файлы перевода:

    (venv) $ flask translate compile

### Рекомендации по развертыванию

В завершении этой главы обсудим изменения в развертывании приложения. Для поддержки фоновых задач я добавил в стек два новых компонента: сервер Redis и один или несколько обработчиков RQ. Очевидно, что они должны быть включены в стратегию развертывания, поэтому я кратко расскажу о различных вариантах развертывания, о которых я рассказывал в предыдущих главах, и о том, как на них повлияли эти изменения.

### Развертывание на сервере Linux

Если приложение выполняется на сервере Linux, добавление Redis должно быть таким же простым, как установка этого пакета из операционной системы. Для Ubuntu Linux необходимо запустить `sudo apt-get install redis-server` .

Чтобы запустить рабочий процесс RQ, вы можете следовать разделу \"Настройка Gunicorn и Supervisor\" в [главе 17](https://habrahabr.ru/post/352266/) , чтобы создать вторую конфигурацию Supervisor, в которой вы запускаете микроблог `rq worker-tasks` вместо `gunicorn` . Если вы хотите запустить более одного обработчика (и, вероятно, должны для production), вы можете использовать директиву `numprocs` Супервизора, чтобы указать, сколько экземпляров вы хотите запустить одновременно.

### Развертывание на Heroku

Чтобы развернуть приложение на Heroku, вам нужно добавить службу Redis в свою учетную запись. Это похоже на процесс, который я использовал для добавления базы данных Postgres. Redis также имеет халявный уровень, который можно добавить с помощью следующей команды:

    $ heroku addons:create heroku-redis:hobby-dev

URL-адрес доступа для новой службы redis будет добавлен в среду Heroku в качестве переменной `REDIS_URL` , что является именно тем, что ожидает приложение.

Бесплатный план в Heroku позволяет один web-dyno и один worker dyno, так что вы можете разместить одного обработчика rq вместе с вашим приложением, не неся никаких расходов. Для этого вам нужно будет объявить обработчик в отдельной строке в вашем procfile:

    web: flask db upgrade; flask translate compile; gunicorn microblog:app
    worker: rq worker microblog-tasks

После развертывания с этими изменениями можно запустить рабочий процесс с помощью следующей команды:

    $ heroku ps:scale worker=1

### Развертывание на Docker

При развертывании приложения в контейнерах Docker сначала необходимо создать контейнер Redis. Для этого можно использовать один из официальных образов Redis из реестра Docker:

    $ docker run --name redis -d -p 6379:6379 redis:3-alpine

При запуске приложения необходимо связать контейнер redis и задать переменную окружения `REDIS_URL` , аналогично тому, как связан контейнер MySQL. Вот полная команда для запуска приложения, включая ссылку redis:

    $ docker run --name microblog -d -p 8000:5000 --rm -e SECRET_KEY=my-secret-key \
        -e MAIL_SERVER=smtp.googlemail.com -e MAIL_PORT=587 -e MAIL_USE_TLS=true \
        -e MAIL_USERNAME=<your-gmail-username> -e MAIL_PASSWORD=<your-gmail-password> \
        --link mysql:dbserver --link redis:redis-server \
        -e DATABASE_URL=mysql+pymysql://microblog:<database-password>@dbserver/microblog \
        -e REDIS_URL=redis://redis-server:6379/0 \
        microblog:latest

Наконец, необходимо запустить один или несколько контейнеров для обработчиков RQ. Поскольку рабочие процессы основаны на том же коде, что и основное приложение, можно использовать тот же образ контейнера, который используется для приложения, переопределив команду start up, чтобы обработчик запускался вместо веб-приложения. Вот пример команды `docker run` , которая запускает worker:

    $ docker run --name rq-worker -d --rm -e SECRET_KEY=my-secret-key \
        -e MAIL_SERVER=smtp.googlemail.com -e MAIL_PORT=587 -e MAIL_USE_TLS=true \
        -e MAIL_USERNAME=<your-gmail-username> -e MAIL_PASSWORD=<your-gmail-password> \
        --link mysql:dbserver --link redis:redis-server \
        -e DATABASE_URL=mysql+pymysql://microblog:<database-password>@dbserver/microblog \
        -e REDIS_URL=redis://redis-server:6379/0 \
        --entrypoint venv/bin/rq \
        microblog:latest worker -u redis://redis-server:6379/0 microblog-tasks

Переопределение команды запуска по умолчанию образа Docker немного сложнее, потому как команда должна быть задана в двух частях. Аргумент `--entrypoint` принимает только имя исполняемого файла, но аргументы (если таковые имеются) должны быть заданы после образа и тега в конце командной строки. Заметьте что `rq` нужно дать как `venv/bin/rq` так, что оно будет работать без активации виртуальной среды.
:::

Глава 23: Интерфейсы прикладного программирования (API)
-------------------------------------------------------

::: {#post-content-body .post__text .post__text-html io-article-url="https://habr.com/ru/post/358152/"}
### REST как основа проектирования API

Кто то может категорически не согласиться с моим утверждением выше, что */translate* и другие маршруты JSON являются маршрутами API. Другие могут согласиться с оговоркой, что они считают их плохо разработанным API. Итак, каковы характеристики хорошо разработанного API, и почему маршруты JSON вне этой категории?

Возможно, вы слышали термин rest API. REST, который означает Representational State Transfer ( *Передача Состояния Представления* ), является архитектурой, предложенной доктором Роем Филдингом в его докторской диссертации. В своей работе д-р Филдинг представляет шесть определяющих характеристик REST в довольно абстрактном и общем виде.

Кроме диссертации доктора Филдинга, нет никакой другой авторитетной спецификации REST, что оставляет много чего для свободной интерпретации читателю. Тема о том, соответствует ли данный API REST или нет, часто является источником жарких дебатов между REST «пуристами», которые считают, что REST API должен соблюдать все шесть характеристик и делать это чётко определенным образом по сравнению с «прагматиками» REST, которые берут идеи, представленные д-ром Филдингом в своей диссертации в качестве руководящих принципов или рекомендаций. Д-р Филдинг сам встал на сторону пуристского лагеря и дал некоторое дополнительное представление о своем видении в блогах и онлайн-комментариях.

Подавляющее большинство API-интерфейсов, реализованных в настоящее время, придерживаются «прагматичной» реализации REST. Это включает в себя большинство API-интерфейсов от «крупных игроков», таких как Facebook, GitHub, Twitter и т.д. Существует очень мало публичных API, которые единодушно считаются чистыми REST, поскольку большинство API-интерфейсов пропускают некоторые детали реализации, которые пуристы считают обязательными. Несмотря на строгие взгляды д-ра Филдинга и других пуристов REST на то, что является или не является REST API, в индустрии программного обеспечения обычно упоминается REST в прагматическом смысле.

Чтобы дать вам представление о том, что находится в диссертации REST, в следующих разделах описываются шесть принципов, перечисленных д-ром Филдингом.

#### Client-Server

Принцип клиент-сервер довольно прост, так как он просто гласит, что в REST API роли клиента и сервера должны быть четко дифференцированы. На практике это означает, что клиент и сервер находятся в отдельных процессах, которые взаимодействуют через транспорт, который в большинстве случаев является протоколом HTTP по сети TCP.

#### Layered System

Принцип Layered System ( *многоуровневой системы* ) говорит, что когда клиент должен взаимодействовать с сервером, он может быть связан с посредником, а не с фактическим сервером. Идея заключается в том, что для клиента не должно быть абсолютно никакой разницы в том, как он отправляет запросы, если не подключен непосредственно к серверу, на самом деле он может даже не знать, подключен ли он к целевому серверу или нет. Аналогичным образом, этот принцип гласит, что сервер может получать клиентские запросы от посредника, а не непосредственно от клиента, поэтому он никогда не должен предполагать, что другая сторона соединения является клиентом.

Это важная функция REST, поскольку возможность добавления промежуточных узлов позволяет архитекторам приложений разрабатывать большие и сложные сети, которые могут удовлетворить большой объем запросов с помощью балансировщика нагрузки, кэшей, прокси-серверов и т.д.

#### Cache

Этот принцип расширяет многоуровневую систему, явно указывая, что сервер или посредник может кэшировать ответы на запросы, которые часто поступают для повышения производительности системы. Существует реализация кэша, с которой вы, вероятно, знакомы: один во всех веб-браузерах. Слой кэша веб-браузера часто используется, чтобы избежать необходимости запрашивать одни и те же файлы, такие как изображения, снова и снова.

Для целей API целевой сервер должен указать с помощью элементов управления кэшем, может ли ответ кэшироваться посредниками, когда он возвращается клиенту. Обратите внимание, что поскольку по соображениям безопасности API, развернутые в рабочей среде, должны использовать шифрование, кэширование обычно не выполняется на промежуточном узле, если только этот узел не завершает соединение SSL или не выполняет расшифровку и повторное шифрование.

#### Code On Demand

Это необязательное требование, указывающее, что сервер может предоставлять исполняемый код в ответах клиенту. Поскольку этот принцип требует соглашения между сервером и клиентом о том, какой исполняемый код может выполнять клиент, это редко используется в API. Вы могли бы подумать, что сервер может вернуть код JavaScript для запуска веб-браузеров, но REST специально не предназначен для клиентов веб-браузера. Например, выполнение JavaScript может привести к усложнению, если клиент является iOS или Android-устройством.

#### Stateless

Принцип stateless является одним из двух в центре большинства дебатов между пуристами REST и прагматиками. В нем указано, что REST API не должен сохранять любое состояние клиента, которое будет вызвано каждый раз, когда данный клиент отправляет запрос. Это означает, что ни один из механизмов, которые являются обычными в веб-разработке для «запоминания» пользователей при навигации по страницам приложения, не может быть использован. В API без состояния каждый запрос должен включать информацию, которую сервер должен идентифицировать и аутентифицировать клиента и выполнить запрос. Это также означает, что сервер не может хранить данные, относящиеся к клиентскому соединению в базе данных или другой форме хранения.

Если вам интересно, почему REST требует сервер без состояния, то основная причина заключается в том, что серверы без учета состояния (stateless) очень просты в масштабировании, все, что вам нужно сделать, это запустить несколько экземпляров сервера за балансировщиком нагрузки. Если сервер хранит состояние клиента, ситуация становится более сложной, так как вам нужно выяснить, как несколько серверов могут получить доступ и обновить это состояние, или же гарантировать, что данный клиент всегда обрабатывается одним и тем же сервером, что обычно называется липкими сеансами.

Если вы снова рассмотрите маршрут /translate, обсуждаемый в начале главы, вы поймете, что его нельзя считать RESTful, потому что функция вида, связанная с этим маршрутом, полагается на декодер `@login_required` из Flask-Login, который, в свою очередь, хранит зарегистрированный в состоянии пользователя в сеансе пользователя Flask.

#### Uniform Interface

Последний, самый важный, самый обсуждаемый и наиболее неопределенно документированный принцип REST --- это единый интерфейс. Д-р Филдинг перечисляет четыре отличительных аспекта единого интерфейса REST: уникальные идентификаторы ресурсов, представления ресурсов, самоописательные сообщения и гипермедиа.

Уникальные идентификаторы ресурсов получаются путем назначения уникального URL-адреса каждому ресурсу. Например, URL-адрес, связанный с данным пользователем, может быть /api/users/\<user-id\>, где \<user-id\> --- это идентификатор, назначенный пользователю в качестве первичного ключа таблицы базы данных. Это вполне приемлемо реализовано большинством API.

Использование представлений ресурсов означает, что если сервер и клиент обмениваются информацией о ресурсе, они должны использовать согласованный Формат. Для большинства современных API Формат JSON используется для построения представлений ресурсов. API может поддерживать несколько форматов представления ресурсов, и в этом случае параметры согласования содержимого в протоколе HTTP являются механизмом, с помощью которого клиент и сервер могут согласовать формат, который нравится обоим.

Самоописательные сообщения означают, что запросы и ответы, которыми обмениваются клиенты и сервер, должны включать всю информацию, необходимую другой стороне. Типичный пример --- это метод запроса HTTP используемый для указания, какую операцию клиент хочет получить от сервера. Запрос `GET` указывает, что клиент хочет получить сведения о ресурсе, запрос `POST` указывает, что клиент хочет создать новый ресурс, запросы `PUT` или `PATCH` определяют изменения существующих ресурсов, а запрос `DELETE` указывает на удаление ресурса. Целевой ресурс указывается как URL-адрес запроса с дополнительной информацией, представленной в заголовках HTTP, части строки запроса URL-адреса или тела(body) запроса.

Требование hypermedia является наиболее полемичным из множества, и тот, который реализуется немногими API, и те API, которые реализуют его, редко делают так, чтобы удовлетворить пуристов REST. Поскольку все ресурсы в приложении взаимосвязаны, это требует обязательного включения связей в представления ресурсов, чтобы клиенты могли обнаруживать новые ресурсы путем обхода связей, почти так же, как вы обнаруживаете новые страницы в веб-приложении, щелкая ссылки, которые ведут вас от одной страницы к другой. Идея заключается в том, что клиент может войти в API без каких-либо предварительных знаний о ресурсах в нем и узнать о них, просто перейдя по ссылкам hypermedia. Одним из аспектов, которые усложняют выполнение данного требования заключается в том, что в отличие от HTML и XML, Формат json, который обычно используется для представления ресурсов в API не определяет стандартный способ включения ссылок, так что вы вынуждены использовать специальные настраиваемые структуры, или один из предлагаемых расширений JSON, которые пытаются восполнить этот пробел, такие как [JSON-API](http://jsonapi.org/) , [HAL](http://stateless.co/hal_specification.html) , [JSON-LD](https://json-ld.org/) или похожие.

### Реализация концепции API Blueprint

Чтобы дать вам представление о том, что участвует в разработке API, я собираюсь добавить его в микроблог. Это не будет полный API, я собираюсь реализовать все функции, связанные с пользователями, оставляя реализацию других ресурсов, таких как сообщения в блоге для читателя в качестве упражнения.

Чтобы все было организовано и структурировано в соответствии с концепцией описанной в [Главе 15](https://habrahabr.ru/post/351218/) , я собираюсь создать новый проект, который будет содержать все маршруты API. Итак, давайте начнем с создания каталога, в котором будет жить этот проект:

    (venv) $ mkdir app/api

Blueprint-овый файл `__init __. py` создает объект blueprint, аналогичный другим blueprint-овым приложениям:

> **`app/api/__init__.py:`** API blueprint constructor.

    from flask import Blueprint

    bp = Blueprint('api', __name__)

    from app.api import users, errors, tokens

Вы, вероятно, помните, что иногда необходимо переместить импорт на самое дно модуля, чтобы избежать циклических ошибок зависимостей. Это причина, почему *app/api/users.py* , *app/api/errors.py* и *app/api/tokens.py* модули (что мне еще предстоит написать) импортируются после создания проекта.

Основное содержание API будет храниться в модуле *app/api/users.py* . В следующей таблице перечислены маршруты, которые я собираюсь реализовать:

  HTTP Method   Resource URL                  Notes
  ------------- ----------------------------- --------------------------------------------------------------
  GET           `/api/users/<id>`             Возвращает пользователя.
  GET           `/api/users`                  Возвращает коллекцию всех пользователей.
  GET           `/api/users/<id>/followers`   Вернет подписчиков этого пользователя.
  GET           `/api/users/<id>/followed`    Вернет пользователей, на которых подписан этот пользователь.
  POST          `/api/users`                  Регистрирует новую учетную запись пользователя.
  PUT           `/api/users/<id>`             Изменяет пользователя.

Каркас модуля с заполнителями для всех этих маршрутов будет такой:

> **`app/api/users.py:`** Заполнители ресурсов API пользователя.

    from app.api import bp

    @bp.route('/users/<int:id>', methods=['GET'])
    def get_user(id):
        pass

    @bp.route('/users', methods=['GET'])
    def get_users():
        pass

    @bp.route('/users/<int:id>/followers', methods=['GET'])
    def get_followers(id):
        pass

    @bp.route('/users/<int:id>/followed', methods=['GET'])
    def get_followed(id):
        pass

    @bp.route('/users', methods=['POST'])
    def create_user():
        pass

    @bp.route('/users/<int:id>', methods=['PUT'])
    def update_user(id):
        pass

В модуле *app/api/errors.py* надо бы определить несколько вспомогательных функций, которые имеют дело с ответами на ошибки. Но сейчас, я создам заполнитель, который заполню позже:

> **`app/api/errors.py:`** Заполнитель обработки ошибок.

    def bad_request():
        pass

*app/api/tokens.py* модуль, в котором будет определена подсистема аутентификации. Это обеспечит альтернативный способ входа для клиентов, которые не являются веб-браузерами. Напишем заполнитель и для этого модуля:

> **`app/api/tokens.py:`** Обработки маркеров.

    def get_token():
        pass

    def revoke_token():
        pass

Новая схема элементов API Blueprint должна быть зарегистрирована в функции фабрики приложений:

> **`app/__init__.py:`** Зарегистрируйте схему элементов API в приложении.

    # ...

    def create_app(config_class=Config):
        app = Flask(__name__)

        # ...

        from app.api import bp as api_bp
        app.register_blueprint(api_bp, url_prefix='/api')

        # ...

### Представление пользователей в виде объектов JSON

Первый аспект, который следует учитывать при реализации API, --- это решить, каким будет представление его ресурсов. Я собираюсь реализовать API, который работает с пользователями, поэтому представление для моих пользовательских ресурсов-это то, что мне нужно решить. После некоторого мозгового штурма, я придумал следующее представление json :

    {
        "id": 123,
        "username": "susan",
        "password": "my-password",
        "email": "susan@example.com",
        "last_seen": "2017-10-20T15:04:27Z",
        "about_me": "Hello, my name is Susan!",
        "post_count": 7,
        "follower_count": 35,
        "followed_count": 21,
        "_links": {
            "self": "/api/users/123",
            "followers": "/api/users/123/followers",
            "followed": "/api/users/123/followed",
            "avatar": "https://www.gravatar.com/avatar/..."
        }
    }

Многие из полей непосредственно поступают из модели пользовательской базы данных. Поле `password` отличается тем, что оно будет использоваться только при регистрации нового пользователя. Как вы помните из [главы 5](https://habrahabr.ru/post/346346/) , пользовательские пароли не хранятся в базе данных, а только хэш, поэтому пароль никогда не возвращается. Поле `email` также обрабатывается специально, потому что я не хочу раскрывать адреса электронной почты пользователей. Поле электронной почты будет возвращено только тогда, когда пользователи будут запрашивать их собственную запись, но не при получении записей от других пользователей. Поля `post_count` , `follower_count` и `follow_count` являются «виртуальными» полями, которые не существуют в качестве полей в базе данных, но предоставляются клиенту в качестве удобства. Это отличный пример, демонстрирующий, что представление ресурса не обязательно должно соответствовать тому, как фактический ресурс определен на сервере.

Обратите внимание на раздел `_links` , который реализует требования hypermedia. Определенные ссылки включают ссылки на текущий ресурс, список пользователей, следующих за этим пользователем, список пользователей, за которыми следует пользователь, и, наконец, ссылку на изображение аватара пользователя. В будущем, если я решу добавить сообщения в этот API, ссылка на список сообщений пользователя также должна быть здесь включена.

Одна из приятных особенностей формата JSON заключается в том, что он всегда переводится как представление в виде словаря или списка Python. Пакет `json` из стандартной библиотеки Python заботится о преобразовании структур данных Python в JSON и из него. Поэтому, чтобы сгенерировать эти представления, я собираюсь добавить метод к модели `User` , называемый `to_dict()` , который возвращает словарь Python:

> **`app/models.py:`** Модель пользователя для представления.

    from flask import url_for
    # ...

    class User(UserMixin, db.Model):
        # ...

        def to_dict(self, include_email=False):
            data = {
                'id': self.id,
                'username': self.username,
                'last_seen': self.last_seen.isoformat() + 'Z',
                'about_me': self.about_me,
                'post_count': self.posts.count(),
                'follower_count': self.followers.count(),
                'followed_count': self.followed.count(),
                '_links': {
                    'self': url_for('api.get_user', id=self.id),
                    'followers': url_for('api.get_followers', id=self.id),
                    'followed': url_for('api.get_followed', id=self.id),
                    'avatar': self.avatar(128)
                }
            }
            if include_email:
                data['email'] = self.email
            return data

Этот метод не должен вызывать особых вопросов и быть в основном понятным. Словарь с пользовательским представлением, на котором я остановился, просто генерируется и возвращается. Как я уже упоминал выше, поле `email` нуждается в специальной обработке, потому что я хочу включить электронную почту только тогда, когда пользователи запрашивают свои собственные данные. Поэтому я использую флаг `include_email` , чтобы определить, включено ли это поле в представление или нет.

Обратите внимание, как генерируется поле `last_seen` . Для полей даты и времени я собираюсь использовать Формат [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) , который может генерировать `datetime` Python с помощью метода `isoformat()` . Но поскольку я использую наивные объекты `datetime` , которые являются UTC, но не имеют часового пояса, записанного в их состоянии, мне нужно добавить `Z` в конце, что является кодом часового пояса ISO 8601 для UTC.

> *Пояснение от [amkko](https://habr.com/ru/users/Amikko/) :* В python объекты datetime могут быть «наивными» или «осведомлёнными» (naive/aware) относительно часового пояса.

Наконец, зацените, как я реализовал hipermedia-ссылки. Для трех ссылок, которые указывают на другие маршруты приложений, я использую `url_for()` для генерации URL-адресов (которые в настоящее время указывают на функции просмотра замещающих элементов, определенные в *app/api/users.py* ). Ссылка аватара особенная, потому что это URL-адрес Gravatar, внешний для приложения. Для этой ссылки я использую тот же метод `avatar()` , который я использовал для рендеринга аватаров на веб-страницах.

Метод `to_dict()` преобразует пользовательский объект в представление Python, которое затем будет преобразовано в JSON. Мне также нужно позаботиться об обратном направлении, где клиент передает представление пользователя в запросе, а сервер должен проанализировать его и преобразовать в объект `User` . Вот метод `from_dict()` , который достигает преобразования из словаря Python в модель:

> **`app/models.py:`** Представление модели пользователя.

    class User(UserMixin, db.Model):
        # ...

        def from_dict(self, data, new_user=False):
            for field in ['username', 'email', 'about_me']:
                if field in data:
                    setattr(self, field, data[field])
            if new_user and 'password' in data:
                self.set_password(data['password'])

В этом случае я решил использовать цикл для импорта любого из полей, которые клиент может установить: `username` , `email` и `about_me` . Для каждого поля я проверяю, есть ли значение в аргументе `data` , и если есть, я использую `setattr()` Python, чтобы установить новое значение в соответствующем атрибуте для объекта.

Поле `password` рассматривается как особый случай, поскольку оно не является полем в объекте. Аргумент `new_user` определяет, является ли это регистрацией нового пользователя, что означает, что пароль включен. Чтобы установить `password` в пользовательской модели, я вызываю метод `set_password()` , который создает хэш пароля.

### Представление коллекций пользователей

Помимо работы с одиночными представлениями ресурсов, этот API будет нуждаться в представлении для группы пользователей. Это будет Формат, используемый, например, когда клиент запрашивает список пользователей или подписчиков. Вот представление для коллекции пользователей:

    {
        "items": [
            { ... user resource ... },
            { ... user resource ... },
            ...
        ],
        "_meta": {
            "page": 1,
            "per_page": 10,
            "total_pages": 20,
            "total_items": 195
        },
        "_links": {
            "self": "http://localhost:5000/api/users?page=1",
            "next": "http://localhost:5000/api/users?page=2",
            "prev": null
        }
    }

В этом представлении `items` -это список пользовательских ресурсов, каждый из которых определен, как описано в предыдущем разделе. Раздел `_meta` включает в себя метаданные коллекции, которые клиент может найти полезными при представлении пользователю элементов управления разбиением на страницы. В разделе `_links` определяются соответствующие ссылки, включая ссылку на саму коллекцию, а также ссылки на предыдущую и следующую страницы, чтобы помочь клиенту разбить список на страницы.

Создание представления коллекции пользователей сложно из-за логики разбиения на страницы, но логика будет общей для других ресурсов, которые я, возможно, захочу Добавить в этот API в будущем, поэтому я собираюсь реализовать это представление общим способом, который я могу затем применить к другим моделям. Еще в [главе 16](https://habrahabr.ru/post/351900/) я был в аналогичной ситуации с индексами полнотекстового поиска, еще одной функцией, которую я хотел реализовать в общем виде, чтобы ее можно было применить к любым моделям. Решение, которое я использовал, состояло в том, чтобы реализовать класс `SearchableMixin` , от которого могут наследовать любые модели, которым нужен полнотекстовый индекс. Я собираюсь использовать ту же идею для этого, так вот новый класс mixin, который я назвал `PaginatedAPIMixin` :

> **`app/models.py:`** Разбитое на страницы представление класса mixin.

    class PaginatedAPIMixin(object):
        @staticmethod
        def to_collection_dict(query, page, per_page, endpoint, **kwargs):
            resources = query.paginate(page, per_page, False)
            data = {
                'items': [item.to_dict() for item in resources.items],
                '_meta': {
                    'page': page,
                    'per_page': per_page,
                    'total_pages': resources.pages,
                    'total_items': resources.total
                },
                '_links': {
                    'self': url_for(endpoint, page=page, per_page=per_page,
                                    **kwargs),
                    'next': url_for(endpoint, page=page + 1, per_page=per_page,
                                    **kwargs) if resources.has_next else None,
                    'prev': url_for(endpoint, page=page - 1, per_page=per_page,
                                    **kwargs) if resources.has_prev else None
                }
            }
            return data

Метод `to_collection_dict()` создает словарь с представлением пользовательской коллекции, включая разделы `items` , `_meta` и `_links` . Я бы советовал вам внимательно изучить метод, чтобы понять, как он работает. Первые три аргумента-объект запроса Flask-SQLAlchemy, номер страницы и Размер страницы. Эти аргументы определяют, какие элементы будут возвращены. Реализация использует метод `paginate()` объекта запроса, чтобы получить стоимость страницы элементов, как я сделал с сообщениями в индексе, исследуйте и профилируйте страницы веб-приложения.

Сложная часть заключается в создании ссылок, которые включают в себя ссылку и ссылки на следующую и предыдущие страницы. Я хотел бы сделать эту функцию обобщенной, поэтому я не мог, например, использовать `url_for ('api.get_users', id = id, page = page)` для создания собственной ссылки. Аргументы для `url_for()` будут зависеть от конкретной коллекции ресурсов, поэтому я буду полагаться на передачу вызывающего в аргументе конечной точки функции представления, которую нужно отправить `url_for()` . И поскольку у многих маршрутов есть аргументы, мне также нужно захватить дополнительные аргументы ключевого слова в `kwargs` и передать их `url_for()` . Строка аргумента строки `page` и `per_page` указывается явно, поскольку они управляют разбиением на страницы для всех маршрутов API.

Этот класс mixin должен быть добавлен в модель `User` в качестве родительского класса:

> **`app/models.py:`** Добавьте PaginatedAPIMixin в модель пользователя.

    class User(PaginatedAPIMixin, UserMixin, db.Model):
        # ...

В случае с коллекциями мне не понадобится обратное направление, потому что у меня не будет маршрутов, требующих от клиента отправки списков пользователей.

### Обработка ошибок

Страницы ошибок, которые я определил в [главе 7](https://habrahabr.ru/post/346880/) , подходят только для пользователя, который взаимодействует с приложением, используя веб-браузер. Когда API должен возвращать ошибку, она должен быть «дружественного машине» типа ошибки, то, что клиентское приложение сможет легко интерпретировать. Точно так же я определил представления для своих ресурсов API в JSON, теперь я собираюсь принять решение о представлении сообщений об ошибках API. Вот основная структура, которую я собираюсь использовать:

    {
        "error": "short error description",
        "message": "error message (optional)"
    }

В дополнение к полезной нагрузке ошибки я буду использовать коды состояния из протокола HTTP для указания общего класса ошибки. Чтобы помочь мне сгенерировать эти ответы на ошибки, я собираюсь написать функцию `error_response()` в *app/api/errors.py* :

> **`app/api/errors.py:`** Ответы об ошибках.

    from flask import jsonify
    from werkzeug.http import HTTP_STATUS_CODES

    def error_response(status_code, message=None):
        payload = {'error': HTTP_STATUS_CODES.get(status_code, 'Unknown error')}
        if message:
            payload['message'] = message
        response = jsonify(payload)
        response.status_code = status_code
        return response

Эта функция использует удобный словарь `HTTP_STATUS_CODES` из `Werkzeug` (основная зависимость Flask), который предоставляет краткое описательное имя для каждого кода состояния HTTP. Я использую эти имена для поля `error` в своих представлениях ошибок, поэтому мне нужно беспокоиться только о числовом коде состояния и необязательном длинном описании. Функция `jsonify()` возвращает объект `Response` Flask с кодом состояния по умолчанию 200, поэтому после создания ответа я устанавливаю код состояния на правильный для ошибки.

Наиболее распространенной ошибкой, которую API собирается вернуть, будет код 400, который является ошибкой для \"плохого запроса\". Это-ошибка, которая используется, когда клиент передает запрос, который имеет недопустимые данные в нем. Чтобы сделать эту ошибку еще проще, я добавлю для нее специальную функцию, которая требует только длинного описательного сообщения в качестве аргумента. Это заполнитель `bad_request()` , который я добавил ранее:

> **`app/api/errors.py:`** Ответы на плохие запросы.

    # ...

    def bad_request(message):
        return error_response(400, message)

### Конечные точки пользовательских ресурсов

Поддержка, которая мне нужна для работы с представлениями пользователей JSON, теперь завершена, поэтому я готов начать кодирование конечных точек API.

### Получение пользователя

Начнем с запроса на получение одного пользователя, заданного `id` :

> **`app/api/users.py:`** Возврат пользователя.

    from flask import jsonify
    from app.models import User

    @bp.route('/users/<int:id>', methods=['GET'])
    def get_user(id):
        return jsonify(User.query.get_or_404(id).to_dict())

Функция view получает идентификатор запрошенного пользователя в качестве динамического аргумента в URL-адресе. Метод `get_or_404()` объекта запроса является очень полезным вариантом метода `get()` , который вы видели ранее, который также возвращает объект с заданным идентификатором, если он существует, но вместо того, чтобы возвращать `None` , когда `id` не существует, он прерывает запрос и возвращает ошибку 404 клиенту. Преимущество `get_or_404()` перед `get()` заключается в том, что он устраняет необходимость проверять результат запроса, упрощая логику в функциях представления.

Метод `to_dict()` , который я добавил к `User` , используется для создания словаря с представлением ресурса для выбранного пользователя, а затем функция Flask `jsonify()` преобразует этот словарь в формат JSON для возврата клиенту.

Если вы хотите увидеть, как работает этот первый маршрут API, запустите сервер, а затем введите следующий URL-адрес в адресной строке браузера:

    http://localhost:5000/api/users/1

Результат должен показать вам первого пользователя, отображенного в формате JSON. Также попробуйте использовать большое значение `id` , чтобы увидеть, как метод `get_or_404()` объекта запроса SQLAlchemy вызывает ошибку 404 (я позже покажу вам, как расширить обработку ошибок, чтобы эти ошибки также возвращались в формате JSON).

Чтобы протестировать этот новый маршрут, я установлю [HTTPie](https://httpie.org/) , HTTP-клиент командной строки, написанный на Python, который упрощает отправку запросов API:

    (venv) $ pip install httpie

Теперь я могу запросить информацию о пользователе с идентификатором 1 (который, вероятно, ты сам и есть) с помощью следующей команды:

    (venv) $ http GET http://localhost:5000/api/users/1
    HTTP/1.0 200 OK
    Content-Length: 457
    Content-Type: application/json
    Date: Mon, 27 Nov 2017 20:19:01 GMT
    Server: Werkzeug/0.12.2 Python/3.6.3

    {
        "_links": {
            "avatar": "https://www.gravatar.com/avatar/993c...2724?d=identicon&s=128",
            "followed": "/api/users/1/followed",
            "followers": "/api/users/1/followers",
            "self": "/api/users/1"
        },
        "about_me": "Hello! I'm the author of the Flask Mega-Tutorial.",
        "followed_count": 0,
        "follower_count": 1,
        "id": 1,
        "last_seen": "2017-11-26T07:40:52.942865Z",
        "post_count": 10,
        "username": "miguel"
    }

### Получение коллекций пользователей

Чтобы вернуть коллекцию всех пользователей, теперь я могу полагаться на метод `to_collection_dict()` PaginatedAPIMixin:

> app/api/users.py: Возвращает коллекцию всех пользователей.

    from flask import request

    @bp.route('/users', methods=['GET'])
    def get_users():
        page = request.args.get('page', 1, type=int)
        per_page = min(request.args.get('per_page', 10, type=int), 100)
        data = User.to_collection_dict(User.query, page, per_page, 'api.get_users')
        return jsonify(data)

Для этой реализации я сначала извлекаю `page` и `per_page` из строки запроса, используя значения по умолчанию 1 и 10 соответственно, если они не определены. `per_page` имеет дополнительную логику, которая ограничивает его 100. Предоставление клиентского элемента управления для запроса действительно больших страниц не является хорошей идеей, так как это может вызвать на сервере проблемы с производительностью. Аргументы `page` и `per_page` затем передаются методу `to_collection_query()` вместе с запросом, который в данном случае является просто `User.query` -самый универсальный запрос, возвращающий всех пользователей. Последний аргумент- `api.get_users` , является именем конечной точки, который мне нужен для трех ссылок что бы использовать их в представлении.

Чтобы проверить эту конечную точку с помощью HTTPie, используйте следующую команду:

    (venv) $ http GET http://localhost:5000/api/users
    The next two endpoints are the ones that return the follower and followed users. These are fairly similar to the one above:

    app/api/users.py: Return followers and followed users.

    @bp.route('/users/<int:id>/followers', methods=['GET'])
    def get_followers(id):
        user = User.query.get_or_404(id)
        page = request.args.get('page', 1, type=int)
        per_page = min(request.args.get('per_page', 10, type=int), 100)
        data = User.to_collection_dict(user.followers, page, per_page,
                                       'api.get_followers', id=id)
        return jsonify(data)

    @bp.route('/users/<int:id>/followed', methods=['GET'])
    def get_followed(id):
        user = User.query.get_or_404(id)
        page = request.args.get('page', 1, type=int)
        per_page = min(request.args.get('per_page', 10, type=int), 100)
        data = User.to_collection_dict(user.followed, page, per_page,
                                       'api.get_followed', id=id)
        return jsonify(data)

Поскольку эти два маршрута специфичны для пользователя, у них есть динамический аргумент `id` . Идентификатор используется для получения пользователя из базы данных, а затем для предоставления `user.followers` и `user.followed` отношения на основе запросов к `to_collection_dict()` , так что, надеюсь, теперь вы можете увидеть, почему затраты дополнительного времени и проектирование этого метода в общем виде действительно окупается. Последние два аргумента `to_collection_dict()` --- это имя конечной точки и идентификатор, который метод будет принимать в качестве дополнительного аргумента ключевого слова в `kwargs` , а затем передавать его в `url_for()` при создании раздела ссылок представления.

Как и в предыдущем примере, вы можете использовать эти два маршрута с HTTPie следующим образом:

    (venv) $ http GET http://localhost:5000/api/users/1/followers
    (venv) $ http GET http://localhost:5000/api/users/1/followed

Я должен отметить, что благодаря hypermedia вам не нужно запоминать эти URL-адреса, поскольку они включены в раздел `_links` пользовательского представления.

### Регистрация новых пользователей

Запрос `POST` на маршрут /users будет использоваться для регистрации новых учетных записей пользователей. Вы можете увидеть реализацию этого маршрута ниже:

> **`app/api/users.py:`** Зарегистрируйте нового пользователя.

    from flask import url_for
    from app import db
    from app.api.errors import bad_request

    @bp.route('/users', methods=['POST'])
    def create_user():
        data = request.get_json() or {}
        if 'username' not in data or 'email' not in data or 'password' not in data:
            return bad_request('must include username, email and password fields')
        if User.query.filter_by(username=data['username']).first():
            return bad_request('please use a different username')
        if User.query.filter_by(email=data['email']).first():
            return bad_request('please use a different email address')
        user = User()
        user.from_dict(data, new_user=True)
        db.session.add(user)
        db.session.commit()
        response = jsonify(user.to_dict())
        response.status_code = 201
        response.headers['Location'] = url_for('api.get_user', id=user.id)
        return response

Этот запрос будет принимать представление пользователя в формате JSON от клиента, предоставленного в теле запроса. Flask предоставляет метод `request.get_json()` , чтобы извлечь JSON из запроса и вернуть его в виде структуры Python. Этот метод возвращает `None` , если данные JSON не найдены в запросе, поэтому я могу гарантировать, что я всегда получаю словарь, используя запрос `request.get_json()` или `{}` .

Прежде чем я смогу использовать данные, мне нужно убедиться, что у меня есть вся информация, поэтому я начинаю с проверки того, что включены три обязательных поля. Это `username` , `email` и `password` . Если какой-либо из них отсутствует, то я использую вспомогательную функцию `bad_request()` из *app/api/errors.py* для возврата клиенту ошибки. В дополнение к этой проверке мне нужно убедиться, что поля `username` и `email` еще не используются другим пользователем, поэтому для этого я пытаюсь загрузить пользователя из базы данных по имени пользователя и электронной почте, и если какой-либо из них возвращает действительного пользователя, я также возвращаю ошибку обратно клиенту.

После того, как я прошел проверку данных, я могу легко создать объект пользователя и добавить его в базу данных. Для создания пользователя я использую метод `from_dict()` в пользовательской модели. Аргумент `new_user` имеет значение `True` , поэтому он также принимает поле `password` , которое обычно не является частью представления пользователя.

Ответ, который я верну для этого запроса, будет представлением нового пользователя, поэтому `to_dict()` генерирует эту полезную нагрузку. Код состояния для запроса `POST` , который создает ресурс, должен быть `201` , который используется, когда новый объект был успешно создан. Кроме того, для протокола HTTP требуется, чтобы ответ `201` включал заголовок Location, который задан URL-адресом нового ресурса.

Ниже вы можете увидеть, как зарегистрировать нового пользователя из командной строки через HTTPie:

    (venv) $ http POST http://localhost:5000/api/users username=alice password=dog \
        email=alice@example.com "about_me=Hello, my name is Alice!"

### Редактирование пользователей

Последняя конечная точка, которую я собираюсь использовать в своем API, --- это та, которая изменяет существующего пользователя:

> **`app/api/users.py:`** Изменение пользователя.

    @bp.route('/users/<int:id>', methods=['PUT'])
    def update_user(id):
        user = User.query.get_or_404(id)
        data = request.get_json() or {}
        if 'username' in data and data['username'] != user.username and \
                User.query.filter_by(username=data['username']).first():
            return bad_request('please use a different username')
        if 'email' in data and data['email'] != user.email and \
                User.query.filter_by(email=data['email']).first():
            return bad_request('please use a different email address')
        user.from_dict(data, new_user=False)
        db.session.commit()
        return jsonify(user.to_dict())

Для этого запроса я получаю `id` пользователя как динамическую часть URL, поэтому я могу загрузить назначенного пользователя и вернуть ошибку `404` , если она не найдена. Как и в случае с новым пользователем, мне нужно проверить, что поля `username` и `email` , предоставленные клиентом, не сталкиваются с другими пользователями, прежде чем я смогу их использовать, но в этом случае проверка немного сложнее. Прежде всего, эти поля являются необязательными в этом запросе, поэтому мне нужно проверить, что поле присутствует. Второе осложнение заключается в том, что клиент может предоставлять одно и то же значение, поэтому, прежде чем я проверю, берется ли имя пользователя или электронная почта, мне нужно убедиться, что они отличаются от текущих. Если какая-либо из этих проверок завершится ошибкой, я верну клиенту ошибку `400` , как и раньше.

После проверки данных я могу использовать метод `From_dict()` пользовательской модели для импорта всех данных, предоставленных клиентом, а затем зафиксировать изменение в базе данных. Ответ на этот запрос возвращает пользователю обновленное представление пользователя с кодом состояния по умолчанию `200` .

Вот пример запроса, который редактирует поле `about_me` с HTTPie:

    (venv) $ http PUT http://localhost:5000/api/users/2 "about_me=Hi, I am Miguel"

### API Аутентификация

Конечные точки API, которые я добавил в предыдущем разделе, в настоящее время открыты для любых клиентов. Очевидно, что они должны быть доступны только зарегистрированным пользователям, и для этого мне нужно добавить *аутентификацию* и *авторизацию* , или «AuthN» и «AuthZ» для краткости. Идея состоит в том, что запросы, отправленные клиентами, предоставляют некоторую идентификацию, так что сервер знает, какого пользователя представляет клиент, и может проверить, разрешено или нет запрошенное действие для этого пользователя.

Наиболее очевидным способом защиты этих конечных точек API является использование декоратора `@login_required` из Flask-Login, но у этого подхода есть некоторые проблемы. Когда декоратор обнаруживает не аутентифицированного пользователя, он перенаправляет пользователя на HTML страницу входа в систему. В API нет концепции страниц HTML или входа в систему, если клиент отправляет запрос с недопустимыми или отсутствующими учетными данными, сервер должен отказаться от запроса, возвращающего код состояния 401. Сервер не может предположить, что клиент API является веб-браузером или он может обрабатывать переадресации или что он может отображать и обрабатывать формы входа в систему HTML. Когда API клиента получает код состояния 401, клиент знает, что ему нужно запросить у пользователя учетные данные, но как это происходит, на самом деле это не дело сервера.

### Маркеры(токены) в пользовательской модели

Для проверки подлинности API я собираюсь использовать схему аутентификации с токеном. Когда клиент хочет начать взаимодействие с API, ему необходимо запросить временный токен, аутентифицироваться с именем пользователя и паролем. Затем клиент может отправлять запросы API, передающие токен в качестве аутентификации, до тех пор, пока токен действителен. По истечении срока действия токена необходимо запросить новый токен. Для поддержки токенов пользователей я собираюсь расширить модель `User` :

> **`app/models.py:`** Поддержка пользовательских токенов.

    import base64
    from datetime import datetime, timedelta
    import os

    class User(UserMixin, PaginatedAPIMixin, db.Model):
        # ...
        token = db.Column(db.String(32), index=True, unique=True)
        token_expiration = db.Column(db.DateTime)

        # ...

        def get_token(self, expires_in=3600):
            now = datetime.utcnow()
            if self.token and self.token_expiration > now + timedelta(seconds=60):
                return self.token
            self.token = base64.b64encode(os.urandom(24)).decode('utf-8')
            self.token_expiration = now + timedelta(seconds=expires_in)
            db.session.add(self)
            return self.token

        def revoke_token(self):
            self.token_expiration = datetime.utcnow() - timedelta(seconds=1)

        @staticmethod
        def check_token(token):
            user = User.query.filter_by(token=token).first()
            if user is None or user.token_expiration < datetime.utcnow():
                return None
            return user

С этим изменением я добавляю атрибут `token` в пользовательскую модель, и поскольку мне нужно будет искать базу данных по ней, я делаю ее уникальной и индексированной. Я также добавил `token_expiration` , в котором есть дата и время истечения срока действия токена. Это делается для того, чтобы маркер не оставался действительным в течение длительного периода времени, что может стать угрозой безопасности.

Я создал три метода работы с этими токенами. Метод `get_token()` возвращает токен для пользователя. Токен генерируется как случайная строка, закодированная в base64, так что все символы находятся в читаемом диапазоне. Перед созданием нового токена этот метод проверяет, есть ли у назначенного токена по крайней мере минута до истечения срока действия, и в этом случае возвращается существующий токен.

При работе с токенами всегда полезно иметь стратегию немедленного отзыва токена, а не полагаться только на дату истечения срока действия. Это лучшая практика в области безопасности, которую часто упускают из виду. Метод `revoke_token()` делает маркер, назначенный пользователю, недействительным, просто установив дату истечения срока действия на одну секунду до текущего времени.

Метод `check_token()` является статическим методом, который принимает токен в качестве входных данных и возвращает пользователя, которому этот токен принадлежит в качестве ответа. Если токен недействителен или истек, метод возвращает None.

Поскольку я внес изменения в базу данных, мне нужно создать новую миграцию базы данных, а затем обновить ее:

    (venv) $ flask db migrate -m "user tokens"
    (venv) $ flask db upgrade

### Запросы Маркеров(токенов)

Когда вы пишете API, вы должны учитывать, что ваши клиенты не всегда будут веб-браузерами, подключенными к веб-приложению. Реальная сила API приходит, когда автономные клиенты, такие как приложения для смартфонов или даже браузерные одностраничные приложения могут иметь доступ к серверным службам. Когда эти специализированные клиенты нуждаются в доступе к службам API, они начинают с запроса маркера, который является аналогом формы входа в традиционное веб-приложение.

Чтобы упростить взаимодействие между клиентом и сервером при использовании аутентификации токенов, я собираюсь использовать расширение Flask под названием [Flask-HTTPAuth](https://flask-httpauth.readthedocs.io/) . Flask-HTTPAuth устанавливается с pip:

    (venv) $ pip install flask-httpauth

Flask-HTTPAuth поддерживает несколько различных механизмов аутентификации, все API дружественные. Для начала я собираюсь использовать [HTTP Basic Authentication](https://en.wikipedia.org/wiki/Basic_access_authentication) или [тут 11.1](http://lib.ru/WEBMASTER/rfc2068/section-11.html) , в которой клиент отправляет учетные данные пользователя в стандартном заголовке http авторизации. Для интеграции с Flask-HTTPAuth приложение должно предоставить две функции: одну, которая определяет логику для проверки имени пользователя и пароля, предоставленных пользователем, и другую, которая возвращает ответ об ошибке в случае сбоя аутентификации. Эти функции регистрируются в Flask-HTTPAuth через декораторы, а затем автоматически вызываются расширением по мере необходимости во время потока проверки подлинности. Вы можете увидеть реализацию:

> **`app/api/auth.py:`** Поддержка обычной проверки подлинности.

    from flask import g
    from flask_httpauth import HTTPBasicAuth
    from app.models import User
    from app.api.errors import error_response

    basic_auth = HTTPBasicAuth()

    @basic_auth.verify_password
    def verify_password(username, password):
        user = User.query.filter_by(username=username).first()
        if user is None:
            return False
        g.current_user = user
        return user.check_password(password)

    @basic_auth.error_handler
    def basic_auth_error():
        return error_response(401)

Класс `HTTPBasicAuth` из Flask-HTTPAuth-это класс, реализующий основной поток проверки подлинности. Две необходимые функции настраиваются с помощью декораторов `verify_password` и `error_handler` соответственно.

Функция проверки получает имя пользователя и пароль, предоставленные клиентом, и возвращает `True` , если учетные данные действительны, или `False` , если нет. Для проверки пароля я полагаюсь на метод `check_password()` класса `User` , который также используется Flask-Login при аутентификации для веб-приложения. Я сохраняю аутентифицированного пользователя в `g.current_user` , так что я могу получить доступ к нему из функций представления API.

Функция обработчика ошибок просто возвращает ошибку 401, сгенерированную функцией `error_response()` в *app/api/errors.py* . Ошибка 401 определяется в стандарте HTTP как \"Unauthorized\" ошибка (\"несанкционированного доступа\"). Клиенты HTTP знают, что при получении этой ошибки отправленный ими запрос должен быть повторно отправлен с действительными учетными данными.

Теперь у меня есть базовая поддержка аутентификации, поэтому я могу добавить маршрут поиска токенов, который будут вызывать клиенты, когда им нужен этот самый токен:

> **`app/api/tokens.py:`** Generate user tokens.

    from flask import jsonify, g
    from app import db
    from app.api import bp
    from app.api.auth import basic_auth

    @bp.route('/tokens', methods=['POST'])
    @basic_auth.login_required
    def get_token():
        token = g.current_user.get_token()
        db.session.commit()
        return jsonify({'token': token})

Эта функция представления обернута декоратором `@basic_auth.login_required` из экземпляра HTTPBasicAuth, который будет инструктировать Flask-HTTPAuth для проверки подлинности (через функцию проверки которую я определил выше) и разрешать функцию для запуска только, когда предоставленные учетные данные являются действительными. Реализация этой функции представления зависит от метода `get_token()` пользовательской модели для создания маркера. Фиксация базы данных выполняется после создания маркера, чтобы гарантировать, что токен и его срок действия будут записаны обратно в базу данных.

При попытке отправить запрос POST на маршрут API маркеров происходит следующее:

    (venv) $ http POST http://localhost:5000/api/tokens
    HTTP/1.0 401 UNAUTHORIZED
    Content-Length: 30
    Content-Type: application/json
    Date: Mon, 27 Nov 2017 20:01:00 GMT
    Server: Werkzeug/0.12.2 Python/3.6.3
    WWW-Authenticate: Basic realm="Authentication Required"

    {
        "error": "Unauthorized"
    }

Ответ HTTP включает в себя код состояния 401 и полезную нагрузку, которую я определил в моей функции `basic_auth_error()` . Вот тот же запрос, на этот раз включая базовые учетные данные:

    (venv) $ http --auth <username>:<password> POST http://localhost:5000/api/tokens
    HTTP/1.0 200 OK
    Content-Length: 50
    Content-Type: application/json
    Date: Mon, 27 Nov 2017 20:01:22 GMT
    Server: Werkzeug/0.12.2 Python/3.6.3

    {
        "token": "pC1Nu9wwyNt8VCj1trWilFdFI276AcbS"
    }

Теперь код состояния 200, который является кодом для успешного запроса, и полезные данные включают недавно созданный маркер для пользователя. Обратите внимание, что при отправке этого запроса необходимо заменить `<username>:<password>` своими учетными данными. Имя пользователя и пароль должны быть снабжены двоеточием в качестве разделителя.

### Защита маршрутов API с помощью токенов

Теперь клиенты могут запрашивать токен для использования с конечными точками API, поэтому осталось добавить проверку токена на эти конечные точки. Это то, что Flask-HTTPAuth также может обрабатывать для меня. Мне нужно создать второй экземпляр проверки подлинности на основе класса `HTTPTokenAuth` и предоставить обратный вызов проверки токена:

> **`app/api/auth.py:`** Поддержка аутентификации Token.

    # ...
    from flask_httpauth import HTTPTokenAuth

    # ...
    token_auth = HTTPTokenAuth()

    # ...

    @token_auth.verify_token
    def verify_token(token):
        g.current_user = User.check_token(token) if token else None
        return g.current_user is not None

    @token_auth.error_handler
    def token_auth_error():
        return error_response(401)

При использовании аутентификации по токенам Flask-HTTPAuth использует функцию `verify_token` , но кроме этого аутентификация токена работает так же, как и базовая аутентификация. Функция проверки токена использует `User.check_token()` , чтобы найти пользователя, которому принадлежит предоставленный токен. Функция также обрабатывает случай отсутствующего токена, установив текущего пользователя в `None` . Возвращаемое значение `True` или `False` определяет, может ли Flask-HTTPAuth разрешить выполнение функции просмотра или нет.

Чтобы защитить маршруты API с помощью токенов, необходимо добавить декоратор `@token_auth.login_required` :

> **`app/api/users.py:`** Protect user routes with token authentication.

    from app.api.auth import token_auth

    @bp.route('/users/<int:id>', methods=['GET'])
    @token_auth.login_required
    def get_user(id):
        # ...

    @bp.route('/users', methods=['GET'])
    @token_auth.login_required
    def get_users():
        # ...

    @bp.route('/users/<int:id>/followers', methods=['GET'])
    @token_auth.login_required
    def get_followers(id):
        # ...

    @bp.route('/users/<int:id>/followed', methods=['GET'])
    @token_auth.login_required
    def get_followed(id):
        # ...

    @bp.route('/users', methods=['POST'])
    def create_user():
        # ...

    @bp.route('/users/<int:id>', methods=['PUT'])
    @token_auth.login_required
    def update_user(id):
        # ...

Обратите внимание, что декоратор добавляется ко всем функциям представления API, кроме `create_user()` , который не может принять аутентификацию, так как пользователь, который запросит маркер, должен быть создан первым.

Если вы отправляете запрос на любую из этих конечных точек, как показано ранее, вы получите ответ об ошибке 401. Чтобы получить доступ, вам нужно добавить заголовок `Authorization` с маркером, который вы получили от запроса в */api/tokens* . Flask-HTTPAuth ожидает, что токен будет отправлен как токен-носитель, который напрямую не поддерживается HTTPie. Для базовой аутентификации с именем пользователя и паролем HTTPie предлагает параметр `--auth` , но для токенов заголовок должен быть явно указан. Вот синтаксис для отправки токена-носителя:

    (venv) $ http GET http://localhost:5000/api/users/1 \
        "Authorization:Bearer pC1Nu9wwyNt8VCj1trWilFdFI276AcbS"

### Отмена токенов

Последняя функция, связанная с токеном, которую я собираюсь реализовать, --- это отзыв токена, который Вы можете увидеть ниже:

> **`app/api/tokens.py:`** Revoke tokens.

    from app.api.auth import token_auth

    @bp.route('/tokens', methods=['DELETE'])
    @token_auth.login_required
    def revoke_token():
        g.current_user.revoke_token()
        db.session.commit()
        return '', 204

Клиенты могут отправить запрос `DELETE` на удаление по URL-адресу */tokens* , чтобы аннулировать маркер. Проверка подлинности для этого маршрута основана на маркере, на самом деле маркер, отправляемый в заголовке `Authorization` , является отозванным. Само аннулирование использует вспомогательный метод в классе `User` , который сбрасывает дату истечения срока действия маркера. Сеанс базы данных фиксируется таким образом, что это изменение записывается в базу данных. Ответ от этого запроса не имеет тела, поэтому я могу вернуть пустую строку. Второе значение в инструкции return задает код состояния ответа 204, который используется для успешных запросов, не имеющих тела ответа.

Вот пример запроса на отзыв токена, отправленного из HTTPie:

    (venv) $ http DELETE http://localhost:5000/api/tokens \
        Authorization:"Bearer pC1Nu9wwyNt8VCj1trWilFdFI276AcbS"

### Сообщения об ошибках API

Вы помните, что произошло в начале этой главы, когда я попросил вас отправить запрос API из браузера с недействительным URL-адресом пользователя? Сервер вернул ошибку 404, но эта ошибка была отформатирована как стандартная страница ошибки 404 HTML. Многие ошибки, которые может потребоваться вернуть API, могут быть переопределены версиями JSON в схеме элементов API, но есть некоторые ошибки, обрабатываемые Flask, которые по-прежнему проходят через обработчики ошибок, глобально зарегистрированные для приложения, и они продолжают возвращать HTML.

Протокол HTTP поддерживает механизм, с помощью которого клиент и сервер могут согласовать оптимальный Формат ответа, называемый согласованием содержимого. Клиенту необходимо отправить Заголовок `Accept` с запросом, указав предпочтения формата. Затем сервер смотрит на список и отвечает, используя лучший формат, который он поддерживает из списка, предлагаемого клиентом.

Я хочу изменить глобальные обработчики ошибок приложений, чтобы они использовали согласование содержимого для ответа в HTML или JSON в соответствии с предпочтениями клиента. Это можно сделать с помощью объекта Flask `request.accept_mimetypes` :

> **`app/errors/handlers.py:`** Согласование содержимого для ответов об ошибках.

    from flask import render_template, request
    from app import db
    from app.errors import bp
    from app.api.errors import error_response as api_error_response

    def wants_json_response():
        return request.accept_mimetypes['application/json'] >= \
            request.accept_mimetypes['text/html']

    @bp.app_errorhandler(404)
    def not_found_error(error):
        if wants_json_response():
            return api_error_response(404)
        return render_template('errors/404.html'), 404

    @bp.app_errorhandler(500)
    def internal_error(error):
        db.session.rollback()
        if wants_json_response():
            return api_error_response(500)
        return render_template('errors/500.html'), 500
:::
